<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>SyntacticConstruct.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect ssrfun ssrbool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk0"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> base.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> MatchingLogic.Utils
<span class="kn">Require Import</span>
    extralibrary
    stdpp_ext
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk1"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> fin_sets.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> MatchingLogic
<span class="kn">Require Import</span>
    Pattern
    Substitution
    IndexManipulation
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> MatchingLogic.Substitution.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">with_signature</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Î£</span> : Signature}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**</span>
<span class="sd">  * General substitutions</span>


<span class="sd">  First, we extract the information that identify the different substiutions:</span>
<span class="sd">  - How to &quot;step&quot; or &quot;increase&quot; (mostly de Bruijn indices) some properties</span>
<span class="sd">    in the recursive calls for binders</span>
<span class="sd">  - How the substitutions work for variables (both set and element, bound and free)</span>
<span class="sd">*)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">SpecificSubst</span> {<span class="nv">A</span> : <span class="kt">Type</span>} : <span class="kt">Type</span> := {
      increase_ex : A -&gt; A;
      increase_mu : A -&gt; A;
      on_fevar : A -&gt; <span class="nb">evar</span> -&gt; Pattern;
      on_fsvar : A -&gt; svar -&gt; Pattern;
      on_bevar : A -&gt; db_index -&gt; Pattern;
      on_bsvar : A -&gt; db_index -&gt; Pattern;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(**</span>
<span class="sd">    We define the general structure of substitutions, and use the specific</span>
<span class="sd">    information for the binders and the variables defined in `SpeificSubst`.</span>
<span class="sd">   *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">apply_subst</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">s</span> : SpecificSubst) (<span class="nv">st</span> : A) (<span class="nv">phi</span> : Pattern) :=
    <span class="kr">match</span> phi <span class="kr">with</span>
    | patt_free_evar x =&gt; on_fevar s st x
    | patt_free_svar X =&gt; on_fsvar s st X
    | patt_bound_evar n =&gt; on_bevar s st n
    | patt_bound_svar N =&gt; on_bsvar s st N
    | patt_sym sm =&gt; patt_sym sm
    | patt_app phi1 phi2 =&gt; patt_app (apply_subst s st phi1) (apply_subst s st phi2)
    | patt_bott =&gt; patt_bott
    | patt_imp phi1 phi2 =&gt; patt_imp (apply_subst s st phi1) (apply_subst s st phi2)
    | patt_exists phi&#39; =&gt; patt_exists (apply_subst s (increase_ex s st) phi&#39;)
    | patt_mu phi&#39; =&gt; patt_mu (apply_subst s (increase_mu s st) phi&#39;)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** For substitutions that can be described with the previous definition,</span>
<span class="sd">      we can instantiate the following type class: *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">PatternMorphism</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) := {
      pm_spec_data : SpecificSubst ;
      pm_ezero_increase : <span class="kr">forall</span> <span class="nv">a</span>,
        on_bevar pm_spec_data (increase_ex pm_spec_data a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span> ;
      pm_szero_increase : <span class="kr">forall</span> <span class="nv">a</span>,
        on_bsvar pm_spec_data (increase_mu pm_spec_data a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span> ;
      pm_correctness : <span class="kr">forall</span> <span class="nv">a</span> (<span class="nv">phi</span> : Pattern), f a phi = apply_subst pm_spec_data a phi
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Variable quantifications are such morphisms: *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Evar_quantify_morphism</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) :
     PatternMorphism (evar_quantify x&#39;) := {
    pm_spec_data := {|
      increase_ex := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">level</span> <span class="nv">x</span> =&gt; <span class="kr">if</span> decide (x&#39; = x)
                                 <span class="kr">then</span> patt_bound_evar level
                                 <span class="kr">else</span> patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk2"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_evar level
             <span class="kr">else</span> patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
â†’ db_index â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_evar level
             <span class="kr">else</span> patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
â†’ db_index â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{{<span class="nb">evar</span>:x&#39;â†¦a}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7"><span class="nb">intros</span> x&#39; db Ï†.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
        <span class="kr">if</span> is_left (decide (x&#39; = x))
        <span class="kr">then</span> patt_bound_evar level
        <span class="kr">else</span> patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9"><span class="nb">induction</span> Ï†; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chka"><hr></label><div class="goal-conclusion">patt_app (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkb"><hr></label><div class="goal-conclusion">patt_imp (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkc"><hr></label><div class="goal-conclusion">patt_exists (Ï†^{{<span class="nb">evar</span>:x&#39;â†¦S db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) Ï†)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkd"><hr></label><div class="goal-conclusion">patt_mu (Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chke">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkf">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk10">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (Ï†1^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml (Ï†2^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk11">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
(Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar :=
<span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_evar level
<span class="kr">else</span> patt_free_evar x;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (Ï†^{{<span class="nb">evar</span>:x&#39;â†¦S db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk12">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
(Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar :=
<span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_evar level
<span class="kr">else</span> patt_free_evar x;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (Ï†^{{<span class="nb">evar</span>:x&#39;â†¦db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Svar_quantify_morphism</span> (<span class="nv">x&#39;</span> : svar) :
     PatternMorphism (svar_quantify x&#39;) := {
    pm_spec_data := {|
      increase_ex := id;
      increase_mu := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_evar X;
      on_fsvar := <span class="kr">fun</span> <span class="nv">level</span> <span class="nv">x</span> =&gt; <span class="kr">if</span> decide (x&#39; = x)
                                 <span class="kr">then</span> patt_bound_svar level
                                 <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk13"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
             patt_free_evar X;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_svar level
             <span class="kr">else</span> patt_free_svar x;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk14"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
â†’ db_index â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk15"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
             patt_free_evar X;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_svar level
             <span class="kr">else</span> patt_free_svar x;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk16"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
â†’ db_index â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk17"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{{svar:x&#39;â†¦a}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk18"><span class="nb">intros</span> x&#39; db Ï†.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï†^{{svar:x&#39;â†¦db}})%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
        <span class="kr">if</span> is_left (decide (x&#39; = x))
        <span class="kr">then</span> patt_bound_svar level
        <span class="kr">else</span> patt_free_svar x;
    on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk19"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk1a"><span class="nb">induction</span> Ï†; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†1^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†2^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1b"><hr></label><div class="goal-conclusion">patt_app (Ï†1^{{svar:x&#39;â†¦db}})%ml (Ï†2^{{svar:x&#39;â†¦db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†1^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†2^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1c"><hr></label><div class="goal-conclusion">patt_imp (Ï†1^{{svar:x&#39;â†¦db}})%ml (Ï†2^{{svar:x&#39;â†¦db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1d"><hr></label><div class="goal-conclusion">patt_exists (Ï†^{{svar:x&#39;â†¦db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1e"><hr></label><div class="goal-conclusion">patt_mu (Ï†^{{svar:x&#39;â†¦S db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) Ï†)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk1f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk20">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†1^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†2^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (Ï†1^{{svar:x&#39;â†¦db}})%ml (Ï†2^{{svar:x&#39;â†¦db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk21">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†1^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (Ï†2^{{svar:x&#39;â†¦db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (Ï†1^{{svar:x&#39;â†¦db}})%ml (Ï†2^{{svar:x&#39;â†¦db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk22">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
(Ï†^{{svar:x&#39;â†¦db}})%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
on_fsvar :=
<span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_svar level
<span class="kr">else</span> patt_free_svar x;
on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (Ï†^{{svar:x&#39;â†¦db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk23">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
(Ï†^{{svar:x&#39;â†¦db}})%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
on_fsvar :=
<span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_svar level
<span class="kr">else</span> patt_free_svar x;
on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (Ï†^{{svar:x&#39;â†¦S db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Bevar_subst_morphism</span> (<span class="nv">Ïˆ</span> : Pattern) :
     PatternMorphism (bevar_subst Ïˆ) := {
    pm_spec_data := {|
      increase_ex := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">n</span> =&gt;
        <span class="kr">match</span> compare_nat n x <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_evar n
        | Nat_equal _ _ _ =&gt; Ïˆ
        | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
        <span class="kr">end</span>;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk24"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              Ïˆ <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n
                                            x
                                            wildcard&#39; =
                                          filtered_var),
                 Ïˆ <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater
                                            n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk25"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
â†’ db_index â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk26"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              Ïˆ <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n
                                            x
                                            wildcard&#39; =
                                          filtered_var),
                 Ïˆ <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater
                                            n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk27"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
â†’ db_index â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk28"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[<span class="nb">evar</span>:aâ†¦Ïˆ])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              Ïˆ <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk29"><span class="nb">intros</span> x&#39; db Ï†.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
        <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
          <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_evar n <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
          <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                       wildcard&#39; =
                                     filtered_var), x&#39;
          <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
          <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_evar (Nat.pred n) <span class="kr">in</span>
        <span class="kr">match</span>
          filtered_var <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span> (anonymous&#39; = filtered_var â†’ Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            program_branch_0 wildcard&#39;
        | Nat_equal _ _ wildcard&#39; =&gt;
            program_branch_1 wildcard&#39;
        | Nat_greater _ _ wildcard&#39; =&gt;
            program_branch_2 wildcard&#39;
        <span class="kr">end</span> (erefl filtered_var);
    on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk2a"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk2b"><span class="nb">induction</span> Ï†; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_evar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_evar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_evar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2c"><hr></label><div class="goal-conclusion">patt_app (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2d"><hr></label><div class="goal-conclusion">patt_imp (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2e"><hr></label><div class="goal-conclusion">patt_exists (Ï†^[<span class="nb">evar</span>:S dbâ†¦x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) Ï†)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2f"><hr></label><div class="goal-conclusion">patt_mu (Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk30">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_evar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_evar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_evar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk31">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk32">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (Ï†1^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml (Ï†2^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk33">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar :=
<span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x wildcard&#39; = filtered_var),
patt_bound_evar n <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
          filtered_var),
patt_bound_evar (Nat.pred n) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var);
on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (Ï†^[<span class="nb">evar</span>:S dbâ†¦x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk34">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar :=
<span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x wildcard&#39; = filtered_var),
patt_bound_evar n <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
          filtered_var),
patt_bound_evar (Nat.pred n) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var);
on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (Ï†^[<span class="nb">evar</span>:dbâ†¦x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Bsvar_subst_morphism</span> (<span class="nv">Ïˆ</span> : Pattern) :
     PatternMorphism (bsvar_subst Ïˆ) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">X</span> <span class="nv">N</span> =&gt;
        <span class="kr">match</span> compare_nat N X <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_svar N
        | Nat_equal _ _ _ =&gt; Ïˆ
        | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred N)
        <span class="kr">end</span>;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk35"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              Ïˆ <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N
                                            X
                                            wildcard&#39; =
                                          filtered_var),
                 Ïˆ <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater
                                            N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk36"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
â†’ db_index â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk37"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              Ïˆ <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N
                                            X
                                            wildcard&#39; =
                                          filtered_var),
                 Ïˆ <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater
                                            N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk38"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
â†’ db_index â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk39"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[svar:aâ†¦Ïˆ])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              Ïˆ <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3a"><span class="nb">intros</span> x&#39; db Ï†.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï†^[svar:dbâ†¦x&#39;])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
        <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
          <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_svar N <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
          <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                       wildcard&#39; =
                                     filtered_var), x&#39;
          <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
          <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_svar (Nat.pred N) <span class="kr">in</span>
        <span class="kr">match</span>
          filtered_var <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span> (anonymous&#39; = filtered_var â†’ Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            program_branch_0 wildcard&#39;
        | Nat_equal _ _ wildcard&#39; =&gt;
            program_branch_1 wildcard&#39;
        | Nat_greater _ _ wildcard&#39; =&gt;
            program_branch_2 wildcard&#39;
        <span class="kr">end</span> (erefl filtered_var)
  |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3b"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3c"><span class="nb">induction</span> Ï†; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_svar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_svar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk3d"><hr></label><div class="goal-conclusion">patt_app (Ï†1^[svar:dbâ†¦x&#39;])%ml (Ï†2^[svar:dbâ†¦x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk3e"><hr></label><div class="goal-conclusion">patt_imp (Ï†1^[svar:dbâ†¦x&#39;])%ml (Ï†2^[svar:dbâ†¦x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk3f"><hr></label><div class="goal-conclusion">patt_exists (Ï†^[svar:dbâ†¦x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk40"><hr></label><div class="goal-conclusion">patt_mu (Ï†^[svar:S dbâ†¦x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} (S db) Ï†)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk41">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_svar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_svar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk42">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (Ï†1^[svar:dbâ†¦x&#39;])%ml (Ï†2^[svar:dbâ†¦x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk43">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†1^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (Ï†2^[svar:dbâ†¦x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (Ï†1^[svar:dbâ†¦x&#39;])%ml (Ï†2^[svar:dbâ†¦x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk44">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(Ï†^[svar:dbâ†¦x&#39;])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar :=
<span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X wildcard&#39; = filtered_var),
patt_bound_svar N <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
          filtered_var),
patt_bound_svar (Nat.pred N) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var)
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (Ï†^[svar:dbâ†¦x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk45">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(Ï†^[svar:dbâ†¦x&#39;])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar :=
<span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X wildcard&#39; = filtered_var),
patt_bound_svar N <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
          filtered_var),
patt_bound_svar (Nat.pred N) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var â†’ Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var)
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (Ï†^[svar:S dbâ†¦x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X â†’ Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} (S db) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Evar_open_morphism</span> (<span class="nv">x</span> : <span class="nb">evar</span>) :
     PatternMorphism (evar_open x) := {
    pm_spec_data := {|
      increase_ex := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">dbi</span> <span class="nv">n</span> =&gt;
        <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_evar n
        | Nat_equal _ _ _ =&gt; patt_free_evar x
        | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
        <span class="kr">end</span>;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk46"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_evar x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
             patt_free_evar x0;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                              dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_evar x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk47"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
â†’ db_index â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk48"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_evar x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
             patt_free_evar x0;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                              dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_evar x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk49"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
â†’ db_index â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{<span class="nb">evar</span>:aâ†¦x})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_evar x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4b"><span class="nb">unfold</span> evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[<span class="nb">evar</span>:aâ†¦patt_free_evar x])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">match</span>
            compare_nat n dbi <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = compare_nat n dbi
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n dbi wildcard&#39; =
                    compare_nat n dbi,
                patt_bound_evar n
          | Nat_equal _ _ wildcard&#39; =&gt;
              <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n dbi wildcard&#39; =
                    compare_nat n dbi,
                patt_free_evar x
          | Nat_greater _ _ wildcard&#39; =&gt;
              <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n dbi wildcard&#39; =
                    compare_nat n dbi,
                patt_bound_evar (Nat.pred n)
          <span class="kr">end</span> (erefl (compare_nat n dbi));
      on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(phi^[<span class="nb">evar</span>:aâ†¦patt_free_evar x])%ml =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
        <span class="kr">match</span>
          compare_nat n dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat n dbi â†’ Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n dbi wildcard&#39; =
                  compare_nat n dbi, patt_bound_evar n
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n dbi wildcard&#39; =
                  compare_nat n dbi, patt_free_evar x
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n dbi wildcard&#39; =
                  compare_nat n dbi,
              patt_bound_evar (Nat.pred n)
        <span class="kr">end</span> (erefl (compare_nat n dbi));
    on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4d"><span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a phi =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Î»</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
        <span class="kr">match</span>
          compare_nat n dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat n dbi â†’ Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less n dbi wildcard&#39; =
                  compare_nat n dbi, patt_bound_evar n
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal n dbi wildcard&#39; =
                  compare_nat n dbi, patt_free_evar x
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater n dbi wildcard&#39; =
                  compare_nat n dbi,
              patt_bound_evar (Nat.pred n)
        <span class="kr">end</span> (erefl (compare_nat n dbi));
    on_bsvar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Svar_open_morphism</span> (<span class="nv">X</span> : svar) :
     PatternMorphism (svar_open X) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">Dbi</span> <span class="nv">N</span> =&gt;
        <span class="kr">match</span> compare_nat N Dbi <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_svar N
        | Nat_equal _ _ _ =&gt; patt_free_svar X
        | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred N)
        <span class="kr">end</span>;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4e"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_svar X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
             patt_free_svar X0;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                              Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_svar X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
â†’ db_index â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk50"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_svar X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
             patt_free_svar X0;
         on_bevar :=
           <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                              Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_svar X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var â†’ Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk51"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
â†’ db_index â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk52"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{svar:aâ†¦X})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_svar X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Î»</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk53"><span class="nb">unfold</span> svar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[svar:aâ†¦patt_free_svar X])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">match</span>
            compare_nat N Dbi <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = compare_nat N Dbi
               â†’ Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N Dbi wildcard&#39; =
                    compare_nat N Dbi,
                patt_bound_svar N
          | Nat_equal _ _ wildcard&#39; =&gt;
              <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N Dbi wildcard&#39; =
                    compare_nat N Dbi,
                patt_free_svar X
          | Nat_greater _ _ wildcard&#39; =&gt;
              <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N Dbi wildcard&#39; =
                    compare_nat N Dbi,
                patt_bound_svar (Nat.pred N)
          <span class="kr">end</span> (erefl (compare_nat N Dbi))
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk54"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(phi^[svar:aâ†¦patt_free_svar X])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
        <span class="kr">match</span>
          compare_nat N Dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat N Dbi â†’ Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_bound_svar N
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_free_svar X
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N Dbi wildcard&#39; =
                  compare_nat N Dbi,
              patt_bound_svar (Nat.pred N)
        <span class="kr">end</span> (erefl (compare_nat N Dbi))
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk55"><span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a phi =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Î»</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Î»</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
        <span class="kr">match</span>
          compare_nat N Dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat N Dbi â†’ Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_less N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_bound_svar N
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_equal N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_free_svar X
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Î»</span> <span class="nv">_</span> : Nat_greater N Dbi wildcard&#39; =
                  compare_nat N Dbi,
              patt_bound_svar (Nat.pred N)
        <span class="kr">end</span> (erefl (compare_nat N Dbi))
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Free_evar_subst_morphism</span> (<span class="nv">Ïˆ</span> : Pattern) :
     PatternMorphism (free_evar_subst Ïˆ) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> =&gt; <span class="kr">if</span> decide (x = x&#39;) <span class="kr">then</span> Ïˆ <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk56"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;))
          <span class="kr">then</span> Ïˆ
          <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
             <span class="kr">if</span> is_left (decide (x = x&#39;))
             <span class="kr">then</span> Ïˆ
             <span class="kr">else</span> patt_free_evar x&#39;;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk57"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern â†’ <span class="nb">evar</span> â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk58"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;))
          <span class="kr">then</span> Ïˆ
          <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
             <span class="kr">if</span> is_left (decide (x = x&#39;))
             <span class="kr">then</span> Ïˆ
             <span class="kr">else</span> patt_free_evar x&#39;;
         on_fsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
         on_bevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk59"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern â†’ <span class="nb">evar</span> â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>) (<span class="nv">phi</span> : Pattern),
  (phi^[[<span class="nb">evar</span>:aâ†¦Ïˆ]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;))
          <span class="kr">then</span> Ïˆ
          <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5b"><span class="nb">intros</span> x&#39; db Ï†.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := id;
    on_fevar :=
      <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
        <span class="kr">if</span> is_left (decide (x = x&#39;0))
        <span class="kr">then</span> x&#39;
        <span class="kr">else</span> patt_free_evar x&#39;0;
    on_fsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
  |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5c"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5d"><span class="nb">induction</span> Ï†; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_evar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk5e"><hr></label><div class="goal-conclusion">patt_app (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk5f"><hr></label><div class="goal-conclusion">patt_imp (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk60"><hr></label><div class="goal-conclusion">patt_exists (Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk61"><hr></label><div class="goal-conclusion">patt_mu (Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk62">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_evar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk63">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk64">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (Ï†1^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml (Ï†2^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk65">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
(Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar :=
<span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
<span class="kr">if</span> is_left (decide (x = x&#39;0)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x&#39;0;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk66">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
(Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar :=
<span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
<span class="kr">if</span> is_left (decide (x = x&#39;0)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x&#39;0;
on_fsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (Ï†^[[<span class="nb">evar</span>:dbâ†¦x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Free_svar_subst_morphism</span> (<span class="nv">Ïˆ</span> : Pattern) :
     PatternMorphism (free_svar_subst Ïˆ) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x ;
      on_fsvar := <span class="kr">fun</span> <span class="nv">X</span> <span class="nv">X&#39;</span> =&gt; <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> Ïˆ <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk67"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : svar),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> Ïˆ
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
             <span class="kr">if</span> is_left (decide (X = X&#39;))
             <span class="kr">then</span> Ïˆ
             <span class="kr">else</span> patt_free_svar X&#39;;
         on_bevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk68"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern â†’ svar â†’ patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk69"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : svar),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> Ïˆ
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
         on_fsvar :=
           <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
             <span class="kr">if</span> is_left (decide (X = X&#39;))
             <span class="kr">then</span> Ïˆ
             <span class="kr">else</span> patt_free_svar X&#39;;
         on_bevar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern â†’ svar â†’ patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6b"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">a</span> : svar) (<span class="nv">phi</span> : Pattern),
  (phi^[[svar:aâ†¦Ïˆ]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> Ïˆ
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6c"><span class="nb">intros</span> x&#39; db Ï†.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï†^[[svar:dbâ†¦x&#39;]])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := id;
    on_fevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
        <span class="kr">if</span> is_left (decide (X = X&#39;))
        <span class="kr">then</span> x&#39;
        <span class="kr">else</span> patt_free_svar X&#39;;
    on_bevar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
  |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6d"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} db Ï†</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6e"><span class="nb">induction</span> Ï†; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†1^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk6f"><hr></label><div class="goal-conclusion">patt_app (Ï†1^[[svar:dbâ†¦x&#39;]])%ml (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†1^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk70"><hr></label><div class="goal-conclusion">patt_imp (Ï†1^[[svar:dbâ†¦x&#39;]])%ml (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk71"><hr></label><div class="goal-conclusion">patt_exists (Ï†^[[svar:dbâ†¦x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk72"><hr></label><div class="goal-conclusion">patt_mu (Ï†^[[svar:dbâ†¦x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk73">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk74">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†1^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (Ï†1^[[svar:dbâ†¦x&#39;]])%ml (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk75">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†1^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†1</span></span></span><br><span><var>IHÏ†2</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db Ï†2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (Ï†1^[[svar:dbâ†¦x&#39;]])%ml (Ï†2^[[svar:dbâ†¦x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHÏ†1, IHÏ†2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk76">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
(Ï†^[[svar:dbâ†¦x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar :=
<span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
<span class="kr">if</span> is_left (decide (X = X&#39;)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar X&#39;;
on_bevar := <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (Ï†^[[svar:dbâ†¦x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk77">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHÏ†</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
(Ï†^[[svar:dbâ†¦x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar := <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar :=
<span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
<span class="kr">if</span> is_left (decide (X = X&#39;)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar X&#39;;
on_bevar := <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db Ï†</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (Ï†^[[svar:dbâ†¦x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Î»</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Î»</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHÏ†.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**</span>
<span class="sd">   * Substitution type classes for the different syntacical cateories</span>

<span class="sd">   Every syntactic construct has a category (unary operator, binder etc),</span>
<span class="sd">   and has to have certain properties about well-formedness</span>
<span class="sd">   and substitution.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Binary</span> (<span class="nv">binary</span> : Pattern -&gt; Pattern -&gt; Pattern) := {
    binary_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi1</span> <span class="nv">phi2</span> : Pattern) <span class="nv">a</span>,
        f a (binary phi1 phi2) = binary (f a phi1) (f a phi2) ;
     binary_wf : <span class="kr">forall</span> <span class="nv">Ïˆ1</span> <span class="nv">Ïˆ2</span>, well_formed Ïˆ1 -&gt; well_formed Ïˆ2 -&gt; 
        well_formed (binary Ïˆ1 Ïˆ2) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Unary</span> (<span class="nv">unary</span> : Pattern -&gt; Pattern) := {
    unary_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
        f a (unary phi) = unary (f a phi) ;
    unary_wf : <span class="kr">forall</span> <span class="nv">Ïˆ</span>, well_formed Ïˆ -&gt; well_formed (unary Ïˆ) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Nullary</span> (<span class="nv">nullary</span> : Pattern) := {
    nullary_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) <span class="nv">a</span>,
        f a nullary = nullary ;
    nullary_wf : well_formed nullary ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">EBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern) := {
    ebinder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
        f a (<span class="kn">binder</span> phi) = <span class="kn">binder</span> (f (increase_ex pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">SBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern) := {
    sbinder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
        f a (<span class="kn">binder</span> phi) = <span class="kn">binder</span> (f (increase_mu pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Next, we define instances for the primitives of matching logic: *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">EBinder_exists</span> : EBinder patt_exists := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk78"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ Pattern â†’ Pattern) (<span class="nv">f_morph</span> : 
                                          PatternMorphism
                                            f) (<span class="nv">phi</span> : Pattern) 
  (<span class="nv">a</span> : A),
  f a (patt_exists phi) =
  patt_exists (f (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk79"><span class="nb">intros</span> A f m Ï† a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_exists Ï†) =
patt_exists (f (increase_ex pm_spec_data a) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7a"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_exists Ï†) =
patt_exists
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) Ï†) =
patt_exists
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">SBinder_mu</span> : SBinder patt_mu := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7c"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ Pattern â†’ Pattern) (<span class="nv">f_morph</span> : 
                                          PatternMorphism
                                            f) (<span class="nv">phi</span> : Pattern) 
  (<span class="nv">a</span> : A),
  f a (patt_mu phi) =
  patt_mu (f (increase_mu pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7d"><span class="nb">intros</span> A f m Ï† a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_mu Ï†) =
patt_mu (f (increase_mu pm_spec_data a) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7e"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_mu Ï†) =
patt_mu
  (apply_subst pm_spec_data
     (increase_mu pm_spec_data a) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu
  (apply_subst pm_spec_data
     (increase_mu pm_spec_data a) Ï†) =
patt_mu
  (apply_subst pm_spec_data
     (increase_mu pm_spec_data a) Ï†)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Binary_imp</span> : Binary patt_imp := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk80"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ Pattern â†’ Pattern),
  PatternMorphism f
  â†’ <span class="kr">âˆ€</span> (<span class="nv">phi1</span> <span class="nv">phi2</span> : Pattern) (<span class="nv">a</span> : A),
      f a (patt_imp phi1 phi2) =
      patt_imp (f a phi1) (f a phi2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk81"><span class="nb">intros</span> A f m Ï†1 Ï†2 a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_imp Ï†1 Ï†2) = patt_imp (f a Ï†1) (f a Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk82"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_imp Ï†1 Ï†2) =
patt_imp (apply_subst pm_spec_data a Ï†1)
  (apply_subst pm_spec_data a Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk83"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (apply_subst pm_spec_data a Ï†1)
  (apply_subst pm_spec_data a Ï†2) =
patt_imp (apply_subst pm_spec_data a Ï†1)
  (apply_subst pm_spec_data a Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk84"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Ïˆ1</span> <span class="nv">Ïˆ2</span> : Pattern,
  well_formed Ïˆ1
  â†’ well_formed Ïˆ2 â†’ well_formed (patt_imp Ïˆ1 Ïˆ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk85"><span class="nb">intros</span> Ï†1 Ï†2 WF1 WF2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WF1</var><span class="hyp-type"><b>: </b><span>well_formed Ï†1</span></span></span><br><span><var>WF2</var><span class="hyp-type"><b>: </b><span>well_formed Ï†2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (patt_imp Ï†1 Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> well_formed_imp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Binary_app</span> : Binary patt_app := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk86"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ Pattern â†’ Pattern),
  PatternMorphism f
  â†’ <span class="kr">âˆ€</span> (<span class="nv">phi1</span> <span class="nv">phi2</span> : Pattern) (<span class="nv">a</span> : A),
      f a (patt_app phi1 phi2) =
      patt_app (f a phi1) (f a phi2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk87"><span class="nb">intros</span> A f m Ï†1 Ï†2 a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_app Ï†1 Ï†2) = patt_app (f a Ï†1) (f a Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk88"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_app Ï†1 Ï†2) =
patt_app (apply_subst pm_spec_data a Ï†1)
  (apply_subst pm_spec_data a Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk89"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (apply_subst pm_spec_data a Ï†1)
  (apply_subst pm_spec_data a Ï†2) =
patt_app (apply_subst pm_spec_data a Ï†1)
  (apply_subst pm_spec_data a Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Ïˆ1</span> <span class="nv">Ïˆ2</span> : Pattern,
  well_formed Ïˆ1
  â†’ well_formed Ïˆ2 â†’ well_formed (patt_app Ïˆ1 Ïˆ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8b"><span class="nb">intros</span> Ï†1 Ï†2 WF1 WF2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ï†1, Ï†2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WF1</var><span class="hyp-type"><b>: </b><span>well_formed Ï†1</span></span></span><br><span><var>WF2</var><span class="hyp-type"><b>: </b><span>well_formed Ï†2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (patt_app Ï†1 Ï†2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> well_formed_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Nullary_bott</span> : Nullary patt_bott := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8c"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ Pattern â†’ Pattern),
  PatternMorphism f
  â†’ <span class="kr">âˆ€</span> <span class="nv">a</span> : A, f a patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8d"><span class="nb">intros</span> A f m a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8e"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk90"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Nullary_sym</span> <span class="nv">s</span> : Nullary (patt_sym s) := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk91"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">s</span> : symbols) (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ Pattern â†’ Pattern),
  PatternMorphism f
  â†’ <span class="kr">âˆ€</span> <span class="nv">a</span> : A, f a (patt_sym s) = patt_sym s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk92"><span class="nb">intros</span> A s f m a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>s â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_sym A) = patt_sym A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk93"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>s â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_sym A) = patt_sym A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk94"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>s â†’ Pattern â†’ Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_sym A = patt_sym A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk95"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">s</span> : symbols, well_formed (patt_sym s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">SwappableEx</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">g</span> : Pattern -&gt; Pattern)
  (<span class="nv">m</span> : PatternMorphism f) :=
{
  eswap : <span class="kr">forall</span> <span class="nv">phi</span> <span class="nv">a</span>,
    apply_subst pm_spec_data (increase_ex pm_spec_data a) (g phi) =
    g (apply_subst pm_spec_data a phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Bevar_subst_swaps_ex_nesting</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">p</span> : well_formed_closed Ïˆ) :
  SwappableEx _ nest_ex (Bevar_subst_morphism Ïˆ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk96"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Ïˆ</span> : Pattern,
  well_formed_closed Ïˆ
  â†’ <span class="kr">âˆ€</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk97"><span class="nb">intros</span> Ïˆ WFÏˆ phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk98"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data aâ†¦Ïˆ])%ml =
nest_ex (phi^[<span class="nb">evar</span>:aâ†¦Ïˆ])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk99"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               aâ†¦Ïˆ])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[<span class="nb">evar</span>:aâ†¦Ïˆ])%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9a"><span class="nb">rewrite</span> &lt;- nest_ex_gt; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               aâ†¦Ïˆ])%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:a + <span class="mi">1</span>â†¦Ïˆ])%ml</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk9b"><hr></label><div class="goal-conclusion">a â‰¥ <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9c"><span class="mi">2</span>: <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               aâ†¦Ïˆ])%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:a + <span class="mi">1</span>â†¦Ïˆ])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9d"><span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               aâ†¦Ïˆ])%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:<span class="mi">1</span> + aâ†¦Ïˆ])%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Bsvar_subst_swaps_ex_nesting</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">p</span> : well_formed_closed Ïˆ) :
  SwappableEx _ nest_ex (Bsvar_subst_morphism Ïˆ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9e"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Ïˆ</span> : Pattern,
  well_formed_closed Ïˆ
  â†’ <span class="kr">âˆ€</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9f"><span class="nb">intros</span> Ïˆ WFÏˆ phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka0"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[svar:increase_ex pm_spec_data aâ†¦Ïˆ])%ml =
nest_ex (phi^[svar:aâ†¦Ïˆ])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka1"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[svar:increase_ex pm_spec_data
                               aâ†¦Ïˆ])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[svar:aâ†¦Ïˆ])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka2"><span class="nb">rewrite</span> bsvar_subst_nest_ex_aux_comm; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux Ïˆ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka3"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> WFÏˆ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux Ïˆ <span class="mi">0</span> = true âˆ§ well_formed_closed_ex_aux Ïˆ <span class="mi">0</span> = true</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux Ïˆ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> WFÏˆ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Fevar_subst_swaps_ex_nesting</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">p</span> : well_formed_closed Ïˆ) :
  SwappableEx _ nest_ex (Free_evar_subst_morphism Ïˆ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka4"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Ïˆ</span> : Pattern,
  well_formed_closed Ïˆ
  â†’ <span class="kr">âˆ€</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka5"><span class="nb">intros</span> Ïˆ WFÏˆ phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka6"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[[<span class="nb">evar</span>:increase_ex pm_spec_data aâ†¦Ïˆ]])%ml =
nest_ex (phi^[[<span class="nb">evar</span>:aâ†¦Ïˆ]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka7"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[[<span class="nb">evar</span>:increase_ex pm_spec_data
                                aâ†¦Ïˆ]])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[[<span class="nb">evar</span>:aâ†¦Ïˆ]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka8"><span class="nb">rewrite</span> nest_ex_free_evar_subst; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux Ïˆ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka9"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> WFÏˆ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux Ïˆ <span class="mi">0</span> = true âˆ§ well_formed_closed_ex_aux Ïˆ <span class="mi">0</span> = true</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux Ïˆ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> WFÏˆ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Fsvar_subst_swaps_ex_nesting</span> (<span class="nv">Ïˆ</span> : Pattern) (<span class="nv">p</span> : well_formed_closed Ïˆ) :
  SwappableEx _ nest_ex (Free_svar_subst_morphism Ïˆ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkaa"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Ïˆ</span> : Pattern,
  well_formed_closed Ïˆ
  â†’ <span class="kr">âˆ€</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : svar),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkab"><span class="nb">intros</span> Ïˆ WFÏˆ phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkac"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[[svar:increase_ex pm_spec_data aâ†¦Ïˆ]])%ml =
nest_ex (phi^[[svar:aâ†¦Ïˆ]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkad"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[[svar:increase_ex pm_spec_data
                                aâ†¦Ïˆ]])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[[svar:aâ†¦Ïˆ]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkae"><span class="nb">rewrite</span> nest_ex_free_svar_subst; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed Ïˆ</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux Ïˆ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkaf"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> WFÏˆ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFÏˆ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux Ïˆ <span class="mi">0</span> = true âˆ§ well_formed_closed_ex_aux Ïˆ <span class="mi">0</span> = true</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux Ïˆ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> WFÏˆ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Evar_quantify_swaps_ex_nesting</span> (<span class="nv">x</span> : <span class="nb">evar</span>) :
  SwappableEx _ nest_ex (Evar_quantify_morphism x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb0"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb1"><span class="nb">intros</span> Ïˆ phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb2"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^{{<span class="nb">evar</span>:Ïˆâ†¦increase_ex pm_spec_data a}})%ml =
nest_ex (phi^{{<span class="nb">evar</span>:Ïˆâ†¦a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb3"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:Ïˆâ†¦increase_ex
                                  pm_spec_data a}})%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^{{<span class="nb">evar</span>:Ïˆâ†¦a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb4"><span class="nb">rewrite</span> &lt;- nest_ex_gt_evar_quantify; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:Ïˆâ†¦increase_ex
                                  pm_spec_data a}})%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:Ïˆâ†¦a + <span class="mi">1</span>}})%ml</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkb5"><hr></label><div class="goal-conclusion">a â‰¥ <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb6"><span class="mi">2</span>: <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:Ïˆâ†¦increase_ex
                                  pm_spec_data a}})%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:Ïˆâ†¦a + <span class="mi">1</span>}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb7"><span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:Ïˆâ†¦increase_ex
                                  pm_spec_data a}})%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:Ïˆâ†¦<span class="mi">1</span> + a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Svar_quantify_swaps_ex_nesting</span> (<span class="nv">X</span> : svar) :
  SwappableEx _ nest_ex (Svar_quantify_morphism X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb8"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">X</span> : svar) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb9"><span class="nb">intros</span> Ïˆ phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkba"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^{{svar:Ïˆâ†¦increase_ex pm_spec_data a}})%ml =
nest_ex (phi^{{svar:Ïˆâ†¦a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbb"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Ïˆ</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{svar:Ïˆâ†¦increase_ex
                                  pm_spec_data a}})%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^{{svar:Ïˆâ†¦a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> nest_ex_svar_quantify.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Evar_open_swaps_ex_nesting</span> (<span class="nv">x</span> : <span class="nb">evar</span>) :
  SwappableEx _ nest_ex (Evar_open_morphism x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbc"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* TODO: here type class inference fails without the explicit parameters *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (@eswap _ _ _ _ (Bevar_subst_swaps_ex_nesting (patt_free_evar x) _)); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Svar_open_swaps_ex_nesting</span> (<span class="nv">X</span> : svar) :
  SwappableEx _ nest_ex (Svar_open_morphism X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbe"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">X</span> : svar) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* TODO: here type class inference fails without the explicit parameters *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (@eswap _ _ _ _ (Bsvar_subst_swaps_ex_nesting (patt_free_svar X) _)); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: mu operations:</span>

<span class="c">Class SwappableMu {A : Type} (f : A -&gt; Pattern -&gt; Pattern) (g : Pattern -&gt; Pattern)</span>
<span class="c">  (m : PatternMorphism f) :=</span>
<span class="c">{</span>
<span class="c">  szero_increase : forall a,</span>
<span class="c">    apply_subst spec_data (increase_mu spec_data a) (patt_bound_svar 0) = patt_bound_svar 0 ;</span>
<span class="c">  sswap_f_g : forall phi a,</span>
<span class="c">    apply_subst spec_data (increase_mu spec_data a) (g phi) =</span>
<span class="c">    g (apply_subst spec_data a phi) ;</span>
<span class="c">}.</span>

<span class="c">#[global]</span>
<span class="c">Program Instance Bsvar_subst_swaps_nesting (Ïˆ : Pattern) (p : well_formed_closed Ïˆ) :</span>
<span class="c">  @SwappableMu _ (bsvar_subst Ïˆ) nest_mu (Bsvar_subst_morphism Ïˆ).</span>
<span class="c">Next Obligation.</span>
<span class="c">  intros. rewrite &lt;- correctness. reflexivity.</span>
<span class="c">Defined.</span>
<span class="c">Next Obligation.</span>
<span class="c">  intros Ïˆ WFÏˆ phi a.</span>
<span class="c">  do 2 rewrite &lt;- correctness.</span>
<span class="c">  unfold nest_mu. rewrite &lt;- nest_mu_gt; auto. 2: lia.</span>
<span class="c">  rewrite Nat.add_comm. reflexivity.</span>
<span class="c">Defined. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ESortedBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern -&gt; Pattern) (<span class="nv">g</span> : Pattern -&gt; Pattern) := {
    esorted_binder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern)
         (<span class="nv">f_morph</span> : PatternMorphism f)
         (<span class="nv">f_swap</span> : SwappableEx f g f_morph) (<span class="nv">s</span> <span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
      f a (<span class="kn">binder</span> s phi) = <span class="kn">binder</span> (f a s) (f (increase_ex pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">SSortedBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern -&gt; Pattern) (<span class="nv">g</span> : Pattern -&gt; Pattern) := {
    ssorted_binder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern)
         (<span class="nv">f_morph</span> : PatternMorphism f)
         (<span class="nv">f_swap</span> : SwappableEx f g f_morph) (<span class="nv">s</span> <span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
      f a (<span class="kn">binder</span> s phi) = <span class="kn">binder</span> (f a s) (f (increase_mu pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Next, we define the substitution simplification record: *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mlSimpl&#39;</span> :=
(
  @binary_morphism,
  @unary_morphism,
  @nullary_morphism,
  @ebinder_morphism,
  @sbinder_morphism
).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_signature</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">  Hints are needed to automatically infer the SwappableEx instances.</span>
<span class="c">  TODO: there is still a problem when the well_formed_closed assumption is</span>
<span class="c">        missing</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Bevar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Bsvar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Fevar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Fsvar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Evar_quantify_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Svar_quantify_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Evar_open_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Svar_open_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**</span>
<span class="sd">  This tactic identifies the sorted binder for simplification (by checking its type).</span>
<span class="sd">  Since automatic identification of the instance of the type class is not working</span>
<span class="sd">  currently, we identify the correct instance by giving the parameters inferred</span>
<span class="sd">  from the context.</span>

<span class="sd">  TODO: more strict identification of the point where the simplification has to be</span>
<span class="sd">        made, since nested sorted quantifiers can occur, which break the tactic.</span>
<span class="sd">        One potential solution is to use Ltac2.</span>
<span class="sd">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simpl_sorted_quantification</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span> G [<span class="nl">?f</span> <span class="nl">?arg</span> _ (<span class="nl">?binder</span> _ _)] =&gt;
    <span class="kr">match</span> <span class="kp">type of</span> <span class="kn">binder</span> <span class="kr">with</span>
    | Pattern -&gt; Pattern -&gt; Pattern =&gt;
      <span class="kr">tryif</span>
       <span class="nb">unshelve</span> (<span class="nb">erewrite</span> (@esorted_binder_morphism _ <span class="kn">binder</span>
            _ _ _ (f arg) _ _));
       <span class="kr">match goal with</span>
       | |- SwappableEx _ _ _ =&gt; <span class="nb">auto</span>
       | |- PatternMorphism _ =&gt; <span class="bp">now</span> <span class="nb">typeclasses eauto</span>
       | |- ESortedBinder _ _ =&gt; <span class="kr">tryif</span> <span class="bp">now</span> <span class="nb">typeclasses eauto</span> <span class="kr">then</span> <span class="kp">idtac</span> <span class="kr">else</span> <span class="kp">fail</span> <span class="mi">3</span>
       | _ =&gt; <span class="kp">idtac</span>
       <span class="kr">end</span>
      <span class="kr">then</span> <span class="kp">idtac</span>
      <span class="kr">else</span> <span class="kp">idtac</span> <span class="c">(* &quot;No sorted simplification instance for &quot; binder *)</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simpl_sorted_quantification_hyp</span> H :=
<span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | <span class="kp">context</span> G [<span class="nl">?f</span> <span class="nl">?arg</span> _ (<span class="nl">?binder</span> _ _)] =&gt; 
    <span class="kr">match</span> <span class="kp">type of</span> <span class="kn">binder</span> <span class="kr">with</span>
    | Pattern -&gt; Pattern -&gt; Pattern =&gt; 
      <span class="kr">tryif</span>
       (<span class="kr">let</span> <span class="nv">name</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span>
         <span class="nb">unshelve</span> (<span class="nb">epose proof</span> (name := @esorted_binder_morphism _ <span class="kn">binder</span>
            _ _ _ (f arg) _ _)); <span class="kp">try</span> (<span class="nb">rewrite</span> name <span class="kr">in</span> H; <span class="nb">clear</span> name);
            <span class="kp">try</span> <span class="nb">typeclasses eauto</span>; <span class="nb">auto</span>;
            <span class="kr">match goal with</span>
             | |- SwappableEx _ _ _ =&gt; <span class="nb">clear</span> H
             | |- PatternMorphism _ =&gt; <span class="nb">clear</span> H; <span class="bp">now</span> <span class="nb">typeclasses eauto</span>
             | |- ESortedBinder _ _ =&gt; <span class="nb">clear</span> H; <span class="kr">tryif</span> <span class="bp">now</span> <span class="nb">typeclasses eauto</span> <span class="kr">then</span> <span class="kp">idtac</span> <span class="kr">else</span> <span class="kp">fail</span> <span class="mi">3</span>
             | _ =&gt; <span class="kp">idtac</span>
            <span class="kr">end</span>
              )
      <span class="kr">then</span> <span class="kp">idtac</span>
      <span class="kr">else</span> <span class="kp">idtac</span> <span class="c">(* &quot;No sorted simplification instance for &quot; binder *)</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Test</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Substitution.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Î£</span> : Signature}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlSimpl&quot;</span> :=
  <span class="kp">repeat</span> (<span class="nb">rewrite</span> mlSimpl&#39; + simpl_sorted_quantification); <span class="kp">try</span> <span class="nb">rewrite</span> [increase_ex _ _]/=; <span class="kp">try</span> <span class="nb">rewrite</span> [increase_mu]/=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlSimpl&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kp">repeat</span> (<span class="nb">rewrite</span> mlSimpl&#39; <span class="kr">in</span> H + simpl_sorted_quantification_hyp H); <span class="kp">try</span> <span class="nb">rewrite</span> [increase_ex _ _]/= <span class="kr">in</span> H; <span class="kp">try</span> <span class="nb">rewrite</span> [increase_mu _ _]/= <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">patt_forall_of_sort</span> (<span class="nv">sort</span> <span class="nv">phi</span> : Pattern) : Pattern :=
    patt_exists (patt_imp (patt_imp (patt_bound_evar <span class="mi">0</span>) (nest_ex sort)) phi).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local]
  <span class="kn">Program Instance</span> <span class="nf">sorted_forall_binder</span> : ESortedBinder patt_forall_of_sort nest_ex := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc0"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ Pattern â†’ Pattern) (<span class="nv">f_morph</span> : 
                                          PatternMorphism
                                            f),
  SwappableEx f nest_ex f_morph
  â†’ <span class="kr">âˆ€</span> (<span class="nv">s</span> <span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : A),
      f a (patt_forall_of_sort s phi) =
      patt_forall_of_sort (f a s)
        (f (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_forall_of_sort s phi) =
patt_forall_of_sort (f a s)
  (f (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc2"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_forall_of_sort s phi) =
patt_forall_of_sort (apply_subst pm_spec_data a s)
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists
  (patt_imp
     (patt_imp
        (on_bevar pm_spec_data
           (increase_ex pm_spec_data a) <span class="mi">0</span>)
        (apply_subst pm_spec_data
           (increase_ex pm_spec_data a) (nest_ex s)))
     (apply_subst pm_spec_data
        (increase_ex pm_spec_data a) phi)) =
patt_forall_of_sort (apply_subst pm_spec_data a s)
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc4"><span class="nb">rewrite</span> eswap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ Pattern â†’ Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists
  (patt_imp
     (patt_imp
        (on_bevar pm_spec_data
           (increase_ex pm_spec_data a) <span class="mi">0</span>)
        (nest_ex (apply_subst pm_spec_data a s)))
     (apply_subst pm_spec_data
        (increase_ex pm_spec_data a) phi)) =
patt_forall_of_sort (apply_subst pm_spec_data a s)
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> pm_ezero_increase.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc5"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">Ïˆ</span> <span class="nv">x</span>, <span class="c">(* well_formed_closed Ïˆ -&gt; *)</span>
(patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>: x â†¦ Ïˆ]] = patt_bott -&gt;
(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>: <span class="mi">0</span> â†¦ x} = patt_bott -&gt;
(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>: x â†¦ <span class="mi">0</span>}} = patt_bott -&gt;
(patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>: x â†¦ Ïˆ]] = patt_bott /\ 
(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>: <span class="mi">0</span> â†¦ x} = patt_bott /\
(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>: x â†¦ <span class="mi">0</span>}} = patt_bott
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">s</span> <span class="nv">Ïˆ</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott
  â†’ (patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott
    â†’ (patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
      patt_bott
      â†’ (patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
        patt_bott
        âˆ§ (patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} =
          patt_bott
          âˆ§ (patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
            patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">s</span> <span class="nv">Ïˆ</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott
  â†’ (patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott
    â†’ (patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
      patt_bott
      â†’ (patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
        patt_bott
        âˆ§ (patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} =
          patt_bott
          âˆ§ (patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
            patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott
âˆ§ (patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott
  âˆ§ (patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc8">mlSimpl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst Ïˆ) nest_ex
  (Free_evar_subst_morphism Ïˆ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkc9"><hr></label><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott
âˆ§ patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x}
    Ïˆ^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>â†¦x} = patt_bott
  âˆ§ patt_forall_of_sort s^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}}
      Ïˆ^{{<span class="nb">evar</span>:xâ†¦increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkca"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott
âˆ§ patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x}
    Ïˆ^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>â†¦x} = patt_bott
  âˆ§ patt_forall_of_sort s^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}}
      Ïˆ^{{<span class="nb">evar</span>:xâ†¦increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkcb">mlSimpl <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst Ïˆ) nest_ex
  (Free_evar_subst_morphism Ïˆ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkcc"><hr></label><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott
âˆ§ patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x}
    Ïˆ^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>â†¦x} = patt_bott
  âˆ§ patt_forall_of_sort s^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}}
      Ïˆ^{{<span class="nb">evar</span>:xâ†¦increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkcd"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott
âˆ§ patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x}
    Ïˆ^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>â†¦x} = patt_bott
  âˆ§ patt_forall_of_sort s^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}}
      Ïˆ^{{<span class="nb">evar</span>:xâ†¦increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkce">mlSimpl <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} Ïˆ^{<span class="nb">evar</span>:<span class="mi">1</span>â†¦x} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott
âˆ§ patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x}
    Ïˆ^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>â†¦x} = patt_bott
  âˆ§ patt_forall_of_sort s^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}}
      Ïˆ^{{<span class="nb">evar</span>:xâ†¦increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">mlSimpl <span class="kr">in</span> H1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkcf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{<span class="nb">evar</span>:<span class="mi">0</span>â†¦x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s Ïˆ)^{{<span class="nb">evar</span>:xâ†¦<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst Ïˆ) nest_ex
  (Free_evar_subst_morphism Ïˆ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd0"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">Ïˆ</span> <span class="nv">x</span>, <span class="c">(* well_formed_closed Ïˆ -&gt; *)</span>
(patt_forall_of_sort (patt_imp s s) Ïˆ)^[[<span class="nb">evar</span>: x â†¦ Ïˆ]] = patt_bott
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">s</span> <span class="nv">Ïˆ</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort (patt_imp s s) Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
  patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">s</span> <span class="nv">Ïˆ</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort (patt_imp s s) Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
  patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(patt_forall_of_sort (patt_imp s s) Ïˆ)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] =
patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd3">simpl_sorted_quantification.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst Ïˆ) nest_ex
  (Free_evar_subst_morphism Ïˆ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkd4"><hr></label><div class="goal-conclusion">patt_forall_of_sort (patt_imp s s)^[[<span class="nb">evar</span>:xâ†¦Ïˆ]]
  Ïˆ^[[<span class="nb">evar</span>:increase_ex pm_spec_data xâ†¦Ïˆ]] = patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd5"><span class="mi">2</span>: mlSimpl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst Ïˆ) nest_ex
  (Free_evar_subst_morphism Ïˆ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Î£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, Ïˆ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkd6"><hr></label><div class="goal-conclusion">patt_forall_of_sort
  (patt_imp s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] s^[[<span class="nb">evar</span>:xâ†¦Ïˆ]])
  Ïˆ^[[<span class="nb">evar</span>:xâ†¦Ïˆ]] = patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Test</span>.</span></span></pre></article></body></html>