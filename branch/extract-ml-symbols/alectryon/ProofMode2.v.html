<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>ProofMode2.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect ssrfun ssrbool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> <span class="kn">Ltac2</span> <span class="kn">Require Import</span> <span class="kn">Ltac2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Ensembles Bool String Btauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq.Logic <span class="kn">Require Import</span> FunctionalExtensionality Eqdep_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> <span class="kn">Equations</span> <span class="nf">Require</span> <span class="nv">Import</span> <span class="nv">Equations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk0"><span class="kn">From</span> MatchingLogic <span class="kn">Require Import</span> Syntax DerivedOperators_Syntax ProofSystem IndexManipulation wftactics Logic ProofMode BasicProofSystemLemmas ProofInfo.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> list tactics fin_sets coGset gmap sets.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> MatchingLogic.Utils <span class="kn">Require Import</span> stdpp_ext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> extralibrary.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span>
  MatchingLogic.Logic.Notations
  MatchingLogic.DerivedOperators_Syntax.Notations
  MatchingLogic.ProofSystem.Notations
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Exports *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> MatchingLogic.ProofSystem.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kt">Set</span> Default <span class="kn">Proof</span> Mode <span class="s2">&quot;Classic&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ProofModeEntry</span> {<span class="nv">Œ£</span> : Signature} :=
| pme_pattern (p : Pattern)
| pme_variable
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">named_hypothesis</span> {<span class="nv">Œ£</span> : Signature} := mkNH
  {
    nh_name : string;
    nh_pme : ProofModeEntry;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;N ‚à∂ P&quot;</span> :=
  (@mkNH _ N P)
  (<span class="kn">at level</span> <span class="mi">100</span>, <span class="kn">no associativity</span>, <span class="kn">format</span> <span class="s2">&quot;N  &#39;‚à∂&#39;  P&quot;</span>, <span class="kn">only printing</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hypotheses</span> {<span class="nv">Œ£</span> : Signature} := list named_hypothesis.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&quot;</span> :=
  (@nil named_hypothesis)
  (<span class="kn">at level</span> <span class="mi">100</span>, <span class="kn">left associativity</span>, <span class="kn">only printing</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(*TODO: Ensure that this does not add parentheses*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ,&quot;</span> :=
  (@cons named_hypothesis x nil)
  (<span class="kn">at level</span> <span class="mi">100</span>, <span class="kn">left associativity</span>, <span class="kn">format</span> <span class="s2">&quot;x &#39;,&#39; &#39;//&#39;&quot;</span>, <span class="kn">only printing</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x , y , .. , z ,&quot;</span> :=
  (@cons named_hypothesis x (cons y .. (cons z nil) ..))
  (<span class="kn">at level</span> <span class="mi">100</span>, <span class="kn">left associativity</span>, <span class="kn">format</span> <span class="s2">&quot;x &#39;,&#39; &#39;//&#39; y &#39;,&#39; &#39;//&#39; .. &#39;,&#39; &#39;//&#39; z &#39;,&#39; &#39;//&#39;&quot;</span>, <span class="kn">only printing</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">names_of</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">h</span> : hypotheses) : list string := map nh_name h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pmes_of</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">h</span> : hypotheses) : list ProofModeEntry := map nh_pme h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">has_name</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">n</span> : string) (<span class="nv">nh</span> : named_hypothesis) : <span class="kt">Prop</span>
:= nh_name nh = n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2">#[<span class="kn">global</span>]
<span class="kn">Instance</span> <span class="nf">has_name_dec</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">n</span> <span class="nv">nh</span> : Decision (has_name n nh).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>nh</var><span class="hyp-type"><b>: </b><span>named_hypothesis</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (has_name n nh)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>nh</var><span class="hyp-type"><b>: </b><span>named_hypothesis</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (has_name n nh)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4"><span class="nb">unfold</span> has_name.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>nh</var><span class="hyp-type"><b>: </b><span>named_hypothesis</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (nh_name nh = n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">solve_decision.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">find_hyp</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">name</span> : string) (<span class="nv">hyps</span> : hypotheses) : option (nat * named_hypothesis)%type
:= stdpp.list.list_find (has_name name) hyps.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">MLGoal</span> {<span class="nv">Œ£</span> : Signature} : <span class="kt">Type</span> := mkMLGoal
  { mlTheory : Theory;
    mlHypotheses: hypotheses;
    mlConclusion : Pattern ;
    mlInfo : ProofSystem.ProofInfo ;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">MLGoal_from_goal</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory) (<span class="nv">goal</span> : Pattern) (<span class="nv">pi</span> : ProofInfo)
  :
  MLGoal
  := mkMLGoal Œ£ Œì nil goal pi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">connect</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">h</span> : ProofModeEntry) (<span class="nv">i</span> : Pattern) :=
  (
    <span class="kr">match</span> h <span class="kr">with</span>
    | pme_pattern p =&gt; patt_imp p i
    | pme_variable =&gt; patt_forall i
    <span class="kr">end</span>
  ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">MLGoal_to_pattern&#39;</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">concl</span>: Pattern) (<span class="nv">pmes</span> : list ProofModeEntry)
  : Pattern
:= fold_right connect concl pmes.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">MLGoal_to_pattern</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">MG</span> : MLGoal) : Pattern
:= MLGoal_to_pattern&#39; (mlConclusion MG) (pmes_of (mlHypotheses MG)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">of_MLGoal</span> {Œ£ : Signature} (MG : MLGoal) : <span class="kt">Type</span> :=
  well_formed (MLGoal_to_pattern MG) -&gt;
  (mlTheory MG) ‚ä¢i (MLGoal_to_pattern MG)
  <span class="nb">using</span> (mlInfo MG).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


  <span class="c">(* This is useful only for printing. </span>
<span class="c">     0x2c75 was used for the ‚ä¢ to avoid collision *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;G &#39;‚±µ&#39; g &#39;using&#39; pi &quot;</span>
  := (mkMLGoal _ G [] g pi)
  (<span class="kn">at level</span> <span class="mi">95</span>,
  <span class="kn">no associativity</span>,
  <span class="kn">format</span> <span class="s2">&quot;G  &#39;‚±µ&#39; &#39;//&#39; g &#39;//&#39; &#39;using&#39;  pi &#39;//&#39;&quot;</span>,
  <span class="kn">only printing</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;G &#39;‚±µ&#39; g&quot;</span>
  := (mkMLGoal _ G [] g AnyReasoning)
  (<span class="kn">at level</span> <span class="mi">95</span>,
  <span class="kn">no associativity</span>,
  <span class="kn">format</span> <span class="s2">&quot;G  &#39;‚±µ&#39; &#39;//&#39;  g &#39;//&#39;&quot;</span>,
  <span class="kn">only printing</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;G &#39;‚±µ&#39; l -------------------------------------- g &#39;using&#39; pi &quot;</span>
  := (mkMLGoal _ G l g pi)
  (<span class="kn">at level</span> <span class="mi">95</span>,
  <span class="kn">no associativity</span>,
  <span class="kn">format</span> <span class="s2">&quot;G  &#39;‚±µ&#39; &#39;//&#39; l -------------------------------------- &#39;//&#39; g &#39;//&#39; &#39;using&#39;  pi &#39;//&#39;&quot;</span>,
  <span class="kn">only printing</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;G &#39;‚±µ&#39; l -------------------------------------- g&quot;</span>
  := (mkMLGoal _ G l g AnyReasoning)
  (<span class="kn">at level</span> <span class="mi">95</span>,
  <span class="kn">no associativity</span>,
  <span class="kn">format</span> <span class="s2">&quot;G  &#39;‚±µ&#39; &#39;//&#39; l -------------------------------------- &#39;//&#39; g &#39;//&#39;&quot;</span>,
  <span class="kn">only printing</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">toMLGoal</span> :=
  <span class="nb">unfold</span> ProofSystem.derives;
  <span class="kr">lazymatch goal with</span>
  | [ |- <span class="nl">?G</span> ‚ä¢i <span class="nl">?phi</span> <span class="nb">using</span> <span class="nl">?pi</span>]
    =&gt; <span class="nb">cut</span> (of_MLGoal (MLGoal_from_goal G phi pi));
       <span class="nb">unfold</span> MLGoal_from_goal;
       [(<span class="nb">unfold</span> of_MLGoal; <span class="nb">simpl</span>; <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span> <span class="nb">intros</span> H; <span class="nb">apply</span> H; <span class="nb">clear</span> H; <span class="nb">cbn</span>)|]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fromMLGoal</span> := <span class="nb">unfold</span> of_MLGoal; <span class="nb">cbn</span>; <span class="nb">intros</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5"><span class="kn">Local Example</span> <span class="nf">ex_toMLGoal</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">Œì</span> (<span class="nv">p</span> : Pattern) :
  well_formed p -&gt;
  Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed p ‚Üí Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed p ‚Üí Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk7"><span class="nb">intros</span> wfp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk8">toMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (p ---&gt; p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk9"><hr></label><div class="goal-conclusion">Œì ‚±µ
p ---&gt; p
<span class="nb">using</span> BasicReasoning
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (p ---&gt; p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
p ---&gt; p
<span class="nb">using</span> BasicReasoning
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc"><span class="kr">match goal with</span>
  | [ |- of_MLGoal (mkMLGoal Œ£ Œì [] (p ---&gt; p) BasicReasoning) ] =&gt; <span class="kp">idtac</span>
  | _ =&gt; <span class="kp">fail</span>
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
p ---&gt; p
<span class="nb">using</span> BasicReasoning
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd">fromMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke"><span class="kn">Lemma</span> <span class="nf">cast_proof_ml_hyps</span> {<span class="nv">Œ£</span> : Signature}
  <span class="nv">Œì</span> <span class="nv">hyps</span> <span class="nv">hyps&#39;</span>
  (<span class="nv">e</span> : hyps = hyps&#39;) <span class="nv">goal</span> (<span class="nv">i</span> : ProofInfo)
  :
  mkMLGoal Œ£ Œì hyps goal i -&gt;
  mkMLGoal Œ£ Œì hyps&#39; goal i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
goal
<span class="nb">using</span> i

‚Üí Œì ‚±µ
hyps&#39;--------------------------------------
goal
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
goal
<span class="nb">using</span> i

‚Üí Œì ‚±µ
hyps&#39;--------------------------------------
goal
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk10"><span class="nb">unfold</span> of_MLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed
   (MLGoal_to_pattern
      (Œì ‚±µ
       hyps--------------------------------------
       goal
       <span class="nb">using</span> i
       ))
 ‚Üí mlTheory
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      )
   ‚ä¢i MLGoal_to_pattern
        (Œì ‚±µ
         hyps--------------------------------------
         goal
         <span class="nb">using</span> i
         )
   <span class="nb">using</span> mlInfo
           (Œì ‚±µ
            hyps--------------------------------------
            goal
            <span class="nb">using</span> i
            ))
‚Üí well_formed
    (MLGoal_to_pattern
       (Œì ‚±µ
        hyps&#39;--------------------------------------
        goal
        <span class="nb">using</span> i
        ))
  ‚Üí mlTheory
      (Œì ‚±µ
       hyps&#39;--------------------------------------
       goal
       <span class="nb">using</span> i
       )
    ‚ä¢i MLGoal_to_pattern
         (Œì ‚±µ
          hyps&#39;--------------------------------------
          goal
          <span class="nb">using</span> i
          )
    <span class="nb">using</span> mlInfo
            (Œì ‚±µ
             hyps&#39;--------------------------------------
             goal
             <span class="nb">using</span> i
             )</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk11"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed
   (MLGoal_to_pattern
      (Œì ‚±µ
       hyps--------------------------------------
       goal
       <span class="nb">using</span> i
       ))
 ‚Üí Œì
   ‚ä¢i MLGoal_to_pattern
        (Œì ‚±µ
         hyps--------------------------------------
         goal
         <span class="nb">using</span> i
         ) <span class="nb">using</span> i)
‚Üí well_formed
    (MLGoal_to_pattern
       (Œì ‚±µ
        hyps&#39;--------------------------------------
        goal
        <span class="nb">using</span> i
        ))
  ‚Üí Œì
    ‚ä¢i MLGoal_to_pattern
         (Œì ‚±µ
          hyps&#39;--------------------------------------
          goal
          <span class="nb">using</span> i
          ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk12"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps&#39;--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk13"><span class="nb">intros</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk14">feed <span class="nb">specialize</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk15"><hr></label><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk16">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk17"><span class="nb">rewrite</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> wfall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk18">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk19"><span class="nb">unshelve</span> (<span class="nb">eapply</span> (@cast_proof&#39; Œ£ Œì _ _ i _ H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MLGoal_to_pattern
  (Œì ‚±µ
   hyps&#39;--------------------------------------
   goal
   <span class="nb">using</span> i
   ) =
MLGoal_to_pattern
  (Œì ‚±µ
   hyps--------------------------------------
   goal
   <span class="nb">using</span> i
   )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a"><span class="nb">rewrite</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps, hyps'</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>hyps = hyps&#39;</span></span></span><br><span><var>goal</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps&#39;--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MLGoal_to_pattern
  (Œì ‚±µ
   hyps&#39;--------------------------------------
   goal
   <span class="nb">using</span> i
   ) =
MLGoal_to_pattern
  (Œì ‚±µ
   hyps&#39;--------------------------------------
   goal
   <span class="nb">using</span> i
   )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b"><span class="kn">Lemma</span> <span class="nf">cast_proof_ml_goal</span> {<span class="nv">Œ£</span> : Signature}
  <span class="nv">Œì</span> <span class="nv">hyps</span> <span class="nv">goal</span> <span class="nv">goal&#39;</span>
  (<span class="nv">e</span> : goal = goal&#39;) (<span class="nv">i</span> : ProofInfo):
  mkMLGoal Œ£ Œì hyps goal i -&gt;
  mkMLGoal Œ£ Œì hyps goal&#39; i .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
goal
<span class="nb">using</span> i

‚Üí Œì ‚±µ
hyps--------------------------------------
goal&#39;
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
goal
<span class="nb">using</span> i

‚Üí Œì ‚±µ
hyps--------------------------------------
goal&#39;
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d"><span class="nb">unfold</span> of_MLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed
   (MLGoal_to_pattern
      (Œì ‚±µ
       hyps--------------------------------------
       goal
       <span class="nb">using</span> i
       ))
 ‚Üí mlTheory
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      )
   ‚ä¢i MLGoal_to_pattern
        (Œì ‚±µ
         hyps--------------------------------------
         goal
         <span class="nb">using</span> i
         )
   <span class="nb">using</span> mlInfo
           (Œì ‚±µ
            hyps--------------------------------------
            goal
            <span class="nb">using</span> i
            ))
‚Üí well_formed
    (MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal&#39;
        <span class="nb">using</span> i
        ))
  ‚Üí mlTheory
      (Œì ‚±µ
       hyps--------------------------------------
       goal&#39;
       <span class="nb">using</span> i
       )
    ‚ä¢i MLGoal_to_pattern
         (Œì ‚±µ
          hyps--------------------------------------
          goal&#39;
          <span class="nb">using</span> i
          )
    <span class="nb">using</span> mlInfo
            (Œì ‚±µ
             hyps--------------------------------------
             goal&#39;
             <span class="nb">using</span> i
             )</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed
   (MLGoal_to_pattern
      (Œì ‚±µ
       hyps--------------------------------------
       goal
       <span class="nb">using</span> i
       ))
 ‚Üí Œì
   ‚ä¢i MLGoal_to_pattern
        (Œì ‚±µ
         hyps--------------------------------------
         goal
         <span class="nb">using</span> i
         ) <span class="nb">using</span> i)
‚Üí well_formed
    (MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal&#39;
        <span class="nb">using</span> i
        ))
  ‚Üí Œì
    ‚ä¢i MLGoal_to_pattern
         (Œì ‚±µ
          hyps--------------------------------------
          goal&#39;
          <span class="nb">using</span> i
          ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal&#39;
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk20"><span class="nb">intros</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk21">feed <span class="nb">specialize</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk22"><hr></label><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk23">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk24"><span class="nb">rewrite</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        goal
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> wfall.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk25">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk26"><span class="nb">unshelve</span> (<span class="nb">eapply</span> (@cast_proof&#39; Œ£ Œì _ _ i _ H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MLGoal_to_pattern
  (Œì ‚±µ
   hyps--------------------------------------
   goal&#39;
   <span class="nb">using</span> i
   ) =
MLGoal_to_pattern
  (Œì ‚±µ
   hyps--------------------------------------
   goal
   <span class="nb">using</span> i
   )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk27"><span class="nb">rewrite</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>goal, goal'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>goal = goal&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      goal&#39;
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MLGoal_to_pattern
  (Œì ‚±µ
   hyps--------------------------------------
   goal&#39;
   <span class="nb">using</span> i
   ) =
MLGoal_to_pattern
  (Œì ‚±µ
   hyps--------------------------------------
   goal&#39;
   <span class="nb">using</span> i
   )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* Extracts well-formedness assumptions about (local) goal and (local) hypotheses. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlExtractWF&quot;</span> <span class="kn">ident</span>(wfa) :=
<span class="kr">match goal with</span>
| [ |- <span class="nl">?g</span> ] =&gt;
  <span class="kr">let</span> <span class="nv">wfa&#39;</span> := <span class="kp">fresh</span> <span class="s2">&quot;wfa&#39;&quot;</span> <span class="kr">in</span>
  <span class="nb">intros</span> wfa&#39;;
  <span class="nb">pose proof</span> (wfa := wfa&#39;);
  <span class="nb">revert</span> wfa&#39;;
  <span class="nb">fold</span> g;
  <span class="nb">cbn</span> <span class="kr">in</span> wfa
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk28"><span class="kn">Local Example</span> <span class="nf">ex_extractWfAssumptions</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">Œì</span> (<span class="nv">p</span> : Pattern) :
  well_formed p -&gt;
  Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed p ‚Üí Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed p ‚Üí Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a"><span class="nb">intros</span> wfp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i p ---&gt; p <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b">toMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (p ---&gt; p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2c"><hr></label><div class="goal-conclusion">Œì ‚±µ
p ---&gt; p
<span class="nb">using</span> BasicReasoning
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (p ---&gt; p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
p ---&gt; p
<span class="nb">using</span> BasicReasoning
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f">mlExtractWF wfa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed (p ---&gt; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
p ---&gt; p
<span class="nb">using</span> BasicReasoning
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* These two asserts by assumption only test presence of the two hypotheses *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk30"><span class="nb">assert</span> (well_formed (p ---&gt; p)) <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfp</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>wfa, H</var><span class="hyp-type"><b>: </b><span>well_formed (p ---&gt; p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
p ---&gt; p
<span class="nb">using</span> BasicReasoning
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk31"><span class="kn">Lemma</span> <span class="nf">MLGoal_introImpl</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory) (<span class="nv">l</span> : hypotheses) (<span class="nv">name</span> : string) (<span class="nv">x</span> <span class="nv">g</span> : Pattern)
  (<span class="nv">i</span> : ProofInfo) :
  mkMLGoal _ Œì (l ++ [mkNH _ name (pme_pattern x)]) g i -&gt;
  mkMLGoal _ Œì l (x ---&gt; g) i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l ++ (name ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i

‚Üí Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l ++ (name ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i

‚Üí Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk33"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
l ++ (name ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk34"><span class="nb">unfold</span> of_MLGoal <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí mlTheory
    (Œì ‚±µ
     l ++ (name ‚à∂ pme_pattern x,
           )--------------------------------------
     g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_pattern x,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        )
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_pattern x,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           )</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk35"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_pattern x,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk36"><span class="nb">unfold</span> of_MLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_pattern x,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      x ---&gt; g
      <span class="nb">using</span> i
      ))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     x ---&gt; g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        x ---&gt; g
        <span class="nb">using</span> i
        )
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk37"><span class="nb">unfold</span> MLGoal_to_pattern.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_pattern x,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         x ---&gt; g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            x ---&gt; g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     x ---&gt; g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern&#39;
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              x ---&gt; g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk38"><span class="nb">unfold</span> MLGoal_to_pattern&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_pattern x,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         x ---&gt; g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            x ---&gt; g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     x ---&gt; g
     <span class="nb">using</span> i
     )
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              x ---&gt; g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk39"><span class="nb">unfold</span> MLGoal_to_pattern <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39;
     (mlConclusion
        (Œì ‚±µ
         l ++ (name ‚à∂ pme_pattern x,
               )--------------------------------------
         g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l ++ (name ‚à∂ pme_pattern x,
                  )--------------------------------------
            g
            <span class="nb">using</span> i
            ))))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern&#39;
       (mlConclusion
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_pattern x,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l ++ (name ‚à∂ pme_pattern x,
                    )--------------------------------------
              g
              <span class="nb">using</span> i
              ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         x ---&gt; g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            x ---&gt; g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     x ---&gt; g
     <span class="nb">using</span> i
     )
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              x ---&gt; g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a"><span class="nb">unfold</span> MLGoal_to_pattern&#39; <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l ++ (name ‚à∂ pme_pattern x,
               )--------------------------------------
         g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l ++ (name ‚à∂ pme_pattern x,
                  )--------------------------------------
            g
            <span class="nb">using</span> i
            ))))
‚Üí Œì
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_pattern x,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l ++ (name ‚à∂ pme_pattern x,
                    )--------------------------------------
              g
              <span class="nb">using</span> i
              ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         x ---&gt; g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            x ---&gt; g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     x ---&gt; g
     <span class="nb">using</span> i
     )
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              x ---&gt; g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l ++ (name ‚à∂ pme_pattern x,
               )--------------------------------------
         g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l ++ (name ‚à∂ pme_pattern x,
                  )--------------------------------------
            g
            <span class="nb">using</span> i
            ))))
‚Üí Œì
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_pattern x,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l ++ (name ‚à∂ pme_pattern x,
                    )--------------------------------------
              g
              <span class="nb">using</span> i
              ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (pmes_of l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                       ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (pmes_of l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d"><span class="nb">intros</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                       ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e">feed <span class="nb">specialize</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                       ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3f"><hr></label><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk40">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                       ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk41"><span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk42"><span class="nb">unfold</span> pmes_of <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (map nh_pme (l ++ (name ‚à∂ pme_pattern x,
                        ))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk43"><span class="nb">rewrite</span> map_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (map nh_pme l ++
      map nh_pme (name ‚à∂ pme_pattern x,
                  )))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk44"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g (map nh_pme l ++ [pme_pattern x]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk45"><span class="nb">rewrite</span> foldr_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect (foldr connect g [pme_pattern x])
     (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk46"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> wfall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk47">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_pattern x,
                     ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk48"><span class="nb">unfold</span> pmes_of <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (map nh_pme (l ++ (name ‚à∂ pme_pattern x,
                        ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk49"><span class="nb">rewrite</span> map_app <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (map nh_pme l ++
      map nh_pme (name ‚à∂ pme_pattern x,
                  )) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (map nh_pme l ++ [pme_pattern x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b"><span class="nb">rewrite</span> foldr_app <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect (foldr connect g [pme_pattern x])
     (map nh_pme l) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplLocalContext</span> :=
  <span class="kr">match goal with</span>
    | [ |- @of_MLGoal <span class="nl">?Sgm</span> (mkMLGoal <span class="nl">?Sgm</span> <span class="nl">?Ctx</span> <span class="nl">?l</span> <span class="nl">?g</span> <span class="nl">?i</span>) ]
      =&gt; <span class="nb">eapply</span> cast_proof_ml_hyps;[(<span class="nb">rewrite</span> {<span class="mi">1</span>}[l]/app; <span class="bp">reflexivity</span>)|]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">_getHypNames</span> :=
  <span class="kr">lazymatch goal with</span>
  | [ |- of_MLGoal (mkMLGoal _ _ <span class="nl">?l</span> _ _) ] =&gt; <span class="kp">eval</span> <span class="nb">lazy</span> <span class="kr">in</span> (names_of l)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;_failIfUsed&quot;</span> <span class="kp">constr</span>(name) :=
  <span class="kr">lazymatch goal with</span>
  | [ |- of_MLGoal (mkMLGoal _ _ <span class="nl">?l</span> _ _) ] =&gt;
    <span class="kr">lazymatch</span> (<span class="kp">eval</span> <span class="nb">cbv</span> <span class="kr">in</span> (find_hyp name l)) <span class="kr">with</span>
    | Some _ =&gt; <span class="kp">fail</span> <span class="s2">&quot;The name&quot;</span> name <span class="s2">&quot;is already used&quot;</span>
    | _ =&gt; <span class="kp">idtac</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlIntro&quot;</span> <span class="kp">constr</span>(name&#39;) :=
_failIfUsed name&#39;; <span class="nb">apply</span> MLGoal_introImpl <span class="kr">with</span> (name := name&#39;); simplLocalContext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlIntro&quot;</span> :=
  <span class="kr">let</span> <span class="nv">hyps</span> := _getHypNames <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">name&#39;</span> := <span class="kp">eval</span> <span class="nb">cbv</span> <span class="kr">in</span> (<span class="kp">fresh</span> hyps) <span class="kr">in</span>
  mlIntro name&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d"><span class="kn">Local Example</span> <span class="nf">ex_mlIntro</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">Œì</span> <span class="nv">a</span> (<span class="nv">i</span> : ProofInfo) :
  well_formed a -&gt;
  Œì ‚ä¢i a ---&gt; a ---&gt; a ---&gt; a ---&gt; a <span class="nb">using</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí Œì ‚ä¢i a ---&gt; a ---&gt; a ---&gt; a ---&gt; a <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí Œì ‚ä¢i a ---&gt; a ---&gt; a ---&gt; a ---&gt; a <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f"><span class="nb">intros</span> wfa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i a ---&gt; a ---&gt; a ---&gt; a ---&gt; a <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk50">toMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (a ---&gt; a ---&gt; a ---&gt; a ---&gt; a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk51"><hr></label><div class="goal-conclusion">Œì ‚±µ
a ---&gt; a ---&gt; a ---&gt; a ---&gt; a
<span class="nb">using</span> i
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk52">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (a ---&gt; a ---&gt; a ---&gt; a ---&gt; a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk53">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
a ---&gt; a ---&gt; a ---&gt; a ---&gt; a
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk54">mlIntro <span class="s2">&quot;h&quot;</span>%string.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;h&quot;</span> ‚à∂ pme_pattern a,
--------------------------------------
a ---&gt; a ---&gt; a ---&gt; a
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk55"><span class="kn">Fail</span> mlIntro <span class="s2">&quot;h&quot;</span>%string.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Tactic failure: The name <span class="s2">&quot;h&quot;</span> <span class="kr">is</span> already used.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;h&quot;</span> ‚à∂ pme_pattern a,
--------------------------------------
a ---&gt; a ---&gt; a ---&gt; a
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk56">mlIntro <span class="s2">&quot;h&#39;&quot;</span>%string.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;h&quot;</span> ‚à∂ pme_pattern a,
<span class="s2">&quot;h&#39;&quot;</span> ‚à∂ pme_pattern a,
--------------------------------------
a ---&gt; a ---&gt; a
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk57"><span class="kp">do</span> <span class="mi">2</span> mlIntro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;h&quot;</span> ‚à∂ pme_pattern a,
<span class="s2">&quot;h&#39;&quot;</span> ‚à∂ pme_pattern a,
<span class="s2">&quot;0&quot;</span> ‚à∂ pme_pattern a,
<span class="s2">&quot;1&quot;</span> ‚à∂ pme_pattern a,
--------------------------------------
a
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk58"><span class="kn">Lemma</span> <span class="nf">MLGoal_revertLast</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory) (<span class="nv">l</span> : hypotheses) (<span class="nv">x</span> <span class="nv">g</span> : Pattern) (<span class="nv">n</span> : string) <span class="nv">i</span> :
  mkMLGoal Œ£ Œì l (x ---&gt; g) i -&gt;
  mkMLGoal Œ£ Œì (l ++ [mkNH _ n (pme_pattern x)]) g i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i

‚Üí Œì ‚±µ
l ++ (n ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i

‚Üí Œì ‚±µ
l ++ (n ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
l--------------------------------------
x ---&gt; g
<span class="nb">using</span> i
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l ++ (n ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b"><span class="nb">unfold</span> of_MLGoal <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      x ---&gt; g
      <span class="nb">using</span> i
      ))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     x ---&gt; g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        x ---&gt; g
        <span class="nb">using</span> i
        )
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           x ---&gt; g
           <span class="nb">using</span> i
           )</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l ++ (n ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      x ---&gt; g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        x ---&gt; g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l ++ (n ‚à∂ pme_pattern x,
      )--------------------------------------
g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5d"><span class="nb">unfold</span> of_MLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      x ---&gt; g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        x ---&gt; g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí mlTheory
    (Œì ‚±µ
     l ++ (n ‚à∂ pme_pattern x,
           )--------------------------------------
     g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (n ‚à∂ pme_pattern x,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        )
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l ++ (n ‚à∂ pme_pattern x,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      x ---&gt; g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        x ---&gt; g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (n ‚à∂ pme_pattern x,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5f"><span class="nb">intros</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      x ---&gt; g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        x ---&gt; g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk60"><span class="nb">cbn</span> <span class="kr">in</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      x ---&gt; g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        x ---&gt; g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk61"><span class="nb">cbn</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
  <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk62">feed <span class="nb">specialize</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
  <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (map nh_pme l))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk63"><hr></label><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk64">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
  <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk65"><span class="nb">rewrite</span> map_app <span class="kr">in</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
  <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme l ++
      map nh_pme (n ‚à∂ pme_pattern x,
                  )))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk66"><span class="nb">simpl</span> <span class="kr">in</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
  <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme l ++ [pme_pattern x]))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk67"><span class="nb">rewrite</span> foldr_app <span class="kr">in</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
  <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect
     (foldr connect g [pme_pattern x])
     (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk68"><span class="nb">simpl</span> <span class="kr">in</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))
‚Üí Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
  <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (x ---&gt; g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (x ---&gt; g) (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> wfall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk69">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (n ‚à∂ pme_pattern x,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk6a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                        ))) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk6b"><span class="nb">rewrite</span> map_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect g
     (map nh_pme l ++ map nh_pme (n ‚à∂ pme_pattern x,
                                  )) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk6c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect g (map nh_pme l ++ [pme_pattern x])
<span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk6d"><span class="nb">rewrite</span> foldr_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect (foldr connect g [pme_pattern x])
     (map nh_pme l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk6e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>x, g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (map nh_pme (l ++ (n ‚à∂ pme_pattern x,
                       ))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (x ---&gt; g) (map nh_pme l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Ltac</span> <span class="nf">mlRevertLast</span> :=
<span class="kr">match goal with</span>
| |- @of_MLGoal <span class="nl">?Sgm</span> (mkMLGoal <span class="nl">?Sgm</span> <span class="nl">?Ctx</span> <span class="nl">?l</span> <span class="nl">?g</span> <span class="nl">?i</span>)
=&gt; <span class="nb">eapply</span> cast_proof_ml_hyps;
   [(<span class="nb">rewrite</span> -[l](take_drop (length l - <span class="mi">1</span>)); <span class="nb">rewrite</span> [take _ _]/=; <span class="nb">rewrite</span> [drop _ _]/=; <span class="bp">reflexivity</span>)|];
   <span class="nb">apply</span> MLGoal_revertLast
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk6f"><span class="kn">Lemma</span> <span class="nf">MLGoal_introForall</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory) (<span class="nv">l</span> : hypotheses) (<span class="nv">name</span> : string) (<span class="nv">g</span> : Pattern)
  (<span class="nv">i</span> : ProofInfo) :
  mkMLGoal _ Œì (l ++ [mkNH _ name (pme_variable)]) g i -&gt;
  mkMLGoal _ Œì l (<span class="kp">all</span>, g) i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l ++ (name ‚à∂ pme_variable,
      )--------------------------------------
g
<span class="nb">using</span> i

‚Üí Œì ‚±µ
l--------------------------------------
<span class="kp">all</span> , g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l ++ (name ‚à∂ pme_variable,
      )--------------------------------------
g
<span class="nb">using</span> i

‚Üí Œì ‚±µ
l--------------------------------------
<span class="kp">all</span> , g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk71"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
l ++ (name ‚à∂ pme_variable,
      )--------------------------------------
g
<span class="nb">using</span> i
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
<span class="kp">all</span> , g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk72"><span class="nb">unfold</span> of_MLGoal <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_variable,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí mlTheory
    (Œì ‚±µ
     l ++ (name ‚à∂ pme_variable,
           )--------------------------------------
     g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_variable,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        )
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_variable,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           )</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
<span class="kp">all</span> , g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk73"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_variable,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_variable,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
l--------------------------------------
<span class="kp">all</span> , g
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk74"><span class="nb">unfold</span> of_MLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_variable,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_variable,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l--------------------------------------
      <span class="kp">all</span> , g
      <span class="nb">using</span> i
      ))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     <span class="kp">all</span> , g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l--------------------------------------
        <span class="kp">all</span> , g
        <span class="nb">using</span> i
        )
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk75"><span class="nb">unfold</span> MLGoal_to_pattern.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_variable,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_variable,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         <span class="kp">all</span> , g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            <span class="kp">all</span> , g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     <span class="kp">all</span> , g
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern&#39;
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              <span class="kp">all</span> , g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk76"><span class="nb">unfold</span> MLGoal_to_pattern&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      l ++ (name ‚à∂ pme_variable,
            )--------------------------------------
      g
      <span class="nb">using</span> i
      ))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        l ++ (name ‚à∂ pme_variable,
              )--------------------------------------
        g
        <span class="nb">using</span> i
        ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         <span class="kp">all</span> , g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            <span class="kp">all</span> , g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     <span class="kp">all</span> , g
     <span class="nb">using</span> i
     )
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              <span class="kp">all</span> , g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk77"><span class="nb">unfold</span> MLGoal_to_pattern <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39;
     (mlConclusion
        (Œì ‚±µ
         l ++ (name ‚à∂ pme_variable,
               )--------------------------------------
         g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l ++ (name ‚à∂ pme_variable,
                  )--------------------------------------
            g
            <span class="nb">using</span> i
            ))))
‚Üí Œì
  ‚ä¢i MLGoal_to_pattern&#39;
       (mlConclusion
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_variable,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l ++ (name ‚à∂ pme_variable,
                    )--------------------------------------
              g
              <span class="nb">using</span> i
              ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         <span class="kp">all</span> , g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            <span class="kp">all</span> , g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     <span class="kp">all</span> , g
     <span class="nb">using</span> i
     )
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              <span class="kp">all</span> , g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk78"><span class="nb">unfold</span> MLGoal_to_pattern&#39; <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l ++ (name ‚à∂ pme_variable,
               )--------------------------------------
         g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l ++ (name ‚à∂ pme_variable,
                  )--------------------------------------
            g
            <span class="nb">using</span> i
            ))))
‚Üí Œì
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_variable,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l ++ (name ‚à∂ pme_variable,
                    )--------------------------------------
              g
              <span class="nb">using</span> i
              ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l--------------------------------------
         <span class="kp">all</span> , g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l--------------------------------------
            <span class="kp">all</span> , g
            <span class="nb">using</span> i
            ))))
‚Üí mlTheory
    (Œì ‚±µ
     l--------------------------------------
     <span class="kp">all</span> , g
     <span class="nb">using</span> i
     )
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l--------------------------------------
              <span class="kp">all</span> , g
              <span class="nb">using</span> i
              )))
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           l--------------------------------------
           <span class="kp">all</span> , g
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk79"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect
     (mlConclusion
        (Œì ‚±µ
         l ++ (name ‚à∂ pme_variable,
               )--------------------------------------
         g
         <span class="nb">using</span> i
         ))
     (pmes_of
        (mlHypotheses
           (Œì ‚±µ
            l ++ (name ‚à∂ pme_variable,
                  )--------------------------------------
            g
            <span class="nb">using</span> i
            ))))
‚Üí Œì
  ‚ä¢i foldr connect
       (mlConclusion
          (Œì ‚±µ
           l ++ (name ‚à∂ pme_variable,
                 )--------------------------------------
           g
           <span class="nb">using</span> i
           ))
       (pmes_of
          (mlHypotheses
             (Œì ‚±µ
              l ++ (name ‚à∂ pme_variable,
                    )--------------------------------------
              g
              <span class="nb">using</span> i
              ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (<span class="kp">all</span> , g) (pmes_of l))
‚Üí Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk7a"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_variable,
                       ))) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (<span class="kp">all</span> , g) (pmes_of l))
‚Üí Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk7b"><span class="nb">intros</span> wfall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_variable,
                       ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk7c">feed <span class="nb">specialize</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_variable,
                       ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk7d"><hr></label><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk7e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))))
‚Üí Œì
  ‚ä¢i foldr connect g
       (pmes_of (l ++ (name ‚à∂ pme_variable,
                       ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk7f"><span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk80"><span class="nb">unfold</span> pmes_of <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (map nh_pme (l ++ (name ‚à∂ pme_variable,
                        ))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk81"><span class="nb">rewrite</span> map_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g
     (map nh_pme l ++
      map nh_pme (name ‚à∂ pme_variable,
                  )))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk82"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect g (map nh_pme l ++ [pme_variable]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk83"><span class="nb">rewrite</span> foldr_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect (foldr connect g [pme_variable])
     (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk84"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (map nh_pme l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect (<span class="kp">all</span> , g) (map nh_pme l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> wfall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk85">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (pmes_of (l ++ (name ‚à∂ pme_variable,
                     ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk86"><span class="nb">unfold</span> pmes_of <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (map nh_pme (l ++ (name ‚à∂ pme_variable,
                        ))) <span class="nb">using</span> i</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk87"><span class="nb">rewrite</span> map_app <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (map nh_pme l ++
      map nh_pme (name ‚à∂ pme_variable,
                  )) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk88"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect g
     (map nh_pme l ++ [pme_variable]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk89"><span class="nb">rewrite</span> foldr_app <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect (foldr connect g [pme_variable])
     (map nh_pme l) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk8a"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>wfall</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect (<span class="kp">all</span> , g) (pmes_of l))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (map nh_pme l)
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect (<span class="kp">all</span> , g) (pmes_of l) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlIntroForall&quot;</span> <span class="kp">constr</span>(name&#39;) :=
  _failIfUsed name&#39;;
  <span class="nb">apply</span> MLGoal_introForall <span class="kr">with</span> (name := name&#39;);
  simplLocalContext
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlIntroForall&quot;</span> :=
  <span class="kr">let</span> <span class="nv">hyps</span> := _getHypNames <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">name&#39;</span> := <span class="kp">eval</span> <span class="nb">cbv</span> <span class="kr">in</span> (<span class="kp">fresh</span> hyps) <span class="kr">in</span>
  mlIntroForall name&#39;
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk8b">#[local]
<span class="kn">Example</span> <span class="nf">ex_introForall</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory) (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Pattern)
  :
  well_formed a -&gt;
  well_formed b -&gt;
  well_formed c -&gt;
  Œì ‚ä¢ <span class="kp">all</span>, (a ---&gt; (<span class="kp">all</span>, (b ---&gt; c)))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí well_formed b
  ‚Üí well_formed c ‚Üí Œì ‚ä¢ <span class="kp">all</span> , a ---&gt; (<span class="kp">all</span> , b ---&gt; c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk8c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí well_formed b
  ‚Üí well_formed c ‚Üí Œì ‚ä¢ <span class="kp">all</span> , a ---&gt; (<span class="kp">all</span> , b ---&gt; c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk8d"><span class="nb">intros</span> wfa wfb wfc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢ <span class="kp">all</span> , a ---&gt; (<span class="kp">all</span> , b ---&gt; c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk8e">toMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (<span class="kp">all</span> , a ---&gt; (<span class="kp">all</span> , b ---&gt; c))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk8f"><hr></label><div class="goal-conclusion">Œì ‚±µ
 <span class="kp">all</span> , a ---&gt; (<span class="kp">all</span> , b ---&gt; c)
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk90">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (<span class="kp">all</span> , a ---&gt; (<span class="kp">all</span> , b ---&gt; c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk91">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
 <span class="kp">all</span> , a ---&gt; (<span class="kp">all</span> , b ---&gt; c)
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk92">mlIntroForall <span class="s2">&quot;x&quot;</span>%string.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
--------------------------------------
a ---&gt; (<span class="kp">all</span> , b ---&gt; c)
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk93">mlIntro <span class="s2">&quot;H1&quot;</span>%string.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern a,
--------------------------------------
<span class="kp">all</span> , b ---&gt; c
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk94">mlIntroForall <span class="s2">&quot;y&quot;</span>%string.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern a,
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
--------------------------------------
b ---&gt; c
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk95">mlIntro <span class="s2">&quot;H2&quot;</span>%string.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern a,
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern b,
--------------------------------------
c
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_variable</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">pme</span>: ProofModeEntry) : <span class="kt">Prop</span> :=
  pme = pme_variable
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk96">#[<span class="kn">global</span>]
<span class="kn">Instance</span> <span class="nf">is_variable_dec</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">pme</span>: ProofModeEntry)
: Decision (is_variable pme).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pme</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (is_variable pme)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk97"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pme</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (is_variable pme)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk98"><span class="nb">unfold</span> is_variable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pme</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (pme = pme_variable)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">solve_decision.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">foralls_count</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">pmes</span> : list ProofModeEntry) : nat
  := length (filter is_variable pmes).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">evar_fresh_nth</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">avoid</span> : EVarSet) (<span class="nv">n</span> : nat) : <span class="nb">evar</span> :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; evar_fresh_s avoid
  | (S n&#39;) =&gt; evar_fresh_nth (avoid ‚à™ {[(evar_fresh_s avoid)]}) n&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">evar_open_fresh_iter_base</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">n</span> : nat) (<span class="nv">p</span> : Pattern) : Pattern
:= <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; p
   | (S n&#39;) =&gt;
     <span class="kr">let</span> <span class="nv">x</span> := (evar_fresh_s avoid) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">p&#39;</span> := (evar_open x (base + n&#39;) p) <span class="kr">in</span>
    (evar_open_fresh_iter_base (avoid ‚à™ {[x]}) base n&#39; p&#39;)
   <span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">evar_open_fresh_iter</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">avoid</span> : EVarSet) (<span class="nv">n</span> : nat) (<span class="nv">p</span> : Pattern) : Pattern
  := evar_open_fresh_iter_base avoid <span class="mi">0</span> n p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">evar_open_pmes</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">pmes</span> : list ProofModeEntry)
  : list ProofModeEntry
  :=
  <span class="kr">match</span> pmes <span class="kr">with</span>
  | [] =&gt; pmes
  | (pme_pattern p)::pmes&#39;
    =&gt; (pme_pattern (evar_open x idx p))::(evar_open_pmes idx x pmes&#39;)
  | (pme_variable)::pmes&#39;
    =&gt; (pme_variable)::(evar_open_pmes (S idx) x pmes&#39;)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk99"><span class="kn">Lemma</span> <span class="nf">foralls_count_evar_open_pmes</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">pmes</span> : list ProofModeEntry)
  :
  foralls_count (evar_open_pmes idx x pmes) = foralls_count pmes
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (evar_open_pmes idx x pmes) =
foralls_count pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk9a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (evar_open_pmes idx x pmes) =
foralls_count pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk9b"><span class="nb">move</span>: idx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk9c"><span class="nb">induction</span> pmes; <span class="nb">intros</span> idx; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count [] = foralls_count []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk9d"><hr></label><div class="goal-conclusion">foralls_count
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span> = foralls_count (a :: pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk9e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count [] = foralls_count []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk9f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span> = foralls_count (a :: pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span> = foralls_count (a :: pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka1"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">cbn</span>; <span class="nb">unfold</span> decide; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (filter is_variable (evar_open_pmes idx x pmes)) =
length (filter is_variable pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chka2"><hr></label><div class="goal-conclusion">S
  (length
     (filter is_variable
        (evar_open_pmes (S idx) x pmes))) =
S (length (filter is_variable pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (filter is_variable (evar_open_pmes idx x pmes)) =
length (filter is_variable pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka4"><span class="nb">unfold</span> foralls_count <span class="kr">in</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length
    (filter is_variable
       (evar_open_pmes idx x pmes)) =
  length (filter is_variable pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (filter is_variable (evar_open_pmes idx x pmes)) =
length (filter is_variable pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka5"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length
    (filter is_variable
       (evar_open_pmes idx x pmes)) =
  length (filter is_variable pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter is_variable pmes) =
length (filter is_variable pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S
  (length
     (filter is_variable
        (evar_open_pmes (S idx) x pmes))) =
S (length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  foralls_count (evar_open_pmes idx x pmes) =
  foralls_count pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S
  (length
     (filter is_variable
        (evar_open_pmes (S idx) x pmes))) =
S (length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka8"><span class="nb">unfold</span> foralls_count <span class="kr">in</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length
    (filter is_variable
       (evar_open_pmes idx x pmes)) =
  length (filter is_variable pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S
  (length
     (filter is_variable
        (evar_open_pmes (S idx) x pmes))) =
S (length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chka9"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length
    (filter is_variable
       (evar_open_pmes idx x pmes)) =
  length (filter is_variable pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (filter is_variable pmes)) =
S (length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkaa"><span class="kn">Lemma</span> <span class="nf">length_evar_open_pmes</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">pmes</span> : list ProofModeEntry)
  : length (evar_open_pmes idx x pmes) = length pmes
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (evar_open_pmes idx x pmes) = length pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (evar_open_pmes idx x pmes) = length pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkac"><span class="nb">move</span>: idx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) = length pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkad"><span class="nb">induction</span> pmes; <span class="nb">simpl</span>; <span class="nb">intros</span> idx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkae"><hr></label><div class="goal-conclusion">length
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span> = S (length pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkaf">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span> = S (length pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span> = S (length pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb2"><span class="nb">destruct</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes idx x pmes)) =
S (length pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkb3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkb3"><hr></label><div class="goal-conclusion">S (length (evar_open_pmes (S idx) x pmes)) =
S (length pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes idx x pmes)) =
S (length pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb5"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length pmes) = S (length pmes)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes (S idx) x pmes)) =
S (length pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes (S idx) x pmes)) =
S (length pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb8"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  length (evar_open_pmes idx x pmes) =
  length pmes</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length pmes) = S (length pmes)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkb9"><span class="kn">Lemma</span> <span class="nf">evar_open_foldr_connect</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">g</span> : Pattern) (<span class="nv">pmes</span> : list ProofModeEntry)
  (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">idx</span> : nat)
  :
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x}
  = foldr connect
          (g^{<span class="nb">evar</span>:(idx + foralls_count pmes)‚Ü¶x})
          (evar_open_pmes idx x pmes)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
foldr connect g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
  (evar_open_pmes idx x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
foldr connect g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
  (evar_open_pmes idx x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkbb"><span class="nb">move</span>: idx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkbc"><span class="nb">induction</span> pmes; <span class="nb">intros</span> idx; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] = g^{<span class="nb">evar</span>:idx + <span class="mi">0</span>‚Ü¶x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkbd"><hr></label><div class="goal-conclusion">(connect a (foldr connect g pmes))^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar
                                               x] =
foldr connect
  g^{<span class="nb">evar</span>:idx +
          length
            (<span class="kr">if</span> decide (is_variable a)
             <span class="kr">then</span> a :: filter is_variable pmes
             <span class="kr">else</span> filter is_variable pmes)‚Ü¶x}
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkbe">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] = g^{<span class="nb">evar</span>:idx + <span class="mi">0</span>‚Ü¶x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkbf"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">idx = idx + <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(connect a (foldr connect g pmes))^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar
                                               x] =
foldr connect
  g^{<span class="nb">evar</span>:idx +
          length
            (<span class="kr">if</span> decide (is_variable a)
             <span class="kr">then</span> a :: filter is_variable pmes
             <span class="kr">else</span> filter is_variable pmes)‚Ü¶x}
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(connect a (foldr connect g pmes))^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar
                                               x] =
foldr connect
  g^{<span class="nb">evar</span>:idx +
          length
            (<span class="kr">if</span> decide (is_variable a)
             <span class="kr">then</span> a :: filter is_variable pmes
             <span class="kr">else</span> filter is_variable pmes)‚Ü¶x}
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x pmes
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc2"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x]) =
(p^{<span class="nb">evar</span>:idx‚Ü¶x} ---&gt;
 foldr connect
   g^{<span class="nb">evar</span>:idx + length (filter is_variable pmes)‚Ü¶x}
   (evar_open_pmes idx x pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkc3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkc3"><hr></label><div class="goal-conclusion">((ex ,
  (foldr connect g pmes)^[<span class="nb">evar</span>:
  S idx‚Ü¶patt_free_evar x] ---&gt; ‚ä•) ---&gt; ‚ä•) =
(<span class="kp">all</span> ,
 foldr connect
   g^{<span class="nb">evar</span>:idx + S (length (filter is_variable pmes))‚Ü¶x}
   (evar_open_pmes (S idx) x pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x]) =
(p^{<span class="nb">evar</span>:idx‚Ü¶x} ---&gt;
 foldr connect
   g^{<span class="nb">evar</span>:idx + length (filter is_variable pmes)‚Ü¶x}
   (evar_open_pmes idx x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc5"><span class="nb">unfold</span> evar_open <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶
  patt_free_evar x] =
  foldr connect
    g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶
    patt_free_evar x]
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x]) =
(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 foldr connect
   g^[<span class="nb">evar</span>:idx + length (filter is_variable pmes)‚Ü¶
   patt_free_evar x] (evar_open_pmes idx x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc6"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶
  patt_free_evar x] =
  foldr connect
    g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶
    patt_free_evar x]
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 foldr connect
   g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶patt_free_evar x]
   (evar_open_pmes idx x pmes)) =
(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 foldr connect
   g^[<span class="nb">evar</span>:idx + length (filter is_variable pmes)‚Ü¶
   patt_free_evar x] (evar_open_pmes idx x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc7"><span class="nb">clear</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 foldr connect
   g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶patt_free_evar x]
   (evar_open_pmes idx x pmes)) =
(p^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar x] ---&gt;
 foldr connect
   g^[<span class="nb">evar</span>:idx + length (filter is_variable pmes)‚Ü¶
   patt_free_evar x] (evar_open_pmes idx x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ex ,
  (foldr connect g pmes)^[<span class="nb">evar</span>:S idx‚Ü¶patt_free_evar x] ---&gt;
  ‚ä•) ---&gt; ‚ä•) =
(<span class="kp">all</span> ,
 foldr connect
   g^{<span class="nb">evar</span>:idx + S (length (filter is_variable pmes))‚Ü¶x}
   (evar_open_pmes (S idx) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkc9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^{<span class="nb">evar</span>:idx‚Ü¶x} =
  foldr connect
    g^{<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶x}
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ex ,
  (foldr connect g pmes)^[<span class="nb">evar</span>:S idx‚Ü¶patt_free_evar x] ---&gt;
  ‚ä•) ---&gt; ‚ä•) =
(<span class="kp">all</span> ,
 foldr connect
   g^{<span class="nb">evar</span>:idx + S (length (filter is_variable pmes))‚Ü¶x}
   (evar_open_pmes (S idx) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkca"><span class="nb">unfold</span> evar_open <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶
  patt_free_evar x] =
  foldr connect
    g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶
    patt_free_evar x]
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ex ,
  (foldr connect g pmes)^[<span class="nb">evar</span>:S idx‚Ü¶patt_free_evar x] ---&gt;
  ‚ä•) ---&gt; ‚ä•) =
(<span class="kp">all</span> ,
 foldr connect
   g^[<span class="nb">evar</span>:idx + S (length (filter is_variable pmes))‚Ü¶
   patt_free_evar x] (evar_open_pmes (S idx) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkcb"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶
  patt_free_evar x] =
  foldr connect
    g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶
    patt_free_evar x]
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ex ,
  foldr connect
    g^[<span class="nb">evar</span>:S idx + foralls_count pmes‚Ü¶patt_free_evar
                                         x]
    (evar_open_pmes (S idx) x pmes) ---&gt; ‚ä•) ---&gt; ‚ä•) =
(<span class="kp">all</span> ,
 foldr connect
   g^[<span class="nb">evar</span>:idx + S (length (filter is_variable pmes))‚Ü¶
   patt_free_evar x] (evar_open_pmes (S idx) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkcc"><span class="nb">unfold</span> patt_forall,patt_not.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶
  patt_free_evar x] =
  foldr connect
    g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶
    patt_free_evar x]
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ex ,
  foldr connect
    g^[<span class="nb">evar</span>:S idx + foralls_count pmes‚Ü¶patt_free_evar
                                         x]
    (evar_open_pmes (S idx) x pmes) ---&gt; ‚ä•) ---&gt; ‚ä•) =
((ex ,
  foldr connect
    g^[<span class="nb">evar</span>:idx + S (length (filter is_variable pmes))‚Ü¶
    patt_free_evar x] (evar_open_pmes (S idx) x pmes) ---&gt;
  ‚ä•) ---&gt; ‚ä•)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkcd"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶
  patt_free_evar x] =
  foldr connect
    g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶
    patt_free_evar x]
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ex ,
  foldr connect
    g^[<span class="nb">evar</span>:S (idx + foralls_count pmes)‚Ü¶patt_free_evar
                                           x]
    (evar_open_pmes (S idx) x pmes) ---&gt; ‚ä•) ---&gt; ‚ä•) =
((ex ,
  foldr connect
    g^[<span class="nb">evar</span>:idx + S (length (filter is_variable pmes))‚Ü¶
    patt_free_evar x] (evar_open_pmes (S idx) x pmes) ---&gt;
  ‚ä•) ---&gt; ‚ä•)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkce"><span class="nb">rewrite</span> Nat.add_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">idx</span> : nat,
  (foldr connect g pmes)^[<span class="nb">evar</span>:idx‚Ü¶
  patt_free_evar x] =
  foldr connect
    g^[<span class="nb">evar</span>:idx + foralls_count pmes‚Ü¶
    patt_free_evar x]
    (evar_open_pmes idx x pmes)</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ex ,
  foldr connect
    g^[<span class="nb">evar</span>:S (idx + foralls_count pmes)‚Ü¶patt_free_evar
                                           x]
    (evar_open_pmes (S idx) x pmes) ---&gt; ‚ä•) ---&gt; ‚ä•) =
((ex ,
  foldr connect
    g^[<span class="nb">evar</span>:S (idx + length (filter is_variable pmes))‚Ü¶
    patt_free_evar x] (evar_open_pmes (S idx) x pmes) ---&gt;
  ‚ä•) ---&gt; ‚ä•)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkcf"><span class="kn">Lemma</span> <span class="nf">evar_open_pmes_comm_higher</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">m</span> <span class="nv">x</span> <span class="nv">pmes</span> :
  evar_open_pmes m x (evar_open_pmes (S m) x pmes)
  = evar_open_pmes m x (evar_open_pmes m x pmes)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd1"><span class="nb">move</span>: m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd2"><span class="nb">induction</span> pmes; <span class="nb">simpl</span>; <span class="nb">intros</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkd3"><hr></label><div class="goal-conclusion">evar_open_pmes m x
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:S m‚Ü¶x}
      :: evar_open_pmes (S m) x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S (S m)) x pmes
  <span class="kr">end</span> =
evar_open_pmes m x
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
      :: evar_open_pmes m x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x pmes
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes m x
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:S m‚Ü¶x}
      :: evar_open_pmes (S m) x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S (S m)) x pmes
  <span class="kr">end</span> =
evar_open_pmes m x
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
      :: evar_open_pmes m x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x pmes
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes m x
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:S m‚Ü¶x}
      :: evar_open_pmes (S m) x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S (S m)) x pmes
  <span class="kr">end</span> =
evar_open_pmes m x
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
      :: evar_open_pmes m x pmes
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x pmes
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd7"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern p^{<span class="nb">evar</span>:S m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x}
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x}
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkd8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkd8"><hr></label><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S (S m)) x pmes) =
pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S m) x pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkd9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern p^{<span class="nb">evar</span>:S m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x}
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x}
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkda"><span class="nb">unfold</span> evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern
  p^[<span class="nb">evar</span>:S m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar
                                          x]
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkdb"><span class="nb">rewrite</span> bevar_subst_comm_higher.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S m &gt; m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkdc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkdc"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x) <span class="mi">0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkdd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkdd"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x) <span class="mi">0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkde" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkde"><hr></label><div class="goal-conclusion">pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:
  Init.Nat.pred (S m)‚Ü¶patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶
  patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkdf">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S m &gt; m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x) <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chke1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chke1"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x) <span class="mi">0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chke2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chke2"><hr></label><div class="goal-conclusion">pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:
  Init.Nat.pred (S m)‚Ü¶patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶
  patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x) <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chke5"><hr></label><div class="goal-conclusion">pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:
  Init.Nat.pred (S m)‚Ü¶patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶
  patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:Init.Nat.pred
                                      (S m)‚Ü¶patt_free_evar
                                              x]
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
pme_pattern
  p^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]
:: evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chke9"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes m x (evar_open_pmes (S m) x pmes) =
evar_open_pmes m x (evar_open_pmes m x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHpmes.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkea">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S (S m)) x pmes) =
pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S m) x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkeb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S (S m)) x pmes) =
pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S m) x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkec"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_open_pmes m x
    (evar_open_pmes (S m) x pmes) =
  evar_open_pmes m x
    (evar_open_pmes m x pmes)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S m) x pmes) =
pme_variable
:: evar_open_pmes (S m) x
     (evar_open_pmes (S m) x pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chked"><span class="kn">Lemma</span> <span class="nf">wf_all_MLGoal_to_pattern&#39;</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">g</span> : Pattern)
  (<span class="nv">pmes</span> : list ProofModeEntry) (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> <span class="nv">n</span> : nat)
  :
  well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes) -&gt;
  well_formed_xy m n (MLGoal_to_pattern&#39; g^[<span class="nb">evar</span>:m + (foralls_count pmes)‚Ü¶patt_free_evar x]
    (evar_open_pmes m x pmes)
  )
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
       (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkee"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
       (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkef"><span class="nb">remember</span> (S(length pmes)) <span class="kr">as</span> pml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m, n, pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqpml</var><span class="hyp-type"><b>: </b><span>pml = S (length pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
       (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf0"><span class="nb">assert</span> (Hpml : S(length pmes) &lt;= pml) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m, n, pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqpml</var><span class="hyp-type"><b>: </b><span>pml = S (length pmes)</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ pml</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
       (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf1"><span class="nb">clear</span> Heqpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m, n, pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ pml</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
       (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf2"><span class="nb">move</span>: pmes Hpml m n g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar
                                              x]
             (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf3"><span class="nb">induction</span> pml; <span class="nb">simpl</span>; <span class="nb">intros</span> pmes Hpml m n g H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
     (evar_open_pmes m x pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkf4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkf4"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
     (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶patt_free_evar x]
     (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf7"><span class="nb">destruct</span> pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length []) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count []‚Ü¶patt_free_evar x]
     (evar_open_pmes m x []))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkf8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length (p :: pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g (p :: pmes))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkf8"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (p :: pmes)‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x (p :: pmes)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkf9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length []) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count []‚Ü¶patt_free_evar x]
     (evar_open_pmes m x []))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkfa"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length []) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n g^[<span class="nb">evar</span>:m + <span class="mi">0</span>‚Ü¶patt_free_evar x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkfb"><span class="nb">rewrite</span> Nat.add_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length []) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n g^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkfc">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length (p :: pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g (p :: pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (p :: pmes)‚Ü¶patt_free_evar
                                             x]
     (evar_open_pmes m x (p :: pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkfd">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length (p :: pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g (p :: pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (p :: pmes)‚Ü¶patt_free_evar
                                             x]
     (evar_open_pmes m x (p :: pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chkfe"><span class="nb">destruct</span> p <span class="kr">as</span> [p|]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , p ---&gt; MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (p^{<span class="nb">evar</span>:m‚Ü¶x} ---&gt;
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_pattern p :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chkff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chkff"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk100">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , p ---&gt; MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (p^{<span class="nb">evar</span>:m‚Ü¶x} ---&gt;
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_pattern p :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk101"><span class="nb">specialize</span> (IHpml pmes <span class="kp">ltac</span>:(<span class="bp">lia</span>) m n g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
       patt_free_evar x]
       (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , p ---&gt; MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (p^{<span class="nb">evar</span>:m‚Ü¶x} ---&gt;
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_pattern p :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk102">feed <span class="nb">specialize</span> IHpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
       patt_free_evar x]
       (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , p ---&gt; MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk103" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , p ---&gt; MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk103"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (p^{<span class="nb">evar</span>:m‚Ü¶x} ---&gt;
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_pattern p :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk104">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
‚Üí well_formed_xy m n
    (MLGoal_to_pattern&#39;
       g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
       patt_free_evar x]
       (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , p ---&gt; MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk105">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x pmes))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , p ---&gt; MLGoal_to_pattern&#39; g pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (p^{<span class="nb">evar</span>:m‚Ü¶x} ---&gt;
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_pattern p :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk106">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk107">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes)
      ‚Üí well_formed_xy m n
          (MLGoal_to_pattern&#39;
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , MLGoal_to_pattern&#39; g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   MLGoal_to_pattern&#39;
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk108"><span class="nb">unfold</span> MLGoal_to_pattern&#39; <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk109"><span class="nb">cut</span> (well_formed_xy m n
      (evar_open x m (
       foldr connect g^[<span class="nb">evar</span>:m + (foralls_count (pme_variable :: pmes))‚Ü¶patt_free_evar x] (evar_open_pmes (S m) x pmes))) = true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true
‚Üí well_formed_xy m n
    (<span class="kp">all</span> ,
     foldr connect
       g^[<span class="nb">evar</span>:m +
               foralls_count (pme_variable :: pmes)‚Ü¶
       patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk10a"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk10b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true
‚Üí well_formed_xy m n
    (<span class="kp">all</span> ,
     foldr connect
       g^[<span class="nb">evar</span>:m +
               foralls_count (pme_variable :: pmes)‚Ü¶
       patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk10c"><span class="nb">clear</span> IHpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true
‚Üí well_formed_xy m n
    (<span class="kp">all</span> ,
     foldr connect
       g^[<span class="nb">evar</span>:m +
               foralls_count (pme_variable :: pmes)‚Ü¶
       patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk10d"><span class="nb">intros</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m +
             foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x]
     (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk10e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x] (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk10f"><span class="nb">rewrite</span> evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x]^{<span class="nb">evar</span>:m +
                             foralls_count
                               (evar_open_pmes (S m) x
                                  pmes)‚Ü¶x}
     (evar_open_pmes m x (evar_open_pmes (S m) x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk110"><span class="nb">unfold</span> evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + foralls_count (pme_variable :: pmes)‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:m +
                             foralls_count
                               (evar_open_pmes (S m) x
                                  pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x (evar_open_pmes (S m) x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk111"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m +
             length
               (<span class="kr">if</span> decide (is_variable pme_variable)
                <span class="kr">then</span>
                 pme_variable
                 :: filter is_variable pmes
                <span class="kr">else</span> filter is_variable pmes)‚Ü¶patt_free_evar
                                                x]^[<span class="nb">evar</span>:
     m + foralls_count (evar_open_pmes (S m) x pmes)‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x (evar_open_pmes (S m) x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk112"><span class="nb">unfold</span> decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m +
             length
               (pme_variable
                :: filter is_variable pmes)‚Ü¶patt_free_evar
                                              x]^[<span class="nb">evar</span>:
     m + foralls_count (evar_open_pmes (S m) x pmes)‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x (evar_open_pmes (S m) x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk113"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:m +
                             foralls_count
                               (evar_open_pmes (S m) x
                                  pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x (evar_open_pmes (S m) x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk114"><span class="nb">rewrite</span> evar_open_pmes_comm_higher.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:m +
                             foralls_count
                               (evar_open_pmes (S m) x
                                  pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x (evar_open_pmes m x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk115"><span class="nb">rewrite</span> foralls_count_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x (evar_open_pmes m x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk116"><span class="nb">rewrite</span> -[foralls_count pmes](foralls_count_evar_open_pmes m x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:m +
                             foralls_count
                               (evar_open_pmes m x
                                  pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x (evar_open_pmes m x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk117"><span class="nb">apply</span> IHpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes m x pmes)) ‚â§ pml</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk118"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk119">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes m x pmes)) ‚â§ pml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk11a"><span class="nb">rewrite</span> length_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length pmes) ‚â§ pml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk11b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  S (length pmes) ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">g</span> : Pattern),
      well_formed_xy m n
        (<span class="kp">all</span> , foldr connect g pmes)
      ‚Üí well_formed_xy m n
          (foldr connect
             g^[<span class="nb">evar</span>:m + foralls_count pmes‚Ü¶
             patt_free_evar x]
             (evar_open_pmes m x pmes))</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk11c"><span class="nb">clear</span> IHpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk11d"><span class="nb">assert</span> (H&#39; : well_formed_xy m n (evar_open x m (evar_open x (S m) (foldr connect g pmes))) = true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect g pmes)^{<span class="nb">evar</span>:S m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x} =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk11e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect g pmes)^{<span class="nb">evar</span>:
  S m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x} = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk11e"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk11f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect g pmes)^{<span class="nb">evar</span>:S m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk120">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (<span class="kp">all</span> , (<span class="kp">all</span> , foldr connect g pmes))</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect g pmes)^{<span class="nb">evar</span>:
  S m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk121"><span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect g pmes)^{<span class="nb">evar</span>:
  S m‚Ü¶x}^{<span class="nb">evar</span>:m‚Ü¶x} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk122"><span class="nb">rewrite</span> evar_open_foldr_connect <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk123"><span class="nb">cbn</span> <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}
     (evar_open_pmes (S m) x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk124"><span class="nb">rewrite</span> evar_open_foldr_connect <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m +
     foralls_count (evar_open_pmes (S m) x pmes)‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk125"><span class="nb">cbn</span> <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m +
     foralls_count (evar_open_pmes (S m) x pmes)‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk126"><span class="nb">rewrite</span> foralls_count_evar_open_pmes <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk127"><span class="nb">cut</span> (well_formed_xy m n (evar_open x m
      (
       foldr connect
         g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
         patt_free_evar x] (evar_open_pmes m x pmes))) = true
      ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true
‚Üí well_formed_xy m n
    (<span class="kp">all</span> ,
     foldr connect
       g^[<span class="nb">evar</span>:m +
               S (length (filter is_variable pmes))‚Ü¶
       patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk128" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk128"><hr></label><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk129">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true
‚Üí well_formed_xy m n
    (<span class="kp">all</span> ,
     foldr connect
       g^[<span class="nb">evar</span>:m +
               S (length (filter is_variable pmes))‚Ü¶
       patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk12a"><span class="nb">intros</span> H&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m +
             S
               (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (<span class="kp">all</span> ,
   foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk12b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (length (filter is_variable pmes))‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk12c"><span class="nb">fold</span> (foralls_count pmes).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:m + S (foralls_count pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk12d"><span class="nb">rewrite</span> -plus_Snm_nSm.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S m + foralls_count pmes‚Ü¶patt_free_evar x]
     (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk12e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^{<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶x}^{<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶x}
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x pmes))^{<span class="nb">evar</span>:m‚Ü¶x} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk12f"><span class="nb">unfold</span> evar_open <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x
        (evar_open_pmes (S m) x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x pmes))^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar
                                          x] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk130"><span class="nb">rewrite</span> evar_open_pmes_comm_higher <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x
        (evar_open_pmes m x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶patt_free_evar
                                          x]
     (evar_open_pmes m x pmes))^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar
                                          x] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk131"><span class="nb">remember</span> (m + foralls_count pmes) <span class="kr">as</span> m&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm'</var><span class="hyp-type"><b>: </b><span>m&#39; = m + foralls_count pmes</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m&#39;‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x
        (evar_open_pmes m x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x]
     (evar_open_pmes m x pmes))^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar
                                          x] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk132"><span class="nb">remember</span> (evar_open_pmes m x pmes) <span class="kr">as</span> pmes&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm'</var><span class="hyp-type"><b>: </b><span>m&#39; = m + foralls_count pmes</span></span></span><br><span><var>pmes'</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Heqpmes'</var><span class="hyp-type"><b>: </b><span>pmes&#39; = evar_open_pmes m x pmes</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x]^[<span class="nb">evar</span>:m&#39;‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes&#39;)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x] pmes&#39;)^[<span class="nb">evar</span>:m‚Ü¶
  patt_free_evar x] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk133"><span class="nb">remember</span> (g^[<span class="nb">evar</span>: S m&#39; ‚Ü¶ patt_free_evar x]) <span class="kr">as</span> g&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm'</var><span class="hyp-type"><b>: </b><span>m&#39; = m + foralls_count pmes</span></span></span><br><span><var>pmes'</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Heqpmes'</var><span class="hyp-type"><b>: </b><span>pmes&#39; = evar_open_pmes m x pmes</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqg'</var><span class="hyp-type"><b>: </b><span>g&#39; = g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x]</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect g&#39;^[<span class="nb">evar</span>:m&#39;‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes&#39;)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect g&#39; pmes&#39;)^[<span class="nb">evar</span>:m‚Ü¶patt_free_evar x] =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk134"><span class="nb">fold</span> (evar_open x m (foldr connect g&#39; pmes&#39;)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm'</var><span class="hyp-type"><b>: </b><span>m&#39; = m + foralls_count pmes</span></span></span><br><span><var>pmes'</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Heqpmes'</var><span class="hyp-type"><b>: </b><span>pmes&#39; = evar_open_pmes m x pmes</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqg'</var><span class="hyp-type"><b>: </b><span>g&#39; = g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x]</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect g&#39;^[<span class="nb">evar</span>:m&#39;‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes&#39;)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n (foldr connect g&#39; pmes&#39;)^{<span class="nb">evar</span>:m‚Ü¶x} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk135"><span class="nb">rewrite</span> evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm'</var><span class="hyp-type"><b>: </b><span>m&#39; = m + foralls_count pmes</span></span></span><br><span><var>pmes'</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Heqpmes'</var><span class="hyp-type"><b>: </b><span>pmes&#39; = evar_open_pmes m x pmes</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqg'</var><span class="hyp-type"><b>: </b><span>g&#39; = g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x]</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect g&#39;^[<span class="nb">evar</span>:m&#39;‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes&#39;)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect g&#39;^{<span class="nb">evar</span>:m + foralls_count pmes&#39;‚Ü¶x}
     (evar_open_pmes m x pmes&#39;)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk136"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqm'</var><span class="hyp-type"><b>: </b><span>m&#39; = m + foralls_count pmes</span></span></span><br><span><var>pmes'</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Heqpmes'</var><span class="hyp-type"><b>: </b><span>pmes&#39; = evar_open_pmes m x pmes</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqg'</var><span class="hyp-type"><b>: </b><span>g&#39; = g^[<span class="nb">evar</span>:S m&#39;‚Ü¶patt_free_evar x]</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect g&#39;^[<span class="nb">evar</span>:m&#39;‚Ü¶
     patt_free_evar x] (evar_open_pmes m x pmes&#39;)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect g&#39;^{<span class="nb">evar</span>:m + foralls_count pmes&#39;‚Ü¶x}
     (evar_open_pmes m x pmes&#39;)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk137"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x
        (evar_open_pmes m x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶patt_free_evar
                                          x]^{<span class="nb">evar</span>:
     m + foralls_count (evar_open_pmes m x pmes)‚Ü¶x}
     (evar_open_pmes m x (evar_open_pmes m x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk138"><span class="nb">unfold</span> evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x
        (evar_open_pmes m x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶patt_free_evar
                                          x]^[<span class="nb">evar</span>:
     m + foralls_count (evar_open_pmes m x pmes)‚Ü¶patt_free_evar
                                                 x]
     (evar_open_pmes m x (evar_open_pmes m x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk139"><span class="nb">rewrite</span> foralls_count_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (S (length pmes)) ‚â§ S pml</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶
     patt_free_evar x]^[<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes m x
        (evar_open_pmes m x pmes))) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m n
  (foldr connect
     g^[<span class="nb">evar</span>:S (m + foralls_count pmes)‚Ü¶patt_free_evar
                                          x]^[<span class="nb">evar</span>:
     m + foralls_count pmes‚Ü¶patt_free_evar x]
     (evar_open_pmes m x (evar_open_pmes m x pmes))) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk13a"><span class="kn">Lemma</span> <span class="nf">bevar_occur_Sn_bevar_occur_bsvar_subst_n</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">n</span> : nat) (<span class="nv">p</span> <span class="nv">q</span> : Pattern)
  :
  bevar_occur p (S n) = true -&gt;
  bevar_occur (bevar_subst q n p) n = true
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p (S n) = true
‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p (S n) = true
‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk13c"><span class="nb">move</span>: n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk13d"><span class="nb">induction</span> p; <span class="nb">simpl</span>; <span class="nb">intros</span> m Hocc; <span class="kp">try</span> <span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = S m) <span class="kr">then</span> true <span class="kr">else</span> false) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur
  <span class="kr">match</span> compare_nat n m <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; q
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> m = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk13e"><hr></label><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m
|| bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk13f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk13f"><hr></label><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m
|| bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk140" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S (S m)) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk140"><hr></label><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:S m‚Ü¶q] (S m) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk141" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S m) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk141"><hr></label><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk142">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = S m) <span class="kr">then</span> true <span class="kr">else</span> false) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur
  <span class="kr">match</span> compare_nat n m <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; q
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk143"><span class="kp">repeat</span> case_match; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = S m</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (n = S m) = <span class="nb">left</span> e</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>compare_nat n m = Nat_greater n m g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (patt_bound_evar (Nat.pred n)) m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> n; <span class="nb">simpl</span>; case_match; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="kp">try</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk144">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m
|| bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk145" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk145"><hr></label><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m
|| bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk146" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S (S m)) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk146"><hr></label><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:S m‚Ü¶q] (S m) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk147" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S m) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk147"><hr></label><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk148">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m
|| bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk149"><span class="nb">apply</span> orb_true_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk14a"><span class="nb">apply</span> orb_true_iff <span class="kr">in</span> Hocc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true
‚à® bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk14b"><span class="nb">destruct</span> Hocc <span class="kr">as</span> [Hocc|Hocc].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk14c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk14c"><hr></label><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk14d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk14e"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> nocore.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk14f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk150">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk151"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> nocore.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk152">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m
|| bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk153" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S (S m)) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk153"><hr></label><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:S m‚Ü¶q] (S m) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk154" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S m) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk154"><hr></label><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk155">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m
|| bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk156"><span class="nb">apply</span> orb_true_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) || bevar_occur p2 (S m) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk157"><span class="nb">apply</span> orb_true_iff <span class="kr">in</span> Hocc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true
‚à® bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk158"><span class="nb">destruct</span> Hocc <span class="kr">as</span> [Hocc|Hocc].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk159" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk159"><hr></label><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk15a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk15b"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p1 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> nocore.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk15c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk15d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p1^[<span class="nb">evar</span>:m‚Ü¶q] m = true
‚à® bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk15e"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p1, p2, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p1 (S n) = true
  ‚Üí bevar_occur p1^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>IHp2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p2 (S n) = true
  ‚Üí bevar_occur p2^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p2 (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p2^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> nocore.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk15f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat, bevar_occur p (S n) = true ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S (S m)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:S m‚Ü¶q] (S m) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk160" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat,
  bevar_occur p (S n) = true
  ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S m) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk160"><hr></label><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk161">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat, bevar_occur p (S n) = true ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S (S m)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:S m‚Ü¶q] (S m) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> nocore.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk162">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat, bevar_occur p (S n) = true ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk163">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">n</span> : nat, bevar_occur p (S n) = true ‚Üí bevar_occur p^[<span class="nb">evar</span>:n‚Ü¶q] n = true</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hocc</var><span class="hyp-type"><b>: </b><span>bevar_occur p (S m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p^[<span class="nb">evar</span>:m‚Ü¶q] m = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> nocore.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk164"><span class="kn">Lemma</span> <span class="nf">bevar_occur_foldr_connect</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">g</span> : Pattern) (<span class="nv">pmes</span> : list ProofModeEntry) (<span class="nv">k</span> : nat) :
  well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes) k -&gt;
  bevar_occur (foldr connect g pmes) k
  = bevar_occur g (k + (foralls_count pmes))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes)
  k
‚Üí bevar_occur (foldr connect g pmes) k =
  bevar_occur g (k + foralls_count pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk165"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes)
  k
‚Üí bevar_occur (foldr connect g pmes) k =
  bevar_occur g (k + foralls_count pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk166"><span class="nb">move</span>: g k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk167"><span class="nb">induction</span> pmes; <span class="nb">cbn</span>; <span class="nb">intros</span> g k Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux g k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = bevar_occur g (k + <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk168"><hr></label><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk169">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux g k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = bevar_occur g (k + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk16a"><span class="nb">rewrite</span> plus_0_r.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux g k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = bevar_occur g k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk16b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk16c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk16d"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">unfold</span> decide; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk16e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk16e"><hr></label><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk16f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk170"><span class="nb">assert</span> (Hbopk : bevar_occur p k = false).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk171" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk171"><hr></label><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk172">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk173"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux 
  (foldr connect g pmes) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk174"><span class="nb">apply</span> wfc_ex_aux_implies_not_bevar_occur.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux 
  (foldr connect g pmes) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk175">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk176"><span class="nb">rewrite</span> Hbopk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false || bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk177"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk178"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes)
  k</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk179" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk179"><hr></label><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk17a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes)
  k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk17b"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux 
  (foldr connect g pmes) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes)
  k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk17c"><span class="nb">unfold</span> MLGoal_to_pattern&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux 
  (foldr connect g pmes) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk17d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect (pme_pattern p)
     (foldr connect g pmes)) k</span></span></span><br><span><var>Hbopk</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk17e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk17f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk180"><span class="nb">rewrite</span> <span class="mi">2</span>!orb_false_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk181"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes)
  (S k)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk182" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk182"><hr></label><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk183">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (MLGoal_to_pattern&#39; g pmes)
  (S k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk184">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk185"><span class="nb">rewrite</span> Nat.add_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) =
bevar_occur g
  (S (k + length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk186"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  well_formed_closed_ex_aux
    (MLGoal_to_pattern&#39; g pmes) k
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect pme_variable (foldr connect g pmes))
  k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S (k + foralls_count pmes)) =
bevar_occur g
  (S (k + length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk187"><span class="kn">Lemma</span> <span class="nf">bevar_occur_foldr_connect&#39;</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">g</span> : Pattern) (<span class="nv">pmes</span> : list ProofModeEntry) (<span class="nv">k</span> : nat) :
  bevar_occur (MLGoal_to_pattern&#39; patt_bott pmes) k = false -&gt;
  bevar_occur (foldr connect g pmes) k
  = bevar_occur g (k + (foralls_count pmes))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k = false
‚Üí bevar_occur (foldr connect g pmes) k =
  bevar_occur g (k + foralls_count pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk188"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k = false
‚Üí bevar_occur (foldr connect g pmes) k =
  bevar_occur g (k + foralls_count pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk189"><span class="nb">move</span>: g k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k = false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk18a"><span class="nb">induction</span> pmes; <span class="nb">cbn</span>; <span class="nb">intros</span> g k Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = bevar_occur g (k + <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk18b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (connect a (foldr connect ‚ä• pmes)) k =
false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk18b"><hr></label><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk18c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = bevar_occur g (k + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk18d"><span class="nb">rewrite</span> plus_0_r.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = bevar_occur g k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk18e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (connect a (foldr connect ‚ä• pmes)) k =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk18f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (connect a (foldr connect ‚ä• pmes)) k =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk190"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">unfold</span> decide; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur
  (connect (pme_pattern p)
     (foldr connect ‚ä• pmes)) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk191" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur
  (connect pme_variable (foldr connect ‚ä• pmes))
  k = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk191"><hr></label><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk192">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur
  (connect (pme_pattern p)
     (foldr connect ‚ä• pmes)) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk193"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur p k
|| bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk194"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false
‚àß bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk195"><span class="nb">destruct</span> Hwf <span class="kr">as</span> [Hwf1 Hwf2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk196"><span class="nb">rewrite</span> Hwf1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false || bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk197"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) k =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk198"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk199" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk199"><hr></label><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk19a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hwf2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk19b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>bevar_occur p k = false</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) =
bevar_occur g (k + length (filter is_variable pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk19c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur
  (connect pme_variable (foldr connect ‚ä• pmes))
  k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk19d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur
  (connect pme_variable (foldr connect ‚ä• pmes))
  k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk19e"><span class="nb">rewrite</span> <span class="mi">2</span>!orb_false_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur
  (connect pme_variable (foldr connect ‚ä• pmes))
  k = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk19f"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k)
|| false || false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a0"><span class="nb">rewrite</span> <span class="mi">2</span>!orb_false_r <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a1"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) (S k) = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k) = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1a2"><hr></label><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) (S k) = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hwf.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) =
bevar_occur g
  (k + S (length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a5"><span class="nb">rewrite</span> Nat.add_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) =
bevar_occur g
  (S (k + length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur (MLGoal_to_pattern&#39; ‚ä• pmes) k =
  false
  ‚Üí bevar_occur (foldr connect g pmes) k =
    bevar_occur g (k + foralls_count pmes)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>bevar_occur (foldr connect ‚ä• pmes) (S k) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S (k + foralls_count pmes)) =
bevar_occur g
  (S (k + length (filter is_variable pmes)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a7"><span class="kn">Lemma</span> <span class="nf">bevar_occur_foldr_connect&#39;&#39;</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">g</span> : Pattern) (<span class="nv">pmes</span> : list ProofModeEntry) (<span class="nv">k</span> : nat) :
  bevar_occur g (k + (foralls_count pmes)) = true -&gt;
  bevar_occur (foldr connect g pmes) k = true
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) = true
‚Üí bevar_occur (foldr connect g pmes) k = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) = true
‚Üí bevar_occur (foldr connect g pmes) k = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1a9"><span class="nb">move</span>: g k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) = true
  ‚Üí bevar_occur (foldr connect g pmes) k = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1aa"><span class="nb">induction</span> pmes; <span class="nb">cbn</span>; <span class="nb">intros</span> g k H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g (k + <span class="mi">0</span>) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1ab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1ab"><hr></label><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ac">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g (k + <span class="mi">0</span>) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ad"><span class="nb">rewrite</span> plus_0_r <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g k = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g k = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ae">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1af">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (connect a (foldr connect g pmes)) k =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b0"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">unfold</span> decide <span class="kr">in</span> *; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1b1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + S (length (filter is_variable pmes))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1b1"><hr></label><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b3"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k
|| bevar_occur (foldr connect g pmes) k = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b4"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1b5"><hr></label><div class="goal-conclusion">bevar_occur p k || true = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (k + foralls_count pmes) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur p k || true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b8"><span class="nb">rewrite</span> orb_true_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + length (filter is_variable pmes)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1b9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + S (length (filter is_variable pmes))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ba">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + S (length (filter is_variable pmes))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) || false
|| false = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1bb"><span class="nb">rewrite</span> <span class="mi">2</span>!orb_false_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + S (length (filter is_variable pmes))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur (foldr connect g pmes) (S k) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1bc"><span class="nb">rewrite</span> IHpmes;[|<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (k + S (length (filter is_variable pmes))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1bd"><span class="nb">rewrite</span> Nat.add_succ_r <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (S (k + length (filter is_variable pmes))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1be"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : nat),
  bevar_occur g (k + foralls_count pmes) =
  true
  ‚Üí bevar_occur (foldr connect g pmes) k =
    true</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur g
  (S (k + length (filter is_variable pmes))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur g (S k + foralls_count pmes) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1bf"><span class="kn">Lemma</span> <span class="nf">wfc_ex_aux_foldr_connect</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">g</span> <span class="nv">pmes</span> <span class="nv">k</span> :
  well_formed_closed_ex_aux (foldr connect g pmes) k = true -&gt;
  well_formed_closed_ex_aux g (k + (foralls_count pmes)) = true
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) k =
true
‚Üí well_formed_closed_ex_aux g (k + foralls_count pmes) =
  true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) k =
true
‚Üí well_formed_closed_ex_aux g (k + foralls_count pmes) =
  true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c1"><span class="nb">move</span>: k g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux (foldr connect g pmes) k =
  true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c2"><span class="nb">induction</span> pmes; <span class="nb">cbn</span>; <span class="nb">intros</span> k g H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux g k = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g (k + <span class="mi">0</span>) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1c3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1c3"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux g k = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g (k + <span class="mi">0</span>) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c5"><span class="nb">rewrite</span> plus_0_r.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux g k = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g k = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1c8"><span class="nb">destruct</span> a; <span class="nb">unfold</span> decide; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux (foldr connect g pmes) k =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k + length (filter is_variable pmes)) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1c9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect g pmes) 
  (S k) &amp;&amp; true &amp;&amp; true = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1c9"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ca">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux (foldr connect g pmes) k =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k + length (filter is_variable pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1cb">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p k = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect g pmes) k = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k + length (filter is_variable pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHpmes;[<span class="bp">assumption</span>|<span class="bp">reflexivity</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1cc">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect g pmes) 
  (S k) &amp;&amp; true &amp;&amp; true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1cd">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect g pmes) 
  (S k) &amp;&amp; true &amp;&amp; true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ce">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect g pmes) 
  (S k) = true</span></span></span><br><span><var>H2, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1cf"><span class="nb">rewrite</span> -plus_Snm_nSm.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k = true
  ‚Üí well_formed_closed_ex_aux g
      (k + foralls_count pmes) = true</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect g pmes) 
  (S k) = true</span></span></span><br><span><var>H2, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (S k + length (filter is_variable pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHpmes;[<span class="bp">assumption</span>|<span class="bp">reflexivity</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">wfcex_pmes</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">idx</span> : nat) (<span class="nv">pmes</span> : list ProofModeEntry)
  : bool
  :=
  <span class="kr">match</span> pmes <span class="kr">with</span>
  | [] =&gt; true
  | (pme_pattern p)::pmes&#39;
    =&gt; well_formed_closed_ex_aux p idx
       &amp;&amp; wfcex_pmes idx pmes&#39;
  | (pme_variable)::pmes&#39;
    =&gt; wfcex_pmes (S idx) pmes&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d0"><span class="kn">Lemma</span> <span class="nf">wfc_ex_aux_foldr_connect&#39;</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">g</span> <span class="nv">pmes</span> <span class="nv">k</span> :
  well_formed_closed_ex_aux (foldr connect g pmes) k 
  = well_formed_closed_ex_aux g (k + (foralls_count pmes))
  &amp;&amp; wfcex_pmes k pmes
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) k =
well_formed_closed_ex_aux g (k + foralls_count pmes) &amp;&amp;
wfcex_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) k =
well_formed_closed_ex_aux g (k + foralls_count pmes) &amp;&amp;
wfcex_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d2"><span class="nb">move</span>: k g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux (foldr connect g pmes) k =
  well_formed_closed_ex_aux g (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d3"><span class="nb">induction</span> pmes; <span class="nb">cbn</span>; <span class="nb">intros</span> k g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g k =
well_formed_closed_ex_aux g (k + <span class="mi">0</span>) &amp;&amp; true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1d4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1d4"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k =
well_formed_closed_ex_aux g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k pmes
| pme_variable =&gt; wfcex_pmes (S k) pmes
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g k =
well_formed_closed_ex_aux g (k + <span class="mi">0</span>) &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d6"><span class="nb">rewrite</span> plus_0_r.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_0_r</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_0_r instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g k =
well_formed_closed_ex_aux g k &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d7"><span class="nb">rewrite</span> andb_true_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g k =
well_formed_closed_ex_aux g k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k =
well_formed_closed_ex_aux g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k pmes
| pme_variable =&gt; wfcex_pmes (S k) pmes
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1d9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (connect a (foldr connect g pmes)) k =
well_formed_closed_ex_aux g
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable pmes
      <span class="kr">else</span> filter is_variable pmes)) &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k pmes
| pme_variable =&gt; wfcex_pmes (S k) pmes
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1da"><span class="nb">destruct</span> a; <span class="nb">unfold</span> decide; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux (foldr connect g pmes) k =
[&amp;&amp; well_formed_closed_ex_aux g
      (k + length (filter is_variable pmes)),
    well_formed_closed_ex_aux p k
  &amp; wfcex_pmes k pmes]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1db" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1db"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) (S k) &amp;&amp;
true &amp;&amp; true =
well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) &amp;&amp;
wfcex_pmes (S k) pmes</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1dc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p k &amp;&amp;
well_formed_closed_ex_aux (foldr connect g pmes) k =
[&amp;&amp; well_formed_closed_ex_aux g
      (k + length (filter is_variable pmes)),
    well_formed_closed_ex_aux p k
  &amp; wfcex_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1dd"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_ex_aux p k,
    well_formed_closed_ex_aux g
      (k + foralls_count pmes)
  &amp; wfcex_pmes k pmes] =
[&amp;&amp; well_formed_closed_ex_aux g
      (k + length (filter is_variable pmes)),
    well_formed_closed_ex_aux p k
  &amp; wfcex_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1de"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_ex_aux p k,
    well_formed_closed_ex_aux g
      (k + length (filter is_variable pmes))
  &amp; wfcex_pmes k pmes] =
[&amp;&amp; well_formed_closed_ex_aux g
      (k + length (filter is_variable pmes)),
    well_formed_closed_ex_aux p k
  &amp; wfcex_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1df"><span class="nb">remember</span> (
        well_formed_closed_ex_aux p k) <span class="kr">as</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqA</var><span class="hyp-type"><b>: </b><span>A = well_formed_closed_ex_aux p k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; A,
    well_formed_closed_ex_aux g
      (k + length (filter is_variable pmes))
  &amp; wfcex_pmes k pmes] =
[&amp;&amp; well_formed_closed_ex_aux g
      (k + length (filter is_variable pmes)), A
  &amp; wfcex_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e0"><span class="nb">remember</span> (well_formed_closed_ex_aux g (k + length (filter is_variable pmes))) <span class="kr">as</span> B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqA</var><span class="hyp-type"><b>: </b><span>A = well_formed_closed_ex_aux p k</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqB</var><span class="hyp-type"><b>: </b><span>B =
well_formed_closed_ex_aux g
  (k + length (filter is_variable pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; A, B &amp; wfcex_pmes k pmes] =
[&amp;&amp; B, A &amp; wfcex_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e1"><span class="nb">remember</span> (wfcex_pmes k pmes) <span class="kr">as</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqA</var><span class="hyp-type"><b>: </b><span>A = well_formed_closed_ex_aux p k</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqB</var><span class="hyp-type"><b>: </b><span>B =
well_formed_closed_ex_aux g
  (k + length (filter is_variable pmes))</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = wfcex_pmes k pmes</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; A, B &amp; C] = [&amp;&amp; B, A &amp; C]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e2"><span class="nb">clear</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; A, B &amp; C] = [&amp;&amp; B, A &amp; C]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">btauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) (S k) &amp;&amp;
true &amp;&amp; true =
well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) &amp;&amp;
wfcex_pmes (S k) pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect g pmes) (S k) &amp;&amp;
true &amp;&amp; true =
well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) &amp;&amp;
wfcex_pmes (S k) pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e5"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g (S k + foralls_count pmes) &amp;&amp;
wfcex_pmes (S k) pmes &amp;&amp; true &amp;&amp; true =
well_formed_closed_ex_aux g
  (k + S (length (filter is_variable pmes))) &amp;&amp;
wfcex_pmes (S k) pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e6"><span class="nb">rewrite</span> -plus_Snm_nSm.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus_Snm_nSm</span> <span class="kr">is</span> deprecated since <span class="mi">8</span>.<span class="mi">16</span>.
The Arith.Plus file <span class="kr">is</span> obsolete. Use Nat.add_succ_r (<span class="kn">and</span> <span class="nb">symmetry</span> of equality) instead.
[deprecated-syntactic-definition,deprecated]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g (S k + foralls_count pmes) &amp;&amp;
wfcex_pmes (S k) pmes &amp;&amp; true &amp;&amp; true =
well_formed_closed_ex_aux g
  (S k + length (filter is_variable pmes)) &amp;&amp;
wfcex_pmes (S k) pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e7"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux g
  (S k + length (filter is_variable pmes)) &amp;&amp;
wfcex_pmes (S k) pmes &amp;&amp; true &amp;&amp; true =
well_formed_closed_ex_aux g
  (S k + length (filter is_variable pmes)) &amp;&amp;
wfcex_pmes (S k) pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e8"><span class="nb">remember</span> (well_formed_closed_ex_aux g (S k + length (filter is_variable pmes))) <span class="kr">as</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : db_index) (<span class="nv">g</span> : Pattern),
  well_formed_closed_ex_aux
    (foldr connect g pmes) k =
  well_formed_closed_ex_aux g
    (k + foralls_count pmes) &amp;&amp;
  wfcex_pmes k pmes</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqA</var><span class="hyp-type"><b>: </b><span>A =
well_formed_closed_ex_aux g
  (S k + length (filter is_variable pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &amp;&amp; wfcex_pmes (S k) pmes &amp;&amp; true &amp;&amp; true =
A &amp;&amp; wfcex_pmes (S k) pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">btauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1e9"><span class="kn">Lemma</span> <span class="nf">lift_to_mixed_context&#39;</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory)
  (<span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span>: Pattern) (<span class="nv">pmes</span> : list ProofModeEntry)
  (<span class="nv">i</span> : ProofInfo)
  (* TODO relax ExGen *)
  (<span class="nv">pile</span> : ProofInfoLe (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i)
  :
  well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) -&gt;
  well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) -&gt;
  <span class="kr">forall</span> (<span class="nv">avoid</span> : EVarSet),
  free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid -&gt;
  free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid -&gt;
  Œì ‚ä¢i (evar_open_fresh_iter
         (avoid)
         (foralls_count pmes)
         (concl‚ÇÇ ---&gt; concl‚ÇÅ)
       ) <span class="nb">using</span> i -&gt;
  Œì ‚ä¢i ((fold_right connect concl‚ÇÇ pmes) ---&gt;
        (fold_right connect concl‚ÇÅ pmes)) <span class="nb">using</span> i
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
      free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚äÜ avoid
      ‚Üí free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚äÜ avoid
        ‚Üí Œì
          ‚ä¢i evar_open_fresh_iter avoid
               (foralls_count pmes)
               (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
          ‚Üí Œì
            ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
               foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ea"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
      free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚äÜ avoid
      ‚Üí free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚äÜ avoid
        ‚Üí Œì
          ‚ä¢i evar_open_fresh_iter avoid
               (foralls_count pmes)
               (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
          ‚Üí Œì
            ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
               foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1eb"><span class="nb">remember</span> (length pmes) <span class="kr">as</span> pml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqpml</var><span class="hyp-type"><b>: </b><span>pml = length pmes</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
      free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚äÜ avoid
      ‚Üí free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚äÜ avoid
        ‚Üí Œì
          ‚ä¢i evar_open_fresh_iter avoid
               (foralls_count pmes)
               (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
          ‚Üí Œì
            ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
               foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ec"><span class="nb">assert</span> (Hpml : length pmes &lt;= pml) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqpml</var><span class="hyp-type"><b>: </b><span>pml = length pmes</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ pml</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
      free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚äÜ avoid
      ‚Üí free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚äÜ avoid
        ‚Üí Œì
          ‚ä¢i evar_open_fresh_iter avoid
               (foralls_count pmes)
               (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
          ‚Üí Œì
            ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
               foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ed"><span class="nb">clear</span> Heqpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ pml</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
      free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚äÜ avoid
      ‚Üí free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚äÜ avoid
        ‚Üí Œì
          ‚ä¢i evar_open_fresh_iter avoid
               (foralls_count pmes)
               (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
          ‚Üí Œì
            ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
               foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ee"><span class="nb">move</span>: concl‚ÇÅ concl‚ÇÇ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ pml</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
  well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
  ‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
    ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
        free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
        ‚äÜ avoid
        ‚Üí free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
          ‚äÜ avoid
          ‚Üí Œì
            ‚ä¢i evar_open_fresh_iter avoid
                 (foralls_count pmes)
                 (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
            ‚Üí Œì
              ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                 foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ef"><span class="nb">move</span>: pmes Hpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
              ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter avoid
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f0"><span class="nb">unfold</span> evar_open_fresh_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
              ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f1"><span class="nb">induction</span> pml; <span class="nb">simpl</span>;
    <span class="nb">intros</span> pmes Hpml concl‚ÇÅ concl‚ÇÇ Hwf1 Hwf2 avoid Havoid1 Havoid2 Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ <span class="mi">0</span></span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1f2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1f2"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ <span class="mi">0</span></span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f4"><span class="nb">destruct</span> pmes; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> ‚â§ <span class="mi">0</span></span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed concl‚ÇÅ</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed concl‚ÇÇ</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars concl‚ÇÅ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars concl‚ÇÇ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i concl‚ÇÇ ---&gt; concl‚ÇÅ <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i concl‚ÇÇ ---&gt; concl‚ÇÅ <span class="nb">using</span> i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1f5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect p (MLGoal_to_pattern&#39; concl‚ÇÅ pmes))</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect p (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars
  (connect p
     (MLGoal_to_pattern&#39; concl‚ÇÅ pmes))
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars
  (connect p
     (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count (p :: pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1f5"><hr></label><div class="goal-conclusion">Œì
‚ä¢i connect p (foldr connect concl‚ÇÇ pmes) ---&gt;
   connect p (foldr connect concl‚ÇÅ pmes) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f6"><span class="bp">exact</span> Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect p (MLGoal_to_pattern&#39; concl‚ÇÅ pmes))</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect p (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars
  (connect p
     (MLGoal_to_pattern&#39; concl‚ÇÅ pmes))
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars
  (connect p
     (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count (p :: pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i connect p (foldr connect concl‚ÇÇ pmes) ---&gt;
   connect p (foldr connect concl‚ÇÅ pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length pmes ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1f9"><span class="nb">destruct</span> pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length [] ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ [])</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ [])</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ [])
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ [])
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count []) (concl‚ÇÇ ---&gt; concl‚ÇÅ)
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ [] ---&gt;
   foldr connect concl‚ÇÅ [] <span class="nb">using</span> i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length (p :: pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (p :: pmes))</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÇ (p :: pmes))</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars
  (MLGoal_to_pattern&#39; concl‚ÇÅ (p :: pmes))
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars
  (MLGoal_to_pattern&#39; concl‚ÇÇ (p :: pmes))
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count (p :: pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1fa"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ (p :: pmes) ---&gt;
   foldr connect concl‚ÇÅ (p :: pmes) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1fb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length [] ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ [])</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ [])</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ [])
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ [])
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count []) (concl‚ÇÇ ---&gt; concl‚ÇÅ)
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ [] ---&gt;
   foldr connect concl‚ÇÅ [] <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Heo.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1fc">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>length (p :: pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (p :: pmes))</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÇ (p :: pmes))</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars
  (MLGoal_to_pattern&#39; concl‚ÇÅ (p :: pmes))
‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars
  (MLGoal_to_pattern&#39; concl‚ÇÇ (p :: pmes))
‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count (p :: pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ (p :: pmes) ---&gt;
   foldr connect concl‚ÇÅ (p :: pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1fd"><span class="nb">destruct</span> p <span class="kr">as</span> [p|]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count (pme_pattern p :: pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk1fe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ)^{<span class="nb">evar</span>:
     length (filter is_variable pmes)‚Ü¶
     evar_fresh_s avoid} <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk1fe"><hr></label><div class="goal-conclusion">Œì
‚ä¢i (<span class="kp">all</span> , foldr connect concl‚ÇÇ pmes) ---&gt;
   (<span class="kp">all</span> , foldr connect concl‚ÇÅ pmes) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk1ff">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count (pme_pattern p :: pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk200"><span class="nb">cbn</span> <span class="kr">in</span> Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (length
        (<span class="kr">if</span> decide (is_variable (pme_pattern p))
         <span class="kr">then</span>
          pme_pattern p
          :: filter is_variable pmes
         <span class="kr">else</span> filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk201"><span class="nb">unfold</span> decide <span class="kr">in</span> Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk202"><span class="nb">specialize</span> (IHpml pmes <span class="kp">ltac</span>:(<span class="bp">lia</span>) concl‚ÇÅ concl‚ÇÇ <span class="kp">ltac</span>:(wf_auto2) <span class="kp">ltac</span>:(wf_auto2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
  free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
  ‚äÜ avoid
  ‚Üí free_evars
      (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid
    ‚Üí Œì
      ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
           (foralls_count pmes)
           (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
      ‚Üí Œì
        ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
           foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk203"><span class="nb">specialize</span> (IHpml avoid <span class="kp">ltac</span>:(set_solver) <span class="kp">ltac</span>:(set_solver)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
‚Üí Œì
  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
     foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk204"><span class="nb">specialize</span> (IHpml Heo).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk205"><span class="nb">clear</span> Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (p ---&gt; foldr connect concl‚ÇÇ pmes) ---&gt;
   p ---&gt; foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk206"><span class="nb">apply</span> prf_weaken_conclusion_meta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk207" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk207"><hr></label><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÇ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk208" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk208"><hr></label><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÅ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk209" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk209"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk20a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk20b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÇ pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk20c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk20c"><hr></label><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÅ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk20d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk20d"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk20e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÇ pmes)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk20f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÅ pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk210" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk210"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk211">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÅ pmes)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk212">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (p ---&gt; MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars p
‚à™ free_evars
    (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHpml.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk213">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ)^{<span class="nb">evar</span>:
     length (filter is_variable pmes)‚Ü¶
     evar_fresh_s avoid} <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (<span class="kp">all</span> , foldr connect concl‚ÇÇ pmes) ---&gt;
   (<span class="kp">all</span> , foldr connect concl‚ÇÅ pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk214">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ)^{<span class="nb">evar</span>:
     length (filter is_variable pmes)‚Ü¶
     evar_fresh_s avoid} <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (<span class="kp">all</span> , foldr connect concl‚ÇÇ pmes) ---&gt;
   (<span class="kp">all</span> , foldr connect concl‚ÇÅ pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk215"><span class="nb">cbn</span> <span class="kr">in</span> Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (<span class="kp">all</span> , foldr connect concl‚ÇÇ pmes) ---&gt;
   (<span class="kp">all</span> , foldr connect concl‚ÇÅ pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk216"><span class="nb">remember</span> (evar_fresh_s (avoid)) <span class="kr">as</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (<span class="kp">all</span> , foldr connect concl‚ÇÇ pmes) ---&gt;
   (<span class="kp">all</span> , foldr connect concl‚ÇÅ pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk217"><span class="nb">apply</span> forall_monotone <span class="kr">with</span> (x := x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false) i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk218" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk218"><hr></label><div class="goal-conclusion">x ‚àâ free_evars (foldr connect concl‚ÇÇ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk219" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk219"><hr></label><div class="goal-conclusion">x ‚àâ free_evars (foldr connect concl‚ÇÅ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk21a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk21a"><hr></label><div class="goal-conclusion">Œì
‚ä¢i (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ---&gt;
   (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk21b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false) i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk21c"><span class="nb">eapply</span> pile_trans.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false) <span class="nl">?i‚ÇÇ</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk21d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk21d"><hr></label><div class="goal-conclusion">ProofInfoLe <span class="nl">?i‚ÇÇ</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk21e"><span class="mi">2</span>: <span class="nb">apply</span> pile.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false)
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">try_solve_pile.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk21f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àâ free_evars (foldr connect concl‚ÇÇ pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk220" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk220"><hr></label><div class="goal-conclusion">x ‚àâ free_evars (foldr connect concl‚ÇÅ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk221" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk221"><hr></label><div class="goal-conclusion">Œì
‚ä¢i (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ---&gt;
   (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk222">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àâ free_evars (foldr connect concl‚ÇÇ pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk223"><span class="nb">subst</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid
‚àâ free_evars (foldr connect concl‚ÇÇ pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk224"><span class="nb">eapply</span> evar_is_fresh_in_richer&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes) ‚äÜ <span class="nl">?B</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk225" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk225"><hr></label><div class="goal-conclusion">evar_fresh_s avoid ‚àâ <span class="nl">?B</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk226"><span class="mi">2</span>: <span class="nb">apply</span> set_evar_fresh_is_fresh&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk227">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk228"><span class="nb">unfold</span> MLGoal_to_pattern&#39; <span class="kr">in</span> Havoid1,Havoid2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk229"><span class="nb">clear</span> -Havoid1 Havoid2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk22a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àâ free_evars (foldr connect concl‚ÇÅ pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk22b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk22b"><hr></label><div class="goal-conclusion">Œì
‚ä¢i (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ---&gt;
   (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk22c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àâ free_evars (foldr connect concl‚ÇÅ pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk22d"><span class="nb">subst</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid
‚àâ free_evars (foldr connect concl‚ÇÅ pmes)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk22e"><span class="nb">eapply</span> evar_is_fresh_in_richer&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes) ‚äÜ <span class="nl">?B</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk22f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk22f"><hr></label><div class="goal-conclusion">evar_fresh_s avoid ‚àâ <span class="nl">?B</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk230"><span class="mi">2</span>: <span class="nb">apply</span> set_evar_fresh_is_fresh&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk231">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk232"><span class="nb">unfold</span> MLGoal_to_pattern&#39; <span class="kr">in</span> Havoid1,Havoid2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar (evar_fresh_s avoid)])
<span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk233"><span class="nb">clear</span> -Havoid1 Havoid2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes) ‚äÜ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk234">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ---&gt;
   (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk235"><span class="nb">rewrite</span> <span class="mi">2</span>!evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     concl‚ÇÇ^{<span class="nb">evar</span>:<span class="mi">0</span> + foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes) ---&gt;
   foldr connect
     concl‚ÇÅ^{<span class="nb">evar</span>:<span class="mi">0</span> + foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk236"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes) ---&gt;
   foldr connect concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk237"><span class="nb">apply</span> IHpml <span class="kr">with</span> (avoid := (avoid ‚à™ {[x]})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (evar_open_pmes <span class="mi">0</span> x pmes) ‚â§ pml</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk238" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk238"><hr></label><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk239" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk239"><hr></label><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk23a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk23a"><hr></label><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ 
avoid ‚à™ {[x]}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk23b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk23b"><hr></label><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ 
avoid ‚à™ {[x]}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk23c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk23c"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk23d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (evar_open_pmes <span class="mi">0</span> x pmes) ‚â§ pml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk23e"><span class="nb">rewrite</span> length_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length pmes ‚â§ pml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk23f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk240" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk240"><hr></label><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk241" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk241"><hr></label><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ 
avoid ‚à™ {[x]}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk242" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk242"><hr></label><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ 
avoid ‚à™ {[x]}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk243" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk243"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk244">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk245"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk246"><span class="nb">apply</span> wf_wfxy00_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk247"><span class="nb">apply</span> wf_wfxy00_decompose <span class="kr">in</span> Hwf1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes) = true</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk248"><span class="nb">apply</span> wf_all_MLGoal_to_pattern&#39; <span class="kr">with</span> (x := x) <span class="kr">in</span> Hwf1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^[<span class="nb">evar</span>:<span class="mi">0</span> + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes <span class="mi">0</span> x pmes))</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hwf1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk249">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk24a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk24a"><hr></label><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ 
avoid ‚à™ {[x]}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk24b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk24b"><hr></label><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ 
avoid ‚à™ {[x]}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk24c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk24c"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk24d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk24e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk24f"><span class="nb">apply</span> wf_wfxy00_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk250"><span class="nb">apply</span> wf_wfxy00_decompose <span class="kr">in</span> Hwf2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes) = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk251"><span class="nb">apply</span> wf_all_MLGoal_to_pattern&#39; <span class="kr">with</span> (x := x) <span class="kr">in</span> Hwf2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^[<span class="nb">evar</span>:<span class="mi">0</span> + foralls_count pmes‚Ü¶
     patt_free_evar x]
     (evar_open_pmes <span class="mi">0</span> x pmes))</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hwf2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk252">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk253" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk253"><hr></label><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ 
avoid ‚à™ {[x]}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk254" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk254"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk255">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk256"><span class="nb">unfold</span> MLGoal_to_pattern&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (foldr connect concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk257"><span class="nb">replace</span> (foralls_count pmes)
          <span class="kr">with</span> (<span class="mi">0</span> + (foralls_count pmes))
          <span class="bp">by</span> <span class="bp">reflexivity</span>
        .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (foldr connect
     concl‚ÇÅ^{<span class="nb">evar</span>:<span class="mi">0</span> + foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk258"><span class="nb">rewrite</span> -evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk259"><span class="nb">pose proof</span> (Hfeeo := free_evars_evar_open (foldr connect concl‚ÇÅ pmes) x <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk25a"><span class="nb">unfold</span> MLGoal_to_pattern&#39; <span class="kr">in</span> Havoid1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk25b"><span class="nb">eapply</span> <span class="nb">transitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ‚äÜ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk25c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk25c"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk25d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ‚äÜ <span class="nl">?y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hfeeo.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk25e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÅ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[x]} ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk25f"><span class="nb">clear</span> -Havoid1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÅ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÅ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[x]} ‚à™ free_evars (foldr connect concl‚ÇÅ pmes)
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk260">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk261" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk261"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk262">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (MLGoal_to_pattern&#39;
     concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk263"><span class="nb">unfold</span> MLGoal_to_pattern&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (foldr connect concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk264"><span class="nb">replace</span> (foralls_count pmes)
          <span class="kr">with</span> (<span class="mi">0</span> + (foralls_count pmes))
          <span class="bp">by</span> <span class="bp">reflexivity</span>
        .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  (foldr connect
     concl‚ÇÇ^{<span class="nb">evar</span>:<span class="mi">0</span> + foralls_count pmes‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x pmes)) ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk265"><span class="nb">rewrite</span> -evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk266"><span class="nb">pose proof</span> (Hfeeo := free_evars_evar_open (foldr connect concl‚ÇÇ pmes) x <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk267"><span class="nb">unfold</span> MLGoal_to_pattern&#39; <span class="kr">in</span> Havoid2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk268"><span class="nb">eapply</span> <span class="nb">transitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ‚äÜ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk269" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk269"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk26a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} ‚äÜ <span class="nl">?y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hfeeo.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk26b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br><span><var>Hfeeo</var><span class="hyp-type"><b>: </b><span>free_evars
  (foldr connect concl‚ÇÇ pmes)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
‚äÜ {[x]}
  ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[x]} ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk26c"><span class="nb">clear</span> -Havoid2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (foldr connect concl‚ÇÇ pmes) ‚à™ ‚àÖ
‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[x]} ‚à™ free_evars (foldr connect concl‚ÇÇ pmes)
‚äÜ avoid ‚à™ {[x]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk26d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk26e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHpml</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">pmes</span> : list ProofModeEntry,
  length pmes ‚â§ pml
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> : Pattern,
      well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚Üí well_formed
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
        ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
            free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
            ‚äÜ avoid
            ‚Üí free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÇ
                   pmes) ‚äÜ avoid
              ‚Üí Œì
                ‚ä¢i evar_open_fresh_iter_base
                     avoid <span class="mi">0</span>
                     (foralls_count pmes)
                     (concl‚ÇÇ ---&gt; concl‚ÇÅ)
                <span class="nb">using</span> i
                ‚Üí Œì
                  ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
                     foldr connect concl‚ÇÅ pmes
                  <span class="nb">using</span> i</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk26f"><span class="nb">clear</span> IHpml.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk270"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count (evar_open_pmes <span class="mi">0</span> x pmes))
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk271"><span class="nb">rewrite</span> foralls_count_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (length (filter is_variable pmes))
     (concl‚ÇÇ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:length
                     (filter is_variable pmes)‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count pmes)
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk272"><span class="nb">fold</span> (foralls_count pmes) <span class="kr">in</span> Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span> (foralls_count pmes)
     (concl‚ÇÇ^[<span class="nb">evar</span>:foralls_count pmes‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:foralls_count pmes‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count pmes)
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk273"><span class="nb">unfold</span> decide <span class="kr">in</span> Heo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>pml</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hpml</var><span class="hyp-type"><b>: </b><span>S (length pmes) ‚â§ S pml</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf1</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>Hwf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> , MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Havoid1</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>Havoid2</var><span class="hyp-type"><b>: </b><span>free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚à™ ‚àÖ ‚à™ ‚àÖ ‚äÜ avoid</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = evar_fresh_s avoid</span></span></span><br><span><var>Heo</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base 
     (avoid ‚à™ {[x]}) <span class="mi">0</span> (foralls_count pmes)
     (concl‚ÇÇ^[<span class="nb">evar</span>:foralls_count pmes‚Ü¶
      patt_free_evar x] ---&gt;
      concl‚ÇÅ^[<span class="nb">evar</span>:foralls_count pmes‚Ü¶
      patt_free_evar x]) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base (avoid ‚à™ {[x]}) <span class="mi">0</span>
     (foralls_count pmes)
     (concl‚ÇÇ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x} ---&gt;
      concl‚ÇÅ^{<span class="nb">evar</span>:foralls_count pmes‚Ü¶x}) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Heo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk274"><span class="kn">Lemma</span> <span class="nf">lift_to_mixed_context</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory)
  (<span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span>: Pattern) (<span class="nv">pmes</span> : list ProofModeEntry)
  (<span class="nv">i</span> : ProofInfo)
  (* TODO relax ExGen *)
  (<span class="nv">pile</span> : ProofInfoLe (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i)
  :
  well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) -&gt;
  well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) -&gt;
  Œì ‚ä¢i (evar_open_fresh_iter
         (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚à™ free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
         (foralls_count pmes)
         (concl‚ÇÇ ---&gt; concl‚ÇÅ)
       ) <span class="nb">using</span> i -&gt;
  Œì ‚ä¢i ((fold_right connect concl‚ÇÇ pmes) ---&gt;
        (fold_right connect concl‚ÇÅ pmes)) <span class="nb">using</span> i
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
         (foralls_count pmes) (concl‚ÇÇ ---&gt; concl‚ÇÅ)
    <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
         foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk275"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚Üí well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
         (foralls_count pmes) (concl‚ÇÇ ---&gt; concl‚ÇÅ)
    <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
         foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk276"><span class="nb">intros</span> wf1 wf2 H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
   foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk277"><span class="nb">eapply</span> lift_to_mixed_context&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk278" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk278"><hr></label><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk279" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk279"><hr></label><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk27a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk27a"><hr></label><div class="goal-conclusion">free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes) ‚äÜ <span class="nl">?avoid</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk27b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk27b"><hr></label><div class="goal-conclusion">free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes) ‚äÜ <span class="nl">?avoid</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk27c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk27c"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter 
     <span class="nl">?avoid</span> (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk27d"><span class="mi">6</span>: <span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk27e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk27e"><hr></label><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk27f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk27f"><hr></label><div class="goal-conclusion">well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk280" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk280"><hr></label><div class="goal-conclusion">free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚äÜ free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
  ‚à™ free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk281" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk281"><hr></label><div class="goal-conclusion">free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚äÜ free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
  ‚à™ free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk282"><span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>: <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
‚äÜ free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
  ‚à™ free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk283" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ pmes))
     (foralls_count pmes) 
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk283"><hr></label><div class="goal-conclusion">free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
‚äÜ free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
  ‚à™ free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">clear</span>; set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk284"><span class="kn">Lemma</span> <span class="nf">wf_lift_helper&#39;</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">hyps</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> <span class="nv">x</span> <span class="nv">y</span>:
  well_formed_xy (x + foralls_count (pmes_of hyps)) y concl‚ÇÇ -&gt;
  well_formed_xy (x) y (foldr connect concl‚ÇÅ (map nh_pme hyps)) -&gt;
  well_formed_xy (x) y (foldr connect concl‚ÇÇ (map nh_pme hyps))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk285"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk286"><span class="nb">move</span>: x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk287"><span class="nb">induction</span> hyps; <span class="nb">cbn</span>; <span class="nb">intros</span> x y wf1 wf2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy (x + <span class="mi">0</span>) y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y concl‚ÇÅ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y concl‚ÇÇ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk288" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>named_hypothesis</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length
     (<span class="kr">if</span> decide (is_variable (nh_pme a))
      <span class="kr">then</span>
       nh_pme a
       :: filter is_variable (map nh_pme hyps)
      <span class="kr">else</span> filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (connect (nh_pme a)
     (foldr connect concl‚ÇÅ (map nh_pme hyps)))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk288"><hr></label><div class="goal-conclusion">well_formed_xy x y
  (connect (nh_pme a)
     (foldr connect concl‚ÇÇ (map nh_pme hyps)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk289">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy (x + <span class="mi">0</span>) y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y concl‚ÇÅ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y concl‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk28a"><span class="nb">rewrite</span> Nat.add_0_r <span class="kr">in</span> wf1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y concl‚ÇÅ</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y concl‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk28b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>named_hypothesis</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length
     (<span class="kr">if</span> decide (is_variable (nh_pme a))
      <span class="kr">then</span>
       nh_pme a
       :: filter is_variable (map nh_pme hyps)
      <span class="kr">else</span> filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (connect (nh_pme a)
     (foldr connect concl‚ÇÅ (map nh_pme hyps)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (connect (nh_pme a)
     (foldr connect concl‚ÇÇ (map nh_pme hyps)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk28c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>named_hypothesis</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length
     (<span class="kr">if</span> decide (is_variable (nh_pme a))
      <span class="kr">then</span>
       nh_pme a
       :: filter is_variable (map nh_pme hyps)
      <span class="kr">else</span> filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (connect (nh_pme a)
     (foldr connect concl‚ÇÅ (map nh_pme hyps)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (connect (nh_pme a)
     (foldr connect concl‚ÇÇ (map nh_pme hyps)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk28d"><span class="nb">destruct</span> a <span class="kr">as</span> [name h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length
     (<span class="kr">if</span>
       decide (is_variable (nh_pme (name ‚à∂ h)))
      <span class="kr">then</span>
       nh_pme (name ‚à∂ h)
       :: filter is_variable (map nh_pme hyps)
      <span class="kr">else</span> filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (connect (nh_pme (name ‚à∂ h))
     (foldr connect concl‚ÇÅ (map nh_pme hyps)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (connect (nh_pme (name ‚à∂ h))
     (foldr connect concl‚ÇÇ (map nh_pme hyps)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk28e"><span class="nb">destruct</span> h <span class="kr">as</span> [p|]; <span class="nb">unfold</span> decide <span class="kr">in</span> *; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk28f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   S
     (length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk28f"><hr></label><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk290">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk291"><span class="nb">specialize</span> (IHhyps x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x + foralls_count (pmes_of hyps)) y concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk292">feed <span class="nb">specialize</span> IHhyps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x + foralls_count (pmes_of hyps)) y concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk293" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x + foralls_count (pmes_of hyps)) y concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk293"><hr></label><div class="goal-conclusion">well_formed_xy x y
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk294" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk294"><hr></label><div class="goal-conclusion">well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk295">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x + foralls_count (pmes_of hyps)) y concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk296">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x + foralls_count (pmes_of hyps)) y concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk297" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk297"><hr></label><div class="goal-conclusion">well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk298">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x + foralls_count (pmes_of hyps)) y concl‚ÇÇ
‚Üí well_formed_xy x y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk299">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   length (filter is_variable (map nh_pme hyps)))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (p ---&gt; foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk29a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   S
     (length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk29b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
  well_formed_xy
    (x + foralls_count (pmes_of hyps)) y
    concl‚ÇÇ
  ‚Üí well_formed_xy x y
      (foldr connect concl‚ÇÅ (map nh_pme hyps))
    ‚Üí well_formed_xy x y
        (foldr connect concl‚ÇÇ
           (map nh_pme hyps))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   S
     (length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk29c"><span class="nb">specialize</span> (IHhyps (S x) y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (x +
   S
     (length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk29d"><span class="nb">rewrite</span> Nat.add_succ_r <span class="kr">in</span> wf1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk29e">feed <span class="nb">specialize</span> IHhyps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk29f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk29f"><hr></label><div class="goal-conclusion">well_formed_xy (S x) y
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2a0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S x) y
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2a0"><hr></label><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a2"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (S (x + foralls_count (pmes_of hyps)))
  y concl‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (S x) y
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2a4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S x) y
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2a4"><hr></label><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S x + foralls_count (pmes_of hyps)) y
  concl‚ÇÇ
‚Üí well_formed_xy (S x) y
    (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed_xy (S x) y
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (S x) y
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>string</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>list named_hypothesis</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHhyps</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S x) y
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy
  (S
     (x +
      length
        (filter is_variable (map nh_pme hyps))))
  y concl‚ÇÇ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy x y
  (<span class="kp">all</span> , foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a7"><span class="kn">Lemma</span> <span class="nf">wf_lift_helper</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">hyps</span> <span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span> :
  well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span> concl‚ÇÇ -&gt;
  well_formed (foldr connect concl‚ÇÅ (map nh_pme hyps)) -&gt;
  well_formed (foldr connect concl‚ÇÇ (map nh_pme hyps))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span> concl‚ÇÇ
‚Üí well_formed (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span> concl‚ÇÇ
‚Üí well_formed (foldr connect concl‚ÇÅ (map nh_pme hyps))
  ‚Üí well_formed
      (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2a9"><span class="nb">intros</span> wf1 wf2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2aa"><span class="nb">rewrite</span> wf_wfxy00.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ab"><span class="nb">rewrite</span> wf_wfxy00 <span class="kr">in</span> wf2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wf1</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>wf2</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span>
  (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> wf_lift_helper&#39; <span class="kr">with</span> (concl‚ÇÅ := concl‚ÇÅ); <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ac"><span class="kn">Lemma</span> <span class="nf">MLGoal_lift_to_mixed_context</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">Œì</span> : Theory)
  (<span class="nv">concl‚ÇÅ</span> <span class="nv">concl‚ÇÇ</span>: Pattern) (<span class="nv">hyps</span> : hypotheses)
  (<span class="nv">i</span> : ProofInfo)
  (* TODO relax ExGen *)
  (<span class="nv">pile</span> : ProofInfoLe (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i)
  :
  well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span> concl‚ÇÇ -&gt;
  Œì ‚ä¢i (evar_open_fresh_iter
         (free_evars (MLGoal_to_pattern&#39; concl‚ÇÅ (pmes_of hyps)) ‚à™ free_evars (MLGoal_to_pattern&#39; concl‚ÇÇ (pmes_of hyps)))
         (foralls_count (pmes_of hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ)
       ) <span class="nb">using</span> i -&gt;
  (mkMLGoal Œ£ Œì hyps concl‚ÇÇ i) -&gt;
  (mkMLGoal Œ£ Œì hyps concl‚ÇÅ i)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span> concl‚ÇÇ
‚Üí Œì
  ‚ä¢i evar_open_fresh_iter
       (free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÅ (pmes_of hyps))
        ‚à™ free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÇ (pmes_of hyps)))
       (foralls_count (pmes_of hyps))
       (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
  ‚Üí Œì ‚±µ
    hyps--------------------------------------
    concl‚ÇÇ
    <span class="nb">using</span> i
    
    ‚Üí Œì ‚±µ
    hyps--------------------------------------
    concl‚ÇÅ
    <span class="nb">using</span> i
    </div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span> concl‚ÇÇ
‚Üí Œì
  ‚ä¢i evar_open_fresh_iter
       (free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÅ (pmes_of hyps))
        ‚à™ free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÇ (pmes_of hyps)))
       (foralls_count (pmes_of hyps))
       (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
  ‚Üí Œì ‚±µ
    hyps--------------------------------------
    concl‚ÇÇ
    <span class="nb">using</span> i
    
    ‚Üí Œì ‚±µ
    hyps--------------------------------------
    concl‚ÇÅ
    <span class="nb">using</span> i
    </div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ae"><span class="nb">intros</span> wfxy Himpl H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
concl‚ÇÅ
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2af">mlExtractWF wf&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
concl‚ÇÅ
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(*intros wf1 wf2 Himpl H.*)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b0">feed <span class="nb">specialize</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÇ
      <span class="nb">using</span> i
      ))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2b1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mlTheory
  (Œì ‚±µ
   hyps--------------------------------------
   concl‚ÇÇ
   <span class="nb">using</span> i
   )
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÇ
      <span class="nb">using</span> i
      )
<span class="nb">using</span> mlInfo
        (Œì ‚±µ
         hyps--------------------------------------
         concl‚ÇÇ
         <span class="nb">using</span> i
         )</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2b1"><hr></label><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
concl‚ÇÅ
<span class="nb">using</span> i
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÇ
      <span class="nb">using</span> i
      ))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b4"><span class="nb">apply</span> wf_lift_helper <span class="kr">with</span> (concl‚ÇÅ := concl‚ÇÅ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span> concl‚ÇÇ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2b5"><hr></label><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b6">wf_auto2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
hyps--------------------------------------
concl‚ÇÇ
<span class="nb">using</span> i
</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect concl‚ÇÅ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mlTheory
  (Œì ‚±µ
   hyps--------------------------------------
   concl‚ÇÇ
   <span class="nb">using</span> i
   )
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÇ
      <span class="nb">using</span> i
      )
<span class="nb">using</span> mlInfo
        (Œì ‚±µ
         hyps--------------------------------------
         concl‚ÇÇ
         <span class="nb">using</span> i
         )</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
hyps--------------------------------------
concl‚ÇÅ
<span class="nb">using</span> i
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b8"><span class="nb">unfold</span> of_MLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mlTheory
  (Œì ‚±µ
   hyps--------------------------------------
   concl‚ÇÇ
   <span class="nb">using</span> i
   )
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÇ
      <span class="nb">using</span> i
      )
<span class="nb">using</span> mlInfo
        (Œì ‚±µ
         hyps--------------------------------------
         concl‚ÇÇ
         <span class="nb">using</span> i
         )</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÅ
      <span class="nb">using</span> i
      ))
‚Üí mlTheory
    (Œì ‚±µ
     hyps--------------------------------------
     concl‚ÇÅ
     <span class="nb">using</span> i
     )
  ‚ä¢i MLGoal_to_pattern
       (Œì ‚±µ
        hyps--------------------------------------
        concl‚ÇÅ
        <span class="nb">using</span> i
        )
  <span class="nb">using</span> mlInfo
          (Œì ‚±µ
           hyps--------------------------------------
           concl‚ÇÅ
           <span class="nb">using</span> i
           )</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2b9"><span class="nb">intros</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mlTheory
  (Œì ‚±µ
   hyps--------------------------------------
   concl‚ÇÇ
   <span class="nb">using</span> i
   )
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÇ
      <span class="nb">using</span> i
      )
<span class="nb">using</span> mlInfo
        (Œì ‚±µ
         hyps--------------------------------------
         concl‚ÇÇ
         <span class="nb">using</span> i
         )</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mlTheory
  (Œì ‚±µ
   hyps--------------------------------------
   concl‚ÇÅ
   <span class="nb">using</span> i
   )
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÅ
      <span class="nb">using</span> i
      )
<span class="nb">using</span> mlInfo
        (Œì ‚±µ
         hyps--------------------------------------
         concl‚ÇÅ
         <span class="nb">using</span> i
         )</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ba"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>mlTheory
  (Œì ‚±µ
   hyps--------------------------------------
   concl‚ÇÇ
   <span class="nb">using</span> i
   )
‚ä¢i MLGoal_to_pattern
     (Œì ‚±µ
      hyps--------------------------------------
      concl‚ÇÇ
      <span class="nb">using</span> i
      )
<span class="nb">using</span> mlInfo
        (Œì ‚±µ
         hyps--------------------------------------
         concl‚ÇÇ
         <span class="nb">using</span> i
         )</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect concl‚ÇÅ (map nh_pme hyps) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2bb"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect concl‚ÇÅ (map nh_pme hyps) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2bc"><span class="nb">pose proof</span> (Htmp := lift_to_mixed_context Œì concl‚ÇÅ concl‚ÇÇ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">pmes</span> : list ProofModeEntry) (<span class="nv">i</span> : ProofInfo),
  ProofInfoLe
    (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i
  ‚Üí well_formed
      (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
    ‚Üí well_formed
        (MLGoal_to_pattern&#39; concl‚ÇÇ pmes)
      ‚Üí Œì
        ‚ä¢i evar_open_fresh_iter
             (free_evars
                (MLGoal_to_pattern&#39; concl‚ÇÅ pmes)
              ‚à™ free_evars
                  (MLGoal_to_pattern&#39; concl‚ÇÇ
                     pmes))
             (foralls_count pmes)
             (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
        ‚Üí Œì
          ‚ä¢i foldr connect concl‚ÇÇ pmes ---&gt;
             foldr connect concl‚ÇÅ pmes <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect concl‚ÇÅ (map nh_pme hyps) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2bd"><span class="nb">specialize</span> (Htmp (map nh_pme hyps) _ pile).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect concl‚ÇÅ (map nh_pme hyps) <span class="nb">using</span> i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2be"><span class="nb">eapply</span> MP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="nl">?œï‚ÇÅ</span> <span class="nb">using</span> i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2bf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2bf"><hr></label><div class="goal-conclusion">Œì ‚ä¢i <span class="nl">?œï‚ÇÅ</span> ---&gt; foldr connect concl‚ÇÅ (map nh_pme hyps)
<span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2c0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2c0"><span class="mi">2</span>: <span class="nb">apply</span> Htmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) <span class="nb">using</span> i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2c1"><hr></label><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2c2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2c2"><hr></label><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÇ (map nh_pme hyps))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2c3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2c3"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ (map nh_pme hyps)))
     (foralls_count (map nh_pme hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2c4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2c4"><span class="mi">1</span>,<span class="mi">4</span>: <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2c5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2c5"><hr></label><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2c6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2c6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2c7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2c7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2c8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2c8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>concl‚ÇÅ, concl‚ÇÇ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>hyps</var><span class="hyp-type"><b>: </b><span>hypotheses</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ProofInfo</span></span></span><br><span><var>pile</var><span class="hyp-type"><b>: </b><span>ProofInfoLe
  (ExGen := ‚ä§, SVSubst := ‚àÖ, KT := false) i</span></span></span><br><span><var>wfxy</var><span class="hyp-type"><b>: </b><span>well_formed_xy (foralls_count (pmes_of hyps)) <span class="mi">0</span>
  concl‚ÇÇ</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter
     (free_evars
        (MLGoal_to_pattern&#39; concl‚ÇÅ
           (pmes_of hyps))
      ‚à™ free_evars
          (MLGoal_to_pattern&#39; concl‚ÇÇ
             (pmes_of hyps)))
     (foralls_count (pmes_of hyps))
     (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps)
<span class="nb">using</span> i</span></span></span><br><span><var>wf'</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect concl‚ÇÅ (map nh_pme hyps))</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÅ (map nh_pme hyps))
‚Üí well_formed
    (MLGoal_to_pattern&#39; concl‚ÇÇ
       (map nh_pme hyps))
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter
         (free_evars
            (MLGoal_to_pattern&#39; concl‚ÇÅ
               (map nh_pme hyps))
          ‚à™ free_evars
              (MLGoal_to_pattern&#39; concl‚ÇÇ
                 (map nh_pme hyps)))
         (foralls_count (map nh_pme hyps))
         (concl‚ÇÇ ---&gt; concl‚ÇÅ) <span class="nb">using</span> i
    ‚Üí Œì
      ‚ä¢i foldr connect concl‚ÇÇ (map nh_pme hyps) ---&gt;
         foldr connect concl‚ÇÅ (map nh_pme hyps)
      <span class="nb">using</span> i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (MLGoal_to_pattern&#39; concl‚ÇÇ (map nh_pme hyps))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">_mlCut</span> g&#39; :=
  <span class="kr">lazymatch goal with</span>
  | [ |- @of_MLGoal <span class="nl">?S</span> (mkMLGoal <span class="nl">?S</span> <span class="nl">?T</span> <span class="nl">?l</span> <span class="nl">?g</span> <span class="nl">?i</span>)] =&gt;
    <span class="nb">cut</span> (@of_MLGoal S (mkMLGoal S T l g&#39; i));
    [(
      <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span>
      <span class="nb">intros</span> H;
      <span class="nb">apply</span> MLGoal_lift_to_mixed_context <span class="kr">with</span> (concl‚ÇÇ := g&#39;);
      [
        (try_solve_pile)|
        (<span class="nb">cbn</span>; <span class="nb">unfold</span> decide; <span class="nb">cbn</span>)|
        (<span class="nb">cbn</span>; <span class="nb">unfold</span> decide; <span class="nb">cbn</span>)|
        (<span class="bp">exact</span> H)
      ]
       <span class="c">(*;</span>
<span class="c">      unshelve (eapply (MLGoal_lift_to_mixed_context _ _ _ _ _ _ _ H)) *)</span>
    )|]
  <span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlCut&quot;</span> <span class="kp">constr</span>(g&#39;) :=
  _mlCut g&#39;
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2c9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2c9">#[local]
<span class="kn">Example</span> <span class="nf">ex_mlCut</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">Œì</span> : Theory) (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Pattern) (<span class="nv">s1</span> <span class="nv">s2</span> : symbols)
  :
  well_formed a -&gt;
  well_formed b -&gt;
  well_formed c -&gt;
  Œì ‚ä¢ (patt_sym s1 ---&gt; patt_sym s2) -&gt;
  Œì ‚ä¢ <span class="kp">all</span>, (a $ b0 ---&gt; <span class="kp">all</span>, (b0 $ b $ b1 ---&gt; <span class="kp">all</span>, (patt_sym s1))) -&gt;
  Œì ‚ä¢ <span class="kp">all</span>, (a $ b0 ---&gt; <span class="kp">all</span>, (b0 $ b $ b1 ---&gt; <span class="kp">all</span>, (patt_sym s2)))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí well_formed b
  ‚Üí well_formed c
    ‚Üí Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2
      ‚Üí Œì
        ‚ä¢ <span class="kp">all</span> ,
          a $ b0 ---&gt;
          (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))
        ‚Üí Œì
          ‚ä¢ <span class="kp">all</span> ,
            a $ b0 ---&gt;
            (<span class="kp">all</span> ,
             b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ca" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí well_formed b
  ‚Üí well_formed c
    ‚Üí Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2
      ‚Üí Œì
        ‚ä¢ <span class="kp">all</span> ,
          a $ b0 ---&gt;
          (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))
        ‚Üí Œì
          ‚ä¢ <span class="kp">all</span> ,
            a $ b0 ---&gt;
            (<span class="kp">all</span> ,
             b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2cb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2cb"><span class="nb">intros</span> wfa wfb wfc Himpl H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2cc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2cc">toMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (<span class="kp">all</span> ,
   a $ b0 ---&gt;
   (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2cd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2cd"><hr></label><div class="goal-conclusion">Œì ‚±µ
 <span class="kp">all</span> ,
 a $ b0 ---&gt;
 (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2))
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ce" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ce">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (<span class="kp">all</span> ,
   a $ b0 ---&gt;
   (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2cf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2cf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
 <span class="kp">all</span> ,
 a $ b0 ---&gt;
 (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2))
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d0">mlIntroForall <span class="s2">&quot;x&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
--------------------------------------
a $ b0 ---&gt;
(<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2))
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d1">mlIntro <span class="s2">&quot;H1&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
--------------------------------------
<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2)
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d2">mlIntroForall <span class="s2">&quot;y&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
--------------------------------------
b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2)
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d3">mlIntro <span class="s2">&quot;H2&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
--------------------------------------
<span class="kp">all</span> , patt_sym s2
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d4">mlIntroForall <span class="s2">&quot;z&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s2
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d5">mlCut (patt_sym s1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2d6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2d6"><hr></label><div class="goal-conclusion">Œì ‚ä¢i patt_sym s1 ---&gt; patt_sym s2 <span class="nb">using</span> AnyReasoning</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2d7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2d7"><hr></label><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2d9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2d9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i patt_sym s1 ---&gt; patt_sym s2 <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2da" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2da"><hr></label><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2db" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2db">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i patt_sym s1 ---&gt; patt_sym s2 <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Himpl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2dc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2dc">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* now the conclusion is [patt_sym s1] *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2dd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2dd">fromMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i <span class="kp">all</span> ,
   a $ b0 ---&gt;
   (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2de" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2de">#[local]
<span class="kn">Example</span> <span class="nf">ex_mlCut2</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">Œì</span> : Theory) (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Pattern) (<span class="nv">s1</span> <span class="nv">s2</span> : symbols)
  :
  well_formed a -&gt;
  well_formed b -&gt;
  well_formed c -&gt;
  Œì ‚ä¢ (patt_sym s1 ---&gt; patt_sym s2) -&gt;
  Œì ‚ä¢ <span class="kp">all</span>, (a $ b0 ---&gt; <span class="kp">all</span>, (b0 $ b $ b1 ---&gt; <span class="kp">all</span>, (patt_sym s1 $ b1))) -&gt;
  Œì ‚ä¢ <span class="kp">all</span>, (a $ b0 ---&gt; <span class="kp">all</span>, (b0 $ b $ b1 ---&gt; <span class="kp">all</span>, (patt_sym s2 $ b1)))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí well_formed b
  ‚Üí well_formed c
    ‚Üí Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2
      ‚Üí Œì
        ‚ä¢ <span class="kp">all</span> ,
          a $ b0 ---&gt;
          (<span class="kp">all</span> ,
           b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))
        ‚Üí Œì
          ‚ä¢ <span class="kp">all</span> ,
            a $ b0 ---&gt;
            (<span class="kp">all</span> ,
             b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2df" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2df"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a
‚Üí well_formed b
  ‚Üí well_formed c
    ‚Üí Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2
      ‚Üí Œì
        ‚ä¢ <span class="kp">all</span> ,
          a $ b0 ---&gt;
          (<span class="kp">all</span> ,
           b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))
        ‚Üí Œì
          ‚ä¢ <span class="kp">all</span> ,
            a $ b0 ---&gt;
            (<span class="kp">all</span> ,
             b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e0"><span class="nb">intros</span> wfa wfb wfc Himpl H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e1">toMLGoal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (<span class="kp">all</span> ,
   a $ b0 ---&gt;
   (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2e2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2e2"><hr></label><div class="goal-conclusion">Œì ‚±µ
 <span class="kp">all</span> ,
 a $ b0 ---&gt;
 (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1))
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (<span class="kp">all</span> ,
   a $ b0 ---&gt;
   (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
 <span class="kp">all</span> ,
 a $ b0 ---&gt;
 (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1))
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e5">mlIntroForall <span class="s2">&quot;x&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
--------------------------------------
a $ b0 ---&gt;
(<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1))
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e6">mlIntro <span class="s2">&quot;H1&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
--------------------------------------
<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1)
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e7">mlIntroForall <span class="s2">&quot;y&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
--------------------------------------
b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s2 $ b1)
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e8">mlIntro <span class="s2">&quot;H2&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
--------------------------------------
<span class="kp">all</span> , patt_sym s2 $ b1
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2e9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2e9">mlIntroForall <span class="s2">&quot;z&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s2 $ b1
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ea" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ea">mlCut (patt_sym s1 $ b1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">3</span> <span class="mi">0</span> (patt_sym s1 $ b1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2eb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2eb"><hr></label><div class="goal-conclusion">Œì
‚ä¢i patt_sym s1 $
   patt_free_evar
     (evar_fresh_s
        (free_evars a ‚à™ ‚àÖ
         ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ) ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ)
            ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
         ‚à™ (free_evars a ‚à™ ‚àÖ
            ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
               ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ)
         ‚à™ {[evar_fresh_s
               (free_evars a ‚à™ ‚àÖ
                ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                   ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
                ‚à™ (free_evars a ‚à™ ‚àÖ
                   ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                      ‚à™ 
                      (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ))]})) ---&gt;
   patt_sym s2 $
   patt_free_evar
     (evar_fresh_s
        (free_evars a ‚à™ ‚àÖ
         ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ) ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ)
            ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
         ‚à™ (free_evars a ‚à™ ‚àÖ
            ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
               ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ)
         ‚à™ {[evar_fresh_s
               (free_evars a ‚à™ ‚àÖ
                ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                   ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
                ‚à™ (free_evars a ‚à™ ‚àÖ
                   ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                      ‚à™ 
                      (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ))]}))
<span class="nb">using</span> AnyReasoning</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2ec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2ec"><hr></label><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ed" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ed">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">3</span> <span class="mi">0</span> (patt_sym s1 $ b1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2ee" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2ee">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i patt_sym s1 $
   patt_free_evar
     (evar_fresh_s
        (free_evars a ‚à™ ‚àÖ
         ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ) ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ)
            ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
         ‚à™ (free_evars a ‚à™ ‚àÖ
            ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
               ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ)
         ‚à™ {[evar_fresh_s
               (free_evars a ‚à™ ‚àÖ
                ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                   ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
                ‚à™ (free_evars a ‚à™ ‚àÖ
                   ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                      ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ
                   ‚à™ ‚àÖ))]})) ---&gt;
   patt_sym s2 $
   patt_free_evar
     (evar_fresh_s
        (free_evars a ‚à™ ‚àÖ
         ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ) ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ)
            ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
         ‚à™ (free_evars a ‚à™ ‚àÖ
            ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
               ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ)
         ‚à™ {[evar_fresh_s
               (free_evars a ‚à™ ‚àÖ
                ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                   ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
                ‚à™ (free_evars a ‚à™ ‚àÖ
                   ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                      ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ
                   ‚à™ ‚àÖ))]})) <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2ef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2ef"><hr></label><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i patt_sym s1 $
   patt_free_evar
     (evar_fresh_s
        (free_evars a ‚à™ ‚àÖ
         ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ) ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ)
            ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
         ‚à™ (free_evars a ‚à™ ‚àÖ
            ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
               ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ)
         ‚à™ {[evar_fresh_s
               (free_evars a ‚à™ ‚àÖ
                ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                   ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
                ‚à™ (free_evars a ‚à™ ‚àÖ
                   ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                      ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ
                   ‚à™ ‚àÖ))]})) ---&gt;
   patt_sym s2 $
   patt_free_evar
     (evar_fresh_s
        (free_evars a ‚à™ ‚àÖ
         ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ) ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ)
            ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
         ‚à™ (free_evars a ‚à™ ‚àÖ
            ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
               ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ)
         ‚à™ {[evar_fresh_s
               (free_evars a ‚à™ ‚àÖ
                ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                   ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ
                ‚à™ (free_evars a ‚à™ ‚àÖ
                   ‚à™ (‚àÖ ‚à™ (free_evars b ‚à™ ‚àÖ)
                      ‚à™ (‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ ‚à™ ‚àÖ) ‚à™ ‚àÖ
                   ‚à™ ‚àÖ))]})) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    <span class="c">(* TODO have Framing available there. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f1">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a</span></span></span><br><span><var>wfb</var><span class="hyp-type"><b>: </b><span>well_formed b</span></span></span><br><span><var>wfc</var><span class="hyp-type"><b>: </b><span>well_formed c</span></span></span><br><span><var>Himpl</var><span class="hyp-type"><b>: </b><span>Œì ‚ä¢ patt_sym s1 ---&gt; patt_sym s2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢ <span class="kp">all</span> ,
  a $ b0 ---&gt;
  (<span class="kp">all</span> , b0 $ b $ b1 ---&gt; (<span class="kp">all</span> , patt_sym s1 $ b1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚±µ
<span class="s2">&quot;x&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H1&quot;</span> ‚à∂ pme_pattern (a $ b0),
<span class="s2">&quot;y&quot;</span> ‚à∂ pme_variable,
<span class="s2">&quot;H2&quot;</span> ‚à∂ pme_pattern (b0 $ b $ b1),
<span class="s2">&quot;z&quot;</span> ‚à∂ pme_variable,
--------------------------------------
patt_sym s1 $ b1
</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f2"><span class="kn">Lemma</span> <span class="nf">evar_open_fresh_iter_impl</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">avoid</span> <span class="nv">m</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">base</span> :
  evar_open_fresh_iter_base avoid base m  (a ---&gt; b)
  = (evar_open_fresh_iter_base avoid base m a ---&gt; evar_open_fresh_iter_base avoid base m b)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base m (a ---&gt; b) =
(evar_open_fresh_iter_base avoid base m a ---&gt;
 evar_open_fresh_iter_base avoid base m b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base m (a ---&gt; b) =
(evar_open_fresh_iter_base avoid base m a ---&gt;
 evar_open_fresh_iter_base avoid base m b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f4"><span class="nb">move</span>: a b avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">a</span> <span class="nv">b</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  evar_open_fresh_iter_base avoid base m (a ---&gt; b) =
  (evar_open_fresh_iter_base avoid base m a ---&gt;
   evar_open_fresh_iter_base avoid base m b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f5"><span class="nb">induction</span> m; <span class="nb">intros</span> a b avoid; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ---&gt; b) = (a ---&gt; b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2f6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> <span class="nv">b</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  evar_open_fresh_iter_base avoid base m
    (a ---&gt; b) =
  (evar_open_fresh_iter_base avoid base m a ---&gt;
   evar_open_fresh_iter_base avoid base m b)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2f6"><hr></label><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (a ---&gt; b)^{<span class="nb">evar</span>:base + m‚Ü¶
  evar_fresh_s avoid} =
(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   a^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} ---&gt;
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   b^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a ---&gt; b) = (a ---&gt; b)</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> <span class="nv">b</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  evar_open_fresh_iter_base avoid base m
    (a ---&gt; b) =
  (evar_open_fresh_iter_base avoid base m a ---&gt;
   evar_open_fresh_iter_base avoid base m b)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (a ---&gt; b)^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} =
(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   a^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} ---&gt;
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   b^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2f9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2f9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> <span class="nv">b</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  evar_open_fresh_iter_base avoid base m
    (a ---&gt; b) =
  (evar_open_fresh_iter_base avoid base m a ---&gt;
   evar_open_fresh_iter_base avoid base m b)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (a ---&gt; b)^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} =
(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   a^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} ---&gt;
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   b^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2fa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2fa"><span class="nb">rewrite</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> <span class="nv">b</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  evar_open_fresh_iter_base avoid base m
    (a ---&gt; b) =
  (evar_open_fresh_iter_base avoid base m a ---&gt;
   evar_open_fresh_iter_base avoid base m b)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   ((<span class="kr">fix</span> bevar_subst
       (psi : Pattern) (x : db_index) (phi : Pattern)
       {<span class="kr">struct</span> phi} : Pattern :=
       <span class="kr">match</span> phi <span class="kr">with</span>
       | patt_free_evar x&#39; =&gt; patt_free_evar x&#39;
       | patt_free_svar x&#39; =&gt; patt_free_svar x&#39;
       | patt_bound_evar n =&gt;
           <span class="kr">match</span> compare_nat n x <span class="kr">with</span>
           | Nat_less _ _ _ =&gt; patt_bound_evar n
           | Nat_equal _ _ _ =&gt; psi
           | Nat_greater _ _ _ =&gt;
               patt_bound_evar (Nat.pred n)
           <span class="kr">end</span>
       | patt_bound_svar n =&gt; patt_bound_svar n
       | patt_sym sigma =&gt; patt_sym sigma
       | phi1 $ phi2 =&gt;
           bevar_subst psi x phi1 $
           bevar_subst psi x phi2
       | ‚ä• =&gt; ‚ä•
       | phi1 ---&gt; phi2 =&gt;
           bevar_subst psi x phi1 ---&gt;
           bevar_subst psi x phi2
       | ex , phi&#39; =&gt; ex , bevar_subst psi (S x) phi&#39;
       | mu , phi&#39; =&gt; mu , bevar_subst psi x phi&#39;
       <span class="kr">end</span>) (patt_free_evar (evar_fresh_s avoid))
      (base + m) a) ---&gt;
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   ((<span class="kr">fix</span> bevar_subst
       (psi : Pattern) (x : db_index) (phi : Pattern)
       {<span class="kr">struct</span> phi} : Pattern :=
       <span class="kr">match</span> phi <span class="kr">with</span>
       | patt_free_evar x&#39; =&gt; patt_free_evar x&#39;
       | patt_free_svar x&#39; =&gt; patt_free_svar x&#39;
       | patt_bound_evar n =&gt;
           <span class="kr">match</span> compare_nat n x <span class="kr">with</span>
           | Nat_less _ _ _ =&gt; patt_bound_evar n
           | Nat_equal _ _ _ =&gt; psi
           | Nat_greater _ _ _ =&gt;
               patt_bound_evar (Nat.pred n)
           <span class="kr">end</span>
       | patt_bound_svar n =&gt; patt_bound_svar n
       | patt_sym sigma =&gt; patt_sym sigma
       | phi1 $ phi2 =&gt;
           bevar_subst psi x phi1 $
           bevar_subst psi x phi2
       | ‚ä• =&gt; ‚ä•
       | phi1 ---&gt; phi2 =&gt;
           bevar_subst psi x phi1 ---&gt;
           bevar_subst psi x phi2
       | ex , phi&#39; =&gt; ex , bevar_subst psi (S x) phi&#39;
       | mu , phi&#39; =&gt; mu , bevar_subst psi x phi&#39;
       <span class="kr">end</span>) (patt_free_evar (evar_fresh_s avoid))
      (base + m) b)) =
(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   a^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} ---&gt;
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) base m
   b^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2fb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2fb"><span class="kn">Lemma</span> <span class="nf">evar_open_fresh_iter_top</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">avoid</span> <span class="nv">m</span>  <span class="nv">base</span> :
  evar_open_fresh_iter_base avoid base m patt_top
  = patt_top
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base m Top = Top</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2fc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2fc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base m Top = Top</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2fd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2fd"><span class="nb">move</span>: avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
  evar_open_fresh_iter_base avoid base m Top = Top</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk2fe" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk2fe"><span class="nb">induction</span> m; <span class="nb">intros</span> avoid; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Top = Top</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk2ff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
  evar_open_fresh_iter_base avoid base m Top =
  Top</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk2ff"><hr></label><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  Top^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} = Top</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk300" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk300">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Top = Top</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk301" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk301">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
  evar_open_fresh_iter_base avoid base m Top =
  Top</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  Top^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} = Top</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk302" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk302">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
  evar_open_fresh_iter_base avoid base m Top =
  Top</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  Top^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} = Top</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk303" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk303"><span class="nb">rewrite</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
  evar_open_fresh_iter_base avoid base m Top =
  Top</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Top = Top</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk304" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk304"><span class="kn">Lemma</span> <span class="nf">evar_open_fresh_iter_base_wfc_aux</span>:
  <span class="kr">‚àÄ</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">db2</span> : nat) (<span class="nv">phi</span> : Pattern) <span class="nv">avoid</span> <span class="nv">base</span>,
	well_formed_closed_ex_aux phi <span class="mi">0</span> ‚Üí
  evar_open_fresh_iter_base avoid base db2 phi = phi
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">Œ£</span> : Signature) (<span class="nv">db2</span> : nat) (<span class="nv">phi</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) 
  (<span class="nv">base</span> : nat),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk305" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk305"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">Œ£</span> : Signature) (<span class="nv">db2</span> : nat) (<span class="nv">phi</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) 
  (<span class="nv">base</span> : nat),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk306" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk306"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk307" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk307"><span class="nb">move</span>: avoid base phi H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk308" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk308"><span class="nb">induction</span> db2; <span class="nb">intros</span> avoid base phi Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base <span class="mi">0</span> phi = phi</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk309" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk309"><hr></label><div class="goal-conclusion">evar_open_fresh_iter_base avoid base (S db2) phi = phi</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk30a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk30a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base <span class="mi">0</span> phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk30b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk30b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk30c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk30c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base (S db2) phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk30d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk30d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base (S db2) phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk30e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk30e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base db2
  phi^{<span class="nb">evar</span>:base + db2‚Ü¶evar_fresh_s avoid} = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk30f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk30f"><span class="nb">unfold</span> evar_open_fresh_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base db2
  phi^{<span class="nb">evar</span>:base + db2‚Ü¶evar_fresh_s avoid} = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk310" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk310"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base db2
  phi^{<span class="nb">evar</span>:base + db2‚Ü¶evar_fresh_s avoid} = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk311" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk311"><span class="nb">rewrite</span> (evar_open_wfc_aux db2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">db2 ‚â§ base + db2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk312" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk312"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux phi db2</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk313" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk313"><hr></label><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base db2 phi = phi</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk314" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk314">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">db2 ‚â§ base + db2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk315" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk315">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi db2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk316" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk316"><hr></label><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base db2 phi = phi</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk317" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk317">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi db2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk318" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk318"><span class="nb">eapply</span> well_formed_closed_ex_aux_ind;[|<span class="nb">apply</span> Hwf].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ db2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk319" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk319">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk31a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk31a"><span class="nb">apply</span> IHdb2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHdb2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) 
  (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter_base avoid base db2
      phi = phi</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hwf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk31b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk31b"><span class="kn">Lemma</span> <span class="nf">evar_open_fresh_iter_wfc_aux</span>:
  <span class="kr">‚àÄ</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">db2</span> : nat) (<span class="nv">phi</span> : Pattern) <span class="nv">avoid</span>,
	well_formed_closed_ex_aux phi <span class="mi">0</span> ‚Üí
  evar_open_fresh_iter avoid db2 phi = phi
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">Œ£</span> : Signature) (<span class="nv">db2</span> : nat) (<span class="nv">phi</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter avoid db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk31c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk31c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">Œ£</span> : Signature) (<span class="nv">db2</span> : nat) (<span class="nv">phi</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  well_formed_closed_ex_aux phi <span class="mi">0</span>
  ‚Üí evar_open_fresh_iter avoid db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk31d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk31d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter avoid db2 phi = phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk31e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk31e"><span class="nb">apply</span> evar_open_fresh_iter_base_wfc_aux.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>db2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk31f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk31f"><span class="kn">Lemma</span> <span class="nf">well_formed_evar_open_fresh_iter</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">avoid</span> <span class="nv">m</span> <span class="nv">p</span>:
  well_formed_xy m <span class="mi">0</span> p -&gt;
  well_formed (evar_open_fresh_iter avoid m p)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> p
‚Üí well_formed (evar_open_fresh_iter avoid m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk320" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk320"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> p
‚Üí well_formed (evar_open_fresh_iter avoid m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk321" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk321"><span class="nb">move</span>: p avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  well_formed_xy m <span class="mi">0</span> p
  ‚Üí well_formed (evar_open_fresh_iter avoid m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk322" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk322"><span class="nb">induction</span> m; <span class="nb">simpl</span>; <span class="nb">intros</span> p avoid H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span> p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter avoid <span class="mi">0</span> p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk323" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
  well_formed_xy m <span class="mi">0</span> p
  ‚Üí well_formed (evar_open_fresh_iter avoid m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> p</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk323"><hr></label><div class="goal-conclusion">well_formed (evar_open_fresh_iter avoid (S m) p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk324" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk324">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span> p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter avoid <span class="mi">0</span> p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk325" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk325">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
well_formed_xy m <span class="mi">0</span> p ‚Üí well_formed (evar_open_fresh_iter avoid m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter avoid (S m) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk326" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk326">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
well_formed_xy m <span class="mi">0</span> p ‚Üí well_formed (evar_open_fresh_iter avoid m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter avoid (S m) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk327" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk327"><span class="nb">apply</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet),
well_formed_xy m <span class="mi">0</span> p ‚Üí well_formed (evar_open_fresh_iter avoid m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> p^{<span class="nb">evar</span>:<span class="mi">0</span> + m‚Ü¶evar_fresh_s avoid}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk328" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk328"><span class="kn">Lemma</span> <span class="nf">evar_open_fresh_iter_base_forall</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">avoid</span> <span class="nv">base</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">l</span>:
  evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l)
  = <span class="kp">all</span>, (evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base m
  (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base avoid (S base) m
   (foldr connect p l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk329" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk329"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base avoid base m
  (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base avoid (S base) m
   (foldr connect p l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk32a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk32a"><span class="nb">move</span>: l p avoid base.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) 
  (<span class="nv">base</span> : nat),
  evar_open_fresh_iter_base avoid base m
    (<span class="kp">all</span> , foldr connect p l) =
  (<span class="kp">all</span> ,
   evar_open_fresh_iter_base avoid (S base) m
     (foldr connect p l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk32b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk32b"><span class="nb">induction</span> m; <span class="nb">simpl</span>; <span class="nb">intros</span> l p avoid base.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kp">all</span> , foldr connect p l) = (<span class="kp">all</span> , foldr connect p l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk32c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) 
  (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) 
  (<span class="nv">base</span> : nat),
  evar_open_fresh_iter_base avoid base m
    (<span class="kp">all</span> , foldr connect p l) =
  (<span class="kp">all</span> ,
   evar_open_fresh_iter_base avoid 
     (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk32c"><hr></label><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (<span class="kp">all</span> , foldr connect p l)^{<span class="nb">evar</span>:
  base + m‚Ü¶evar_fresh_s avoid} =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) 
   (S base) m
   (foldr connect p l)^{<span class="nb">evar</span>:
   S (base + m)‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk32d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk32d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kp">all</span> , foldr connect p l) = (<span class="kp">all</span> , foldr connect p l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk32e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk32e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat),
evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> , evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (<span class="kp">all</span> , foldr connect p l)^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s
                                             avoid} =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect p l)^{<span class="nb">evar</span>:S (base + m)‚Ü¶evar_fresh_s
                                            avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk32f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk32f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat),
evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> , evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (<span class="kp">all</span> , foldr connect p l)^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s
                                             avoid} =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect p l)^{<span class="nb">evar</span>:S (base + m)‚Ü¶evar_fresh_s
                                            avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk330" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk330">mlSimpl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat),
evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> , evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (<span class="kp">all</span> ,
   (foldr connect p l)^{<span class="nb">evar</span>:S (base + m)‚Ü¶evar_fresh_s
                                            avoid}) =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect p l)^{<span class="nb">evar</span>:S (base + m)‚Ü¶evar_fresh_s
                                            avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk331" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk331"><span class="nb">rewrite</span> evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat),
evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> , evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (<span class="kp">all</span> ,
   foldr connect
     p^{<span class="nb">evar</span>:S (base + m) + foralls_count l‚Ü¶evar_fresh_s
                                              avoid}
     (evar_open_pmes (S (base + m))
        (evar_fresh_s avoid) l)) =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect
      p^{<span class="nb">evar</span>:S (base + m) + foralls_count l‚Ü¶evar_fresh_s
                                               avoid}
      (evar_open_pmes (S (base + m))
         (evar_fresh_s avoid) l)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk332" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk332"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat),
evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> , evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) base m
  (<span class="kp">all</span> ,
   foldr connect
     p^{<span class="nb">evar</span>:S (base + m + foralls_count l)‚Ü¶evar_fresh_s
                                              avoid}
     (evar_open_pmes (S (base + m))
        (evar_fresh_s avoid) l)) =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect
      p^{<span class="nb">evar</span>:S (base + m + foralls_count l)‚Ü¶evar_fresh_s
                                               avoid}
      (evar_open_pmes (S (base + m))
         (evar_fresh_s avoid) l)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk333" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk333"><span class="nb">rewrite</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat),
evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> , evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect
      p^{<span class="nb">evar</span>:S (base + m + foralls_count l)‚Ü¶evar_fresh_s
                                               avoid}
      (evar_open_pmes (S (base + m))
         (evar_fresh_s avoid) l))) =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect
      p^{<span class="nb">evar</span>:S (base + m + foralls_count l)‚Ü¶evar_fresh_s
                                               avoid}
      (evar_open_pmes (S (base + m))
         (evar_fresh_s avoid) l)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk334" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk334"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">l</span> : list ProofModeEntry) (<span class="nv">p</span> : Pattern) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat),
evar_open_fresh_iter_base avoid base m (<span class="kp">all</span> , foldr connect p l) =
(<span class="kp">all</span> , evar_open_fresh_iter_base avoid (S base) m (foldr connect p l))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect
      p^{<span class="nb">evar</span>:S (base + m + foralls_count l)‚Ü¶evar_fresh_s
                                               avoid}
      (evar_open_pmes (S (base + m))
         (evar_fresh_s avoid) l))) =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S base) m
   (foldr connect
      p^{<span class="nb">evar</span>:S (base + m + foralls_count l)‚Ü¶evar_fresh_s
                                               avoid}
      (evar_open_pmes (S (base + m))
         (evar_fresh_s avoid) l)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk335" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk335"><span class="kn">Lemma</span> <span class="nf">forall_quantify_evar_open</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">x&#39;</span> <span class="nv">p</span> :
  x&#39; ‚àâ free_evars p -&gt;
  well_formed_closed_ex_aux p <span class="mi">1</span> -&gt;
  (forall_quantify x&#39; (evar_open x&#39; <span class="mi">0</span> p))
  = (<span class="kp">all</span> , p)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x&#39; ‚àâ free_evars p
‚Üí well_formed_closed_ex_aux p <span class="mi">1</span>
  ‚Üí forall_quantify x&#39; p^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;} = (<span class="kp">all</span> , p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk336" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk336"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x&#39; ‚àâ free_evars p
‚Üí well_formed_closed_ex_aux p <span class="mi">1</span>
  ‚Üí forall_quantify x&#39; p^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;} = (<span class="kp">all</span> , p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk337" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk337"><span class="nb">intros</span> H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x&#39; ‚àâ free_evars p</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_quantify x&#39; p^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;} = (<span class="kp">all</span> , p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk338" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk338"><span class="nb">unfold</span> forall_quantify, patt_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x&#39; ‚àâ free_evars p</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(! (ex , ! p^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;}^{{<span class="nb">evar</span>:x&#39;‚Ü¶<span class="mi">0</span>}})) =
(! (ex , ! p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> evar_quantify_evar_open.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk339" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk339"><span class="kn">Lemma</span> <span class="nf">evar_fresh_nth_avoid</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">avoid</span> <span class="nv">m</span> :
 evar_fresh_nth (avoid) m ‚àâ avoid
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m ‚àâ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk33a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk33a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m ‚àâ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk33b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk33b"><span class="nb">move</span>: avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, evar_fresh_nth avoid m ‚àâ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk33c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk33c"><span class="nb">induction</span> m; <span class="nb">simpl</span>; <span class="nb">intros</span> avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid ‚àâ avoid</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk33d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
  evar_fresh_nth avoid m ‚àâ avoid</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk33d"><hr></label><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m
‚àâ avoid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk33e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk33e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid ‚àâ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> set_evar_fresh_is_fresh&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk33f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk33f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, evar_fresh_nth avoid m ‚àâ avoid</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m
‚àâ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk340" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk340">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, evar_fresh_nth avoid m ‚àâ avoid</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m
‚àâ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk341" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk341"><span class="nb">specialize</span> (IHm (avoid ‚à™ {[evar_fresh_s avoid]})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span>evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]})
  m ‚àâ avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m
‚àâ avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk342" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk342"><span class="kn">Lemma</span> <span class="nf">evar_fresh_nth_notin_free_evars_evar_open_fresh_iter_base</span>
  {<span class="nv">Œ£</span> : Signature} (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">p</span> : Pattern)
  :
  (<span class="kr">forall</span> <span class="nv">m</span>, (evar_fresh_nth avoid m) ‚àâ (free_evars p)) -&gt;
  <span class="kr">forall</span> <span class="nv">m</span>, (evar_fresh_nth avoid m)
  ‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí <span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
    evar_fresh_nth avoid m
    ‚àâ free_evars
        (evar_open_fresh_iter_base avoid base m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk343" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk343"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí <span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
    evar_fresh_nth avoid m
    ‚àâ free_evars
        (evar_open_fresh_iter_base avoid base m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk344" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk344"><span class="nb">intros</span> H m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m
‚àâ free_evars
    (evar_open_fresh_iter_base avoid base m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk345" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk345"><span class="nb">move</span>: p base avoid H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
  (<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
  ‚Üí evar_fresh_nth avoid m
    ‚àâ free_evars
        (evar_open_fresh_iter_base avoid base m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk346" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk346"><span class="nb">induction</span> m; <span class="nb">simpl</span>; <span class="nb">intros</span> p base avoid H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid ‚àâ free_evars p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk347" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
  (<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
     evar_fresh_nth avoid m ‚àâ free_evars p)
  ‚Üí evar_fresh_nth avoid m
    ‚àâ free_evars
        (evar_open_fresh_iter_base avoid base m
           p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk347"><hr></label><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m
‚àâ free_evars
    (evar_open_fresh_iter_base
       (avoid ‚à™ {[evar_fresh_s avoid]}) base m
       p^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk348" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk348">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid ‚àâ free_evars p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H <span class="mi">0</span>).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk349" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk349">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m
‚àâ free_evars
    (evar_open_fresh_iter_base
       (avoid ‚à™ {[evar_fresh_s avoid]}) base m
       p^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk34a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk34a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m
‚àâ free_evars
    (evar_open_fresh_iter_base
       (avoid ‚à™ {[evar_fresh_s avoid]}) base m
       p^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk34b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk34b"><span class="nb">apply</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">m0</span> : nat,
  evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
  ‚àâ free_evars p^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk34c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk34c"><span class="nb">intros</span> m0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚àâ free_evars p^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk34d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk34d"><span class="nb">apply</span> evar_open_fresh_notin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚àâ free_evars p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk34e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
  (<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
     evar_fresh_nth avoid m ‚àâ free_evars p)
  ‚Üí evar_fresh_nth avoid m
    ‚àâ free_evars
        (evar_open_fresh_iter_base avoid base m
           p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk34e"><hr></label><div class="goal-conclusion">evar_fresh_s avoid ‚àâ free_evars p</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk34f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
  (<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
     evar_fresh_nth avoid m ‚àâ free_evars p)
  ‚Üí evar_fresh_nth avoid m
    ‚àâ free_evars
        (evar_open_fresh_iter_base avoid base m
           p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk34f"><hr></label><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚â† evar_fresh_s avoid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk350" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk350"><span class="mi">3</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚â† evar_fresh_s avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk351" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk351"><span class="nb">pose proof</span> (H0 := evar_fresh_nth_avoid (avoid ‚à™ {[evar_fresh_s avoid]}) m0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]})
  m0 ‚àâ avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚â† evar_fresh_s avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk352" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk352"><span class="nb">clear</span> -H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]})
  m0 ‚àâ avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚â† evar_fresh_s avoid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk353" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk353">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚àâ free_evars p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk354" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
  (<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
     evar_fresh_nth avoid m ‚àâ free_evars p)
  ‚Üí evar_fresh_nth avoid m
    ‚àâ free_evars
        (evar_open_fresh_iter_base avoid base m
           p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk354"><hr></label><div class="goal-conclusion">evar_fresh_s avoid ‚àâ free_evars p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk355" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk355"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m0
‚àâ free_evars p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H (S m0)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk356" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk356">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid ‚àâ free_evars p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk357" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk357">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">p</span> : Pattern) (<span class="nv">base</span> : nat) (<span class="nv">avoid</span> : EVarSet),
(<span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p)
‚Üí evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid base m p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars p</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s avoid ‚àâ free_evars p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk358" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk358"><span class="kn">Lemma</span> <span class="nf">wfce_eofib</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">avoid</span> <span class="nv">base</span> <span class="nv">m</span> <span class="nv">phi</span> :
  well_formed_closed_ex_aux
    (evar_open_fresh_iter_base avoid base m phi) base
  = well_formed_closed_ex_aux phi (base+m)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk359" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk359"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk35a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk35a"><span class="nb">move</span>: avoid base phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux
    (evar_open_fresh_iter_base avoid base m phi) base =
  well_formed_closed_ex_aux phi (base + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk35b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk35b"><span class="nb">induction</span> m; <span class="nb">simpl</span>; <span class="nb">intros</span> avoid base phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi base =
well_formed_closed_ex_aux phi (base + <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk35c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux
    (evar_open_fresh_iter_base avoid base m phi)
    base =
  well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk35c"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) base m
     phi^{<span class="nb">evar</span>:base + m‚Ü¶
     evar_fresh_s avoid}) base =
well_formed_closed_ex_aux phi (base + S m)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk35d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk35d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi base =
well_formed_closed_ex_aux phi (base + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk35e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk35e"><span class="nb">rewrite</span> Nat.add_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi base =
well_formed_closed_ex_aux phi base</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk35f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk35f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) base m
     phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}) base =
well_formed_closed_ex_aux phi (base + S m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk360" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk360">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) base m
     phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}) base =
well_formed_closed_ex_aux phi (base + S m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk361" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk361"><span class="nb">rewrite</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} (base + m) =
well_formed_closed_ex_aux phi (base + S m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk362" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk362"><span class="nb">rewrite</span> Nat.add_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} (base + m) =
well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk363" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk363"><span class="nb">remember</span> (well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} (base + m))
      <span class="kr">as</span> b
    .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>b =
well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk364" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk364"><span class="nb">destruct</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>true =
well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk365" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
  well_formed_closed_ex_aux
    (evar_open_fresh_iter_base avoid base m phi)
    base =
  well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>false =
well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk365"><hr></label><div class="goal-conclusion">false = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk366" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk366">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>true =
well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk367" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk367"><span class="nb">symmetry in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk368" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk368"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S (base + m)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk369" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk369"><span class="nb">apply</span> wfc_ex_aux_body_ex_imp2 <span class="kr">in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi (S (base + m)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S (base + m)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Heqb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk36a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk36a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>false =
well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk36b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk36b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>false =
well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk36c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk36c"><span class="nb">symmetry in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = well_formed_closed_ex_aux phi (S (base + m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk36d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk36d"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S (base + m)) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk36e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk36e"><span class="nb">rewrite</span> -not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S (base + m)) ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk36f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk36f"><span class="nb">rewrite</span> -not_true_iff_false <span class="kr">in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) ‚â† true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S (base + m)) ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk370" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk370"><span class="nb">intros</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi (S (base + m)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk371" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk371"><span class="nb">apply</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi (S (base + m)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid} (base + m) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk372" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk372"><span class="nb">apply</span> wfc_ex_aux_body_ex_imp1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">avoid</span> : EVarSet) (<span class="nv">base</span> : nat) (<span class="nv">phi</span> : Pattern),
well_formed_closed_ex_aux (evar_open_fresh_iter_base avoid base m phi) base =
well_formed_closed_ex_aux phi (base + m)</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>base</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  phi^{<span class="nb">evar</span>:base + m‚Ü¶evar_fresh_s avoid}
  (base + m) ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi (S (base + m)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S (base + m)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> HContra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk373" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk373"><span class="kn">Lemma</span> <span class="nf">wfcex_pmes_evar_open_pmes</span> {<span class="nv">Œ£</span> : Signature}
  <span class="nv">m</span> <span class="nv">x</span> <span class="nv">l</span>
  :
  wfcex_pmes m (evar_open_pmes m x l) = true -&gt;
  wfcex_pmes (S m) l = true
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m (evar_open_pmes m x l) = true
‚Üí wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk374" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk374"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m (evar_open_pmes m x l) = true
‚Üí wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk375" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk375"><span class="nb">move</span>: x m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
  wfcex_pmes m (evar_open_pmes m x l) = true
  ‚Üí wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk376" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk376"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span> x m H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk377" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
      :: evar_open_pmes m x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x l
  <span class="kr">end</span> = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk377"><hr></label><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p (S m) &amp;&amp;
    wfcex_pmes (S m) l
| pme_variable =&gt; wfcex_pmes (S (S m)) l
<span class="kr">end</span> = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk378" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk378">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk379" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk379">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
      :: evar_open_pmes m x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x l
  <span class="kr">end</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p (S m) &amp;&amp;
    wfcex_pmes (S m) l
| pme_variable =&gt; wfcex_pmes (S (S m)) l
<span class="kr">end</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk37a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk37a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
      :: evar_open_pmes m x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x l
  <span class="kr">end</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p (S m) &amp;&amp;
    wfcex_pmes (S m) l
| pme_variable =&gt; wfcex_pmes (S (S m)) l
<span class="kr">end</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk37b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk37b"><span class="nb">destruct</span> a <span class="kr">as</span> [p|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
   :: evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk37c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (pme_variable :: evar_open_pmes (S m) x l) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk37c"><hr></label><div class="goal-conclusion">wfcex_pmes (S (S m)) l = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk37d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk37d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x}
   :: evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk37e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk37e"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m &amp;&amp;
wfcex_pmes m (evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk37f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk37f">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk380" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk380"><span class="nb">specialize</span> (IHl x m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk381" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk381">feed <span class="nb">specialize</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m (evar_open_pmes m x l) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk382" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S m) l = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk382"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk383" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk383">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m (evar_open_pmes m x l) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk384" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk384">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S m) l = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m (evar_open_pmes m x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk385" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk385">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (pme_variable :: evar_open_pmes (S m) x l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S (S m)) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk386" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk386">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (pme_variable :: evar_open_pmes (S m) x l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S (S m)) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk387" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk387"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = true ‚Üí wfcex_pmes (S m) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S m) (evar_open_pmes (S m) x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S (S m)) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk388" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk388"><span class="nb">specialize</span> (IHl x (S m) H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S (S m)) l = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S m) (evar_open_pmes (S m) x l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S (S m)) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk389" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk389"><span class="kn">Lemma</span> <span class="nf">wfc_ex_aux_body_iff&#39;</span> :
  <span class="kr">forall</span> {<span class="nv">Œ£</span> : Signature} (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
	well_formed_closed_ex_aux phi (S n) 
  = well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">Œ£</span> : Signature) (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
  well_formed_closed_ex_aux phi (S n) =
  well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk38a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk38a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">Œ£</span> : Signature) (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
  well_formed_closed_ex_aux phi (S n) =
  well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk38b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk38b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) =
well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk38c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk38c"><span class="nb">remember</span> (well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n) <span class="kr">as</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>b = well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk38d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk38d"><span class="nb">symmetry in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk38e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk38e"><span class="nb">destruct</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk38f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n =
false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk38f"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk390" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk390">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk391" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk391"><span class="nb">apply</span> wfc_ex_aux_body_iff <span class="kr">in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Heqb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk392" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk392">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk393" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk393">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk394" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk394"><span class="nb">rewrite</span> -not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk395" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk395"><span class="nb">rewrite</span> -not_true_iff_false <span class="kr">in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n
‚â† true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi (S n) ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk396" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk396"><span class="nb">intros</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n
‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk397" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk397"><span class="nb">apply</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n
‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk398" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk398"><span class="nb">rewrite</span> wfc_ex_aux_body_iff <span class="kr">in</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n
‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶
  <span class="nl">?Goal</span>} n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi^{<span class="nb">evar</span>:n‚Ü¶x} n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> HContra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk399" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk399"><span class="kn">Lemma</span> <span class="nf">wfcex_pmes_evar_open_pmes_iff</span> {<span class="nv">Œ£</span> : Signature}
  <span class="nv">m</span> <span class="nv">x</span> <span class="nv">l</span>
  :
  wfcex_pmes m (evar_open_pmes m x l)
  = wfcex_pmes (S m) l
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m (evar_open_pmes m x l) =
wfcex_pmes (S m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk39a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk39a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m (evar_open_pmes m x l) =
wfcex_pmes (S m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk39b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk39b"><span class="nb">move</span>: x m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
  wfcex_pmes m (evar_open_pmes m x l) =
  wfcex_pmes (S m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk39c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk39c"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span> x m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk39d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk39d"><hr></label><div class="goal-conclusion">wfcex_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x} :: evar_open_pmes m x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p (S m) &amp;&amp;
    wfcex_pmes (S m) l
| pme_variable =&gt; wfcex_pmes (S (S m)) l
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk39e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk39e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk39f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk39f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x} :: evar_open_pmes m x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p (S m) &amp;&amp;
    wfcex_pmes (S m) l
| pme_variable =&gt; wfcex_pmes (S (S m)) l
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m‚Ü¶x} :: evar_open_pmes m x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p (S m) &amp;&amp;
    wfcex_pmes (S m) l
| pme_variable =&gt; wfcex_pmes (S (S m)) l
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a1"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m &amp;&amp;
wfcex_pmes m (evar_open_pmes m x l) =
well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3a2"><hr></label><div class="goal-conclusion">wfcex_pmes (S m) (evar_open_pmes (S m) x l) =
wfcex_pmes (S (S m)) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m &amp;&amp;
wfcex_pmes m (evar_open_pmes m x l) =
well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a4"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p^{<span class="nb">evar</span>:m‚Ü¶x} m &amp;&amp;
wfcex_pmes (S m) l =
well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a5"><span class="nb">rewrite</span> -wfc_ex_aux_body_iff&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l =
well_formed_closed_ex_aux p (S m) &amp;&amp;
wfcex_pmes (S m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S m) (evar_open_pmes (S m) x l) =
wfcex_pmes (S (S m)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S m) (evar_open_pmes (S m) x l) =
wfcex_pmes (S (S m)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a8"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">m</span> : nat),
wfcex_pmes m (evar_open_pmes m x l) = wfcex_pmes (S m) l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S (S m)) l = wfcex_pmes (S (S m)) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3a9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3a9"><span class="kn">Lemma</span> <span class="nf">evar_open_evar_open_fresh_iter_base</span>
  {<span class="nv">Œ£</span> : Signature} <span class="nv">avoid</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">phi</span> :
  (evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶(evar_fresh_nth avoid m)}
  = evar_open_fresh_iter_base avoid n (S m) phi
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶
evar_fresh_nth avoid m} =
evar_open_fresh_iter_base avoid n (S m) phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3aa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3aa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶
evar_fresh_nth avoid m} =
evar_open_fresh_iter_base avoid n (S m) phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3ab" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3ab"><span class="nb">move</span>: phi n avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : db_index) (<span class="nv">avoid</span> : EVarSet),
  (evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶
  evar_fresh_nth avoid m} =
  evar_open_fresh_iter_base avoid n (S m) phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3ac" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3ac"><span class="nb">induction</span> m; <span class="nb">simpl</span>; <span class="nb">intros</span> phi n avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi^{<span class="nb">evar</span>:n‚Ü¶evar_fresh_s avoid} =
phi^{<span class="nb">evar</span>:n + <span class="mi">0</span>‚Ü¶evar_fresh_s avoid}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3ad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : db_index) 
  (<span class="nv">avoid</span> : EVarSet),
  (evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶
  evar_fresh_nth avoid m} =
  evar_open_fresh_iter_base avoid n (S m) phi</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3ad"><hr></label><div class="goal-conclusion">(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) 
   (S n) m phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶
   evar_fresh_s avoid})^{<span class="nb">evar</span>:n‚Ü¶
evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m} =
evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:n + S m‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:
  n + m‚Ü¶evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3ae" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3ae">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi^{<span class="nb">evar</span>:n‚Ü¶evar_fresh_s avoid} =
phi^{<span class="nb">evar</span>:n + <span class="mi">0</span>‚Ü¶evar_fresh_s avoid}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3af" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3af"><span class="nb">rewrite</span> Nat.add_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi^{<span class="nb">evar</span>:n‚Ü¶evar_fresh_s avoid} =
phi^{<span class="nb">evar</span>:n‚Ü¶evar_fresh_s avoid}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : db_index) (<span class="nv">avoid</span> : EVarSet),
(evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶evar_fresh_nth avoid
                             m} =
evar_open_fresh_iter_base avoid n (S m) phi</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S n) m
   phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶evar_fresh_s avoid})^{<span class="nb">evar</span>:n‚Ü¶
evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m} =
evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:n + S m‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : db_index) (<span class="nv">avoid</span> : EVarSet),
(evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶evar_fresh_nth avoid
                             m} =
evar_open_fresh_iter_base avoid n (S m) phi</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evar_open_fresh_iter_base
   (avoid ‚à™ {[evar_fresh_s avoid]}) (S n) m
   phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶evar_fresh_s avoid})^{<span class="nb">evar</span>:n‚Ü¶
evar_fresh_nth (avoid ‚à™ {[evar_fresh_s avoid]}) m} =
evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:n + S m‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b2"><span class="nb">rewrite</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : db_index) (<span class="nv">avoid</span> : EVarSet),
(evar_open_fresh_iter_base avoid (S n) m phi)^{<span class="nb">evar</span>:n‚Ü¶evar_fresh_nth avoid
                             m} =
evar_open_fresh_iter_base avoid n (S m) phi</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) n (S m)
  phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶evar_fresh_s avoid} =
evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:n + S m‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b3"><span class="nb">clear</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}) n (S m)
  phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶evar_fresh_s avoid} =
evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:n + S m‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})} =
evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:n + S m‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b5"><span class="nb">rewrite</span> Nat.add_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})} =
evar_open_fresh_iter_base
  (avoid ‚à™ {[evar_fresh_s avoid]}
   ‚à™ {[evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})]})
  n m
  phi^{<span class="nb">evar</span>:S (n + m)‚Ü¶evar_fresh_s avoid}^{<span class="nb">evar</span>:n + m‚Ü¶
  evar_fresh_s (avoid ‚à™ {[evar_fresh_s avoid]})}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b6"><span class="kn">Lemma</span> <span class="nf">nested_const_fa&#39;</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">Œì</span> <span class="nv">a</span> <span class="nv">l</span> <span class="nv">avoid</span> (<span class="nv">m</span> : nat) :
  free_evars (a ---&gt; (fold_right connect a l)) ‚äÜ avoid -&gt;
  well_formed a = true -&gt;
  well_formed_xy m <span class="mi">0</span> ((fold_right connect patt_bott l)) = true -&gt;
  Œì ‚ä¢i evar_open_fresh_iter avoid m (a ---&gt; (fold_right connect a l))
  <span class="nb">using</span> AnyReasoning.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (a ---&gt; foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
  ‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
    ‚Üí Œì
      ‚ä¢i evar_open_fresh_iter avoid m
           (a ---&gt; foldr connect a l)
      <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (a ---&gt; foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
  ‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
    ‚Üí Œì
      ‚ä¢i evar_open_fresh_iter avoid m
           (a ---&gt; foldr connect a l)
      <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b8"><span class="nb">move</span>: m avoid a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
  free_evars (a ---&gt; foldr connect a l) ‚äÜ avoid
  ‚Üí well_formed a = true
    ‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
      ‚Üí Œì
        ‚ä¢i evar_open_fresh_iter avoid m
             (a ---&gt; foldr connect a l)
        <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3b9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3b9"><span class="nb">induction</span> l; <span class="nb">simpl</span>; <span class="nb">intros</span> m avoid a&#39; Havoid wfa wfl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i evar_open_fresh_iter avoid m (a&#39; ---&gt; a&#39;)
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3ba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
  free_evars (a ---&gt; foldr connect a l) ‚äÜ avoid
  ‚Üí well_formed a = true
    ‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) =
      true
      ‚Üí Œì
        ‚ä¢i evar_open_fresh_iter avoid m
             (a ---&gt; foldr connect a l)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars (connect a (foldr connect a&#39; l))
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect a (foldr connect ‚ä• l)) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3ba"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter avoid m
     (a&#39; ---&gt; connect a (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3bb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3bb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i evar_open_fresh_iter avoid m (a&#39; ---&gt; a&#39;)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3bc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3bc"><span class="nb">unfold</span> evar_open_fresh_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a&#39; ---&gt; a&#39;)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3bd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3bd"><span class="nb">rewrite</span> evar_open_fresh_iter_impl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3be" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3be">useBasicReasoning.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;
<span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3bf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3bf"><span class="nb">apply</span> A_impl_A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c0"><span class="nb">assert</span> (Hweak : well_formed_xy m <span class="mi">0</span> a&#39; = true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> a&#39; = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> a&#39; = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3c1"><hr></label><div class="goal-conclusion">well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> a&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c3">wf_auto2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive a&#39; = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; <span class="mi">0</span> = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a&#39; <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; m = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c4"><span class="nb">eapply</span> well_formed_closed_ex_aux_ind;[|<span class="nb">apply</span> H2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive a&#39; = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; <span class="mi">0</span> = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a&#39; <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39; ‚à™ free_evars a&#39; ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> a&#39; = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c6"><span class="nb">clear</span> wfa Havoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> a&#39; = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c7"><span class="nb">move</span>: a&#39; Hweak wfl avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
  well_formed_xy m <span class="mi">0</span> a&#39; = true
  ‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
    ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
        well_formed
          (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3c8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3c8"><span class="nb">induction</span> m; <span class="nb">simpl</span>; <span class="nb">intros</span> a Hweak wfl avoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3c9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
  well_formed_xy m <span class="mi">0</span> a&#39; = true
  ‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
    ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
        well_formed
          (evar_open_fresh_iter_base avoid <span class="mi">0</span> m
             a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3c9"><hr></label><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     a^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3ca" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3ca">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy <span class="mi">0</span> <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3cb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3cb">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
well_formed_xy m <span class="mi">0</span> a&#39; = true
‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     a^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3cc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3cc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
well_formed_xy m <span class="mi">0</span> a&#39; = true
‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     a^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3cd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3cd"><span class="nb">apply</span> IHm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
well_formed_xy m <span class="mi">0</span> a&#39; = true
‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> a^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3ce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
  well_formed_xy m <span class="mi">0</span> a&#39; = true
  ‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
    ‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet,
        well_formed
          (evar_open_fresh_iter_base avoid <span class="mi">0</span> m
             a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3ce"><hr></label><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> ‚ä• = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3cf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3cf">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
well_formed_xy m <span class="mi">0</span> a&#39; = true
‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> a^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
well_formed_xy m <span class="mi">0</span> a&#39; = true
‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> ‚ä• = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">a&#39;</span> : Pattern,
well_formed_xy m <span class="mi">0</span> a&#39; = true
‚Üí well_formed_xy m <span class="mi">0</span> ‚ä• = true
‚Üí <span class="kr">‚àÄ</span> <span class="nv">avoid</span> : EVarSet, well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hweak</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> a = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> ‚ä• = true</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> ‚ä• = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars (a ---&gt; foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter avoid m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars (connect a (foldr connect a&#39; l))
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect a (foldr connect ‚ä• l)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter avoid m
     (a&#39; ---&gt; connect a (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d3"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter avoid m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars (connect a (foldr connect a&#39; l))
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect a (foldr connect ‚ä• l)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter avoid m
     (a&#39; ---&gt; connect a (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d4"><span class="nb">unfold</span> evar_open_fresh_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter avoid m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars (connect a (foldr connect a&#39; l))
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect a (foldr connect ‚ä• l)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt; connect a (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d5"><span class="nb">unfold</span> evar_open_fresh_iter <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars (connect a (foldr connect a&#39; l))
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect a (foldr connect ‚ä• l)) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt; connect a (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d6"><span class="nb">destruct</span> a <span class="kr">as</span> [p|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect (pme_pattern p)
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect (pme_pattern p) (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect (pme_pattern p) (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3d7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
  free_evars a ‚à™ free_evars (foldr connect a l)
  ‚äÜ avoid
  ‚Üí well_formed a = true
    ‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) =
      true
      ‚Üí Œì
        ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
             (a ---&gt; foldr connect a l)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect pme_variable
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect pme_variable (foldr connect ‚ä• l)) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3d7"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect pme_variable (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect (pme_pattern p)
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect (pme_pattern p) (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect (pme_pattern p) (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3d9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3d9"><span class="nb">simpl</span> <span class="kr">in</span> Havoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect (pme_pattern p) (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect (pme_pattern p) (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3da" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3da"><span class="nb">specialize</span> (IHl m avoid a&#39; <span class="kp">ltac</span>:(set_solver)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
  ‚Üí Œì
    ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
         (a&#39; ---&gt; foldr connect a&#39; l)
    <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect (pme_pattern p) (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect (pme_pattern p) (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3db" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3db"><span class="nb">specialize</span> (IHl <span class="kp">ltac</span>:(wf_auto2) <span class="kp">ltac</span>:(wf_auto2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt; foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect (pme_pattern p) (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect (pme_pattern p) (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3dc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3dc"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt; foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt; p ---&gt; foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3dd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3dd"><span class="nb">rewrite</span> <span class="mi">2</span>!evar_open_fresh_iter_impl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt; foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3de" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3de"><span class="nb">rewrite</span> evar_open_fresh_iter_impl <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3df" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3df"><span class="nb">assert</span> (H2 : Œì ‚ä¢i ((evar_open_fresh_iter avoid m (foldr connect a&#39; l)) ---&gt; ((evar_open_fresh_iter avoid m p) ---&gt; (evar_open_fresh_iter avoid m (foldr connect a&#39; l)))) <span class="nb">using</span> BasicReasoning).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter avoid m (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m (foldr connect a&#39; l)
<span class="nb">using</span> BasicReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3e0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3e0"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter avoid m (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m (foldr connect a&#39; l)
<span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e2"><span class="nb">simpl</span> <span class="kr">in</span> wfl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter avoid m (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m (foldr connect a&#39; l)
<span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e3"><span class="nb">apply</span> ProofInfo.P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter avoid m (foldr connect a&#39; l))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3e4"><hr></label><div class="goal-conclusion">well_formed (evar_open_fresh_iter avoid m p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e5">wf_auto2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter avoid m p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e6"><span class="nb">apply</span> well_formed_evar_open_fresh_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy m <span class="mi">0</span> p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3e8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3e8"><span class="nb">eapply</span> syllogism_meta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3e9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3e9"><hr></label><div class="goal-conclusion">well_formed <span class="nl">?B</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3ea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3ea"><hr></label><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3eb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3eb"><hr></label><div class="goal-conclusion">Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt; <span class="nl">?B</span>
<span class="nb">using</span> AnyReasoning</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3ec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3ec"><hr></label><div class="goal-conclusion">Œì
‚ä¢i <span class="nl">?B</span> ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3ed" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3ed"><span class="mi">5</span>: useBasicReasoning; <span class="nb">apply</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3ee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3ee"><hr></label><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter avoid m (foldr connect a&#39; l))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3ef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3ef"><hr></label><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3f0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3f0"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter avoid m (foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3f1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3f1"><span class="mi">4</span>: <span class="nb">apply</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3f2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3f2"><hr></label><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter avoid m (foldr connect a&#39; l))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk3f3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars p
   ‚à™ free_evars (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (p ---&gt; foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) ---&gt;
   evar_open_fresh_iter avoid m p ---&gt;
   evar_open_fresh_iter avoid m
     (foldr connect a&#39; l) <span class="nb">using</span> BasicReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk3f3"><hr></label><div class="goal-conclusion">well_formed
  (evar_open_fresh_iter_base avoid <span class="mi">0</span> m p ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (foldr connect a&#39; l))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3f4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3f4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect pme_variable
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect pme_variable (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect pme_variable (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3f5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3f5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect pme_variable
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect pme_variable (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt;
      connect pme_variable (foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3f6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3f6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect pme_variable
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect pme_variable (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (a&#39; ---&gt; (<span class="kp">all</span> , foldr connect a&#39; l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3f7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3f7"><span class="nb">rewrite</span> evar_open_fresh_iter_impl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect pme_variable
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span>
  (connect pme_variable (foldr connect ‚ä• l)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (<span class="kp">all</span> , foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3f8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3f8"><span class="nb">simpl</span> <span class="kr">in</span> wfl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ free_evars
    (connect pme_variable
       (foldr connect a&#39; l)) ‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (<span class="kp">all</span> , foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3f9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3f9"><span class="nb">simpl</span> <span class="kr">in</span> Havoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> : nat) (<span class="nv">avoid</span> : EVarSet) (<span class="nv">a</span> : Pattern),
free_evars a ‚à™ free_evars (foldr connect a l) ‚äÜ avoid
‚Üí well_formed a = true
‚Üí well_formed_xy m <span class="mi">0</span> (foldr connect ‚ä• l) = true
‚Üí Œì ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m (a ---&gt; foldr connect a l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (<span class="kp">all</span> , foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3fa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3fa"><span class="nb">specialize</span> (IHl (S m) avoid a&#39; <span class="kp">ltac</span>:(set_solver) <span class="kp">ltac</span>:(wf_auto2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>well_formed_xy (S m) <span class="mi">0</span> (foldr connect ‚ä• l) =
true
‚Üí Œì
  ‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> 
       (S m) (a&#39; ---&gt; foldr connect a&#39; l)
  <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (<span class="kp">all</span> , foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3fb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3fb"><span class="nb">specialize</span> (IHl <span class="kp">ltac</span>:(wf_auto2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> 
     (S m) (a&#39; ---&gt; foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (<span class="kp">all</span> , foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3fc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3fc"><span class="nb">rewrite</span> evar_open_fresh_iter_impl <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> (S m) a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> 
     (S m) (foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (<span class="kp">all</span> , foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3fd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3fd"><span class="nb">unfold</span> evar_open_fresh_iter <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> (S m) a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> 
     (S m) (foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> m
     (<span class="kp">all</span> , foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3fe" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3fe"><span class="nb">rewrite</span> evar_open_fresh_iter_base_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> (S m) a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> 
     (S m) (foldr connect a&#39; l)
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk3ff" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk3ff"><span class="nb">simpl</span> <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39; l)^{<span class="nb">evar</span>:m‚Ü¶
     evar_fresh_s avoid} <span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk400" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk400"><span class="nb">rewrite</span> evar_open_foldr_connect <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk401" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk401"><span class="nb">remember</span> (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="kr">as</span> avoid&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk402" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk402"><span class="nb">assert</span> (Ha&#39; : <span class="kr">forall</span> <span class="nv">idx</span> <span class="nv">avoid&#39;&#39;</span>, a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk403" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk403"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk404" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk404">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk405" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk405"><span class="nb">intros</span> idx avoid&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid''</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk406" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk406"><span class="nb">eapply</span> evar_open_wfc_aux <span class="kr">with</span> (db1 := <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid''</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ idx</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk407" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid''</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk407"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk408" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk408">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid''</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ‚â§ idx</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk409" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk409">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid''</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk40a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk40a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>avoid''</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk40b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk40b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     a&#39;^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid} ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶
        evar_fresh_s avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk40c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk40c"><span class="nb">rewrite</span> <span class="mi">2</span>!Ha&#39; <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk40d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk40d"><span class="nb">remember</span> (evar_fresh_nth avoid m) <span class="kr">as</span> x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (<span class="kp">all</span> ,
    evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk40e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk40e"><span class="nb">replace</span>
        (<span class="kp">all</span> , evar_open_fresh_iter_base avoid <span class="mi">1</span> m (foldr connect a&#39; l))
      <span class="kr">with</span>
        (forall_quantify x&#39; (evar_open x&#39; <span class="mi">0</span> (evar_open_fresh_iter_base avoid <span class="mi">1</span> m (foldr connect a&#39; l))))
      .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   forall_quantify x&#39;
     (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
        (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;}
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk40f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk40f"><hr></label><div class="goal-conclusion">forall_quantify x&#39;
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;} =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base avoid <span class="mi">1</span> m
   (foldr connect a&#39; l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk410" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk410"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_quantify x&#39;
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;} =
(<span class="kp">all</span> ,
 evar_open_fresh_iter_base avoid <span class="mi">1</span> m
   (foldr connect a&#39; l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk411" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk411"><span class="nb">apply</span> forall_quantify_evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x&#39;
‚àâ free_evars
    (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
       (foldr connect a&#39; l))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk412" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk412"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l)) <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk413" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk413">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x&#39;
‚àâ free_evars
    (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
       (foldr connect a&#39; l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk414" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk414"><span class="nb">subst</span> x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m
‚àâ free_evars
    (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
       (foldr connect a&#39; l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk415" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk415"><span class="nb">apply</span> evar_fresh_nth_notin_free_evars_evar_open_fresh_iter_base.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat,
  evar_fresh_nth avoid m
  ‚àâ free_evars (foldr connect a&#39; l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk416" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk416"><span class="nb">intros</span> m0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m0
‚àâ free_evars (foldr connect a&#39; l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk417" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk417"><span class="nb">pose proof</span> (H0 := evar_fresh_nth_avoid avoid m0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>evar_fresh_nth avoid m0 ‚àâ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m0
‚àâ free_evars (foldr connect a&#39; l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk418" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk418"><span class="nb">clear</span> -H0 Havoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>evar_fresh_nth avoid m0 ‚àâ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m0
‚àâ free_evars (foldr connect a&#39; l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk419" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk419">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l)) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk41a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk41a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l)) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk41b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk41b">wf_auto2_decompose_hyps_parts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar
                 (evar_fresh_s avoid&#39;&#39;)] = a&#39;</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_positive a&#39; = true</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a&#39; <span class="mi">0</span> = true</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; <span class="mi">0</span> = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39;) =
true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39;) <span class="mi">0</span> =
true</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l)))
  <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39;) <span class="mi">0</span> =
true</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l)))
  <span class="mi">0</span> = true</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>well_formed_positive (foldr connect ‚ä• l) = true</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect ‚ä• l) (S m) = true</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (foldr connect ‚ä• l) <span class="mi">0</span> =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l)) <span class="mi">1</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          <span class="c">(* This is a way how to give a name to a hypothesis that should exists somewhere *)</span>
</span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk41c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk41c"><span class="nb">assert</span> (H&#39;&#39; : well_formed_closed_ex_aux
            (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
             (foldr connect a&#39; (evar_open_pmes m (evar_fresh_s avoid) l))) <span class="mi">0</span> =
            true) <span class="bp">by</span> <span class="bp">assumption</span>
          .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^[<span class="nb">evar</span>:idx‚Ü¶patt_free_evar
                 (evar_fresh_s avoid&#39;&#39;)] = a&#39;</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_positive a&#39; = true</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a&#39; <span class="mi">0</span> = true</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; <span class="mi">0</span> = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39;) =
true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39;) <span class="mi">0</span> =
true</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l)))
  <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39;) <span class="mi">0</span> =
true</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l)))
  <span class="mi">0</span> = true</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>well_formed_positive (foldr connect ‚ä• l) = true</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux 
  (foldr connect ‚ä• l) (S m) = true</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (foldr connect ‚ä• l) <span class="mi">0</span> =
true</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l)))
  <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l)) <span class="mi">1</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk41d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk41d"><span class="nb">clear</span> -H&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l)))
  <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
     (foldr connect a&#39; l)) <span class="mi">1</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk41e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk41e"><span class="nb">rewrite</span> wfce_eofib.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l)))
  <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect a&#39; l) (<span class="mi">1</span> + m) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk41f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk41f"><span class="nb">rewrite</span> wfce_eofib <span class="kr">in</span> H&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (foldr connect a&#39;
     (evar_open_pmes m (evar_fresh_s avoid) l))
  (<span class="mi">0</span> + m) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect a&#39; l) (<span class="mi">1</span> + m) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk420" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk420"><span class="nb">simpl</span> <span class="kr">in</span> H&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (foldr connect a&#39;
     (evar_open_pmes m (evar_fresh_s avoid) l))
  m = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect a&#39; l) (<span class="mi">1</span> + m) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk421" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk421"><span class="nb">rewrite</span> wfc_ex_aux_foldr_connect&#39; <span class="kr">in</span> H&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39;
  (m +
   foralls_count
     (evar_open_pmes m (evar_fresh_s avoid) l)) &amp;&amp;
wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect a&#39; l) (<span class="mi">1</span> + m) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk422" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk422"><span class="nb">rewrite</span> wfc_ex_aux_foldr_connect&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39;
  (m +
   foralls_count
     (evar_open_pmes m (evar_fresh_s avoid) l)) &amp;&amp;
wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; (<span class="mi">1</span> + m + foralls_count l) &amp;&amp;
wfcex_pmes (<span class="mi">1</span> + m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk423" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk423"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39;
  (m +
   foralls_count
     (evar_open_pmes m (evar_fresh_s avoid) l)) &amp;&amp;
wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; (S (m + foralls_count l)) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk424" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk424"><span class="nb">rewrite</span> foralls_count_evar_open_pmes <span class="kr">in</span> H&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39;
  (m + foralls_count l) &amp;&amp;
wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; (S (m + foralls_count l)) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk425" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk425">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; (m + foralls_count l) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; (S (m + foralls_count l)) &amp;&amp;
wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk426" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk426">split_and.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; (m + foralls_count l) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; (S (m + foralls_count l)) =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk427" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; (m + foralls_count l) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk427"><hr></label><div class="goal-conclusion">wfcex_pmes (S m) l = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk428" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk428">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; (m + foralls_count l) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; (S (m + foralls_count l)) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk429" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk429">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; (m + foralls_count l) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk42a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk42a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a&#39; (m + foralls_count l) =
true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk42b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk42b"><span class="nb">clear</span> -H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes m
  (evar_open_pmes m (evar_fresh_s avoid) l) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk42c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk42c"><span class="nb">apply</span> wfcex_pmes_evar_open_pmes <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S m) l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S m) l = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk42d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk42d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   forall_quantify x&#39;
     (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
        (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk42e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk42e"><span class="nb">apply</span> forall_gen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x&#39;
  (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk42f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk42f"><hr></label><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x&#39;]}, SVSubst := ‚àÖ, KT := false)
  AnyReasoning</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk430" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk430"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk431" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk431">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x&#39;
  (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk432" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk432"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x&#39;
  (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk433" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk433"><span class="nb">subst</span> x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in (evar_fresh_nth avoid m)
  (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk434" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk434"><span class="nb">unfold</span> evar_is_fresh_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m
‚àâ free_evars (evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk435" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk435"><span class="nb">apply</span> evar_fresh_nth_notin_free_evars_evar_open_fresh_iter_base.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">m</span> : nat, evar_fresh_nth avoid m ‚àâ free_evars a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk436" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk436"><span class="nb">intros</span> m0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m0 ‚àâ free_evars a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk437" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk437"><span class="nb">pose proof</span> (H := evar_fresh_nth_avoid avoid m0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>evar_fresh_nth avoid m0 ‚àâ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m0 ‚àâ free_evars a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk438" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk438"><span class="nb">clear</span> -H Havoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>m0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>evar_fresh_nth avoid m0 ‚àâ avoid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_nth avoid m0 ‚àâ free_evars a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk439" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk439">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x&#39;]}, SVSubst := ‚àÖ, KT := false)
  AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk43a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk43a"><hr></label><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk43b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk43b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x&#39;]}, SVSubst := ‚àÖ, KT := false)
  AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pile_any.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk43c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk43c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx'</var><span class="hyp-type"><b>: </b><span>x&#39; = evar_fresh_nth avoid m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x&#39;}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk43d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk43d"><span class="nb">subst</span> x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   (evar_open_fresh_iter_base avoid <span class="mi">1</span> m
      (foldr connect a&#39; l))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶evar_fresh_nth
                                      avoid m}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk43e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk43e"><span class="nb">rewrite</span> evar_open_evar_open_fresh_iter_base.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid <span class="mi">0</span> (S m)
     (foldr connect a&#39; l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk43f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk43f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>avoid'</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>Heqavoid'</var><span class="hyp-type"><b>: </b><span>avoid&#39; = avoid ‚à™ {[evar_fresh_s avoid]}</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base avoid&#39; <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39; l)^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk440" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk440"><span class="nb">subst</span> avoid&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39; l)^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk441" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk441"><span class="nb">rewrite</span> [evar_open_fresh_iter_base avoid <span class="mi">0</span> m a&#39;]evar_open_fresh_iter_base_wfc_aux.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk442" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk442"><hr></label><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39; l)^{<span class="nb">evar</span>:m‚Ü¶
     evar_fresh_s avoid} <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk443" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk443">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk444" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk444">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39; l)^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk445" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk445"><span class="nb">rewrite</span> [evar_open_fresh_iter_base _ <span class="mi">0</span> m a&#39;]evar_open_fresh_iter_base_wfc_aux <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk446" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk446"><hr></label><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39; l)^{<span class="nb">evar</span>:m‚Ü¶
     evar_fresh_s avoid} <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk447" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk447">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk448" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk448">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39; l)^{<span class="nb">evar</span>:m‚Ü¶evar_fresh_s avoid}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk449" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk449"><span class="nb">rewrite</span> evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶evar_fresh_s
                                       avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk44a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk44a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect
        a&#39;^{<span class="nb">evar</span>:m + foralls_count l‚Ü¶evar_fresh_s
                                       avoid}
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk44b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk44b"><span class="nb">rewrite</span> [evar_open _ _ a&#39;]evar_open_wfc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk44c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk44c"><hr></label><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk44d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk44d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk44e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk44e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>avoid</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Havoid</var><span class="hyp-type"><b>: </b><span>free_evars a&#39;
‚à™ (free_evars (foldr connect a&#39; l) ‚à™ ‚àÖ ‚à™ ‚àÖ)
‚äÜ avoid</span></span></span><br><span><var>wfa</var><span class="hyp-type"><b>: </b><span>well_formed a&#39; = true</span></span></span><br><span><var>wfl</var><span class="hyp-type"><b>: </b><span>well_formed_xy m <span class="mi">0</span> (<span class="kp">all</span> , foldr connect ‚ä• l) =
true</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : db_index) (<span class="nv">avoid&#39;&#39;</span> : EVarSet),
  a&#39;^{<span class="nb">evar</span>:idx‚Ü¶evar_fresh_s avoid&#39;&#39;} = a&#39;</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i a&#39; ---&gt;
   evar_open_fresh_iter_base
     (avoid ‚à™ {[evar_fresh_s avoid]}) <span class="mi">0</span> m
     (foldr connect a&#39;
        (evar_open_pmes m (evar_fresh_s avoid) l))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk44f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk44f"><span class="kn">Lemma</span> <span class="nf">nested_const_fa</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">Œì</span> <span class="nv">a</span> <span class="nv">l</span> :
  well_formed a = true -&gt;
  well_formed ((fold_right connect patt_bott l)) = true -&gt;
  Œì ‚ä¢i (a ---&gt; (fold_right connect a l))
  <span class="nb">using</span> AnyReasoning.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a = true
‚Üí well_formed (foldr connect ‚ä• l) = true
  ‚Üí Œì ‚ä¢i a ---&gt; foldr connect a l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk450" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk450"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a = true
‚Üí well_formed (foldr connect ‚ä• l) = true
  ‚Üí Œì ‚ä¢i a ---&gt; foldr connect a l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk451" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk451"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i a ---&gt; foldr connect a l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk452" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk452"><span class="nb">apply</span> (nested_const_fa&#39; Œì a l (free_evars (a ---&gt; foldr connect a l)) <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (a ---&gt; foldr connect a l)
‚äÜ free_evars (a ---&gt; foldr connect a l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk453" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk453"><hr></label><div class="goal-conclusion">well_formed a = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk454" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk454"><hr></label><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span> (foldr connect ‚ä• l) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk455" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk455">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars (a ---&gt; foldr connect a l)
‚äÜ free_evars (a ---&gt; foldr connect a l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk456" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk456">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk457" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk457"><hr></label><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span> (foldr connect ‚ä• l) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk458" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk458">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk459" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk459">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span> (foldr connect ‚ä• l) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk45a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk45a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed a = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect ‚ä• l) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_xy <span class="mi">0</span> <span class="mi">0</span> (foldr connect ‚ä• l) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">wfcmu_pmes</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">idx</span> : nat) (<span class="nv">pmes</span> : list ProofModeEntry)
  : bool
  :=
  <span class="kr">match</span> pmes <span class="kr">with</span>
  | [] =&gt; true
  | (pme_pattern p)::pmes&#39;
    =&gt; well_formed_closed_mu_aux p idx
       &amp;&amp; wfcmu_pmes idx pmes&#39;
  | (pme_variable)::pmes&#39;
    =&gt; wfcmu_pmes idx pmes&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">wfp_pmes</span> {<span class="nv">Œ£</span> : Signature}
  (<span class="nv">pmes</span> : list ProofModeEntry)
  : bool
  :=
  <span class="kr">match</span> pmes <span class="kr">with</span>
  | [] =&gt; true
  | (pme_pattern p)::pmes&#39;
    =&gt; well_formed_positive p
       &amp;&amp; wfp_pmes pmes&#39;
  | (pme_variable)::pmes&#39;
    =&gt; wfp_pmes pmes&#39;
  <span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk45b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk45b"><span class="kn">Lemma</span> <span class="nf">wfc_mu_aux_foldr_connect</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">g</span> <span class="nv">pmes</span> <span class="nv">k</span> :
  well_formed_closed_mu_aux (foldr connect g pmes) k 
  = well_formed_closed_mu_aux g k
  &amp;&amp; wfcmu_pmes k pmes
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux (foldr connect g pmes) k =
well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk45c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk45c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux (foldr connect g pmes) k =
well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk45d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk45d"><span class="nb">move</span>: g k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk45e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk45e"><span class="nb">induction</span> pmes; <span class="nb">cbn</span>; <span class="nb">intros</span> g k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux g k =
well_formed_closed_mu_aux g k &amp;&amp; true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk45f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk45f"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux
  (connect a (foldr connect g pmes)) k =
well_formed_closed_mu_aux g k &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p k &amp;&amp; wfcmu_pmes k pmes
| pme_variable =&gt; wfcmu_pmes k pmes
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk460" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk460">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux g k =
well_formed_closed_mu_aux g k &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk461" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk461"><span class="nb">rewrite</span> andb_true_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux g k =
well_formed_closed_mu_aux g k</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk462" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk462">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux
  (connect a (foldr connect g pmes)) k =
well_formed_closed_mu_aux g k &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p k &amp;&amp; wfcmu_pmes k pmes
| pme_variable =&gt; wfcmu_pmes k pmes
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk463" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk463">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux
  (connect a (foldr connect g pmes)) k =
well_formed_closed_mu_aux g k &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p k &amp;&amp; wfcmu_pmes k pmes
| pme_variable =&gt; wfcmu_pmes k pmes
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk464" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk464"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p k &amp;&amp;
well_formed_closed_mu_aux (foldr connect g pmes) k =
[&amp;&amp; well_formed_closed_mu_aux g k,
    well_formed_closed_mu_aux p k
  &amp; wfcmu_pmes k pmes]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk465" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk465"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux (foldr connect g pmes) k &amp;&amp;
true &amp;&amp; true =
well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk466" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk466">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p k &amp;&amp;
well_formed_closed_mu_aux (foldr connect g pmes) k =
[&amp;&amp; well_formed_closed_mu_aux g k,
    well_formed_closed_mu_aux p k
  &amp; wfcmu_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk467" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk467"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_mu_aux p k,
    well_formed_closed_mu_aux g k
  &amp; wfcmu_pmes k pmes] =
[&amp;&amp; well_formed_closed_mu_aux g k,
    well_formed_closed_mu_aux p k
  &amp; wfcmu_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk468" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk468"><span class="nb">clear</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_mu_aux p k,
    well_formed_closed_mu_aux g k
  &amp; wfcmu_pmes k pmes] =
[&amp;&amp; well_formed_closed_mu_aux g k,
    well_formed_closed_mu_aux p k
  &amp; wfcmu_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk469" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk469"><span class="nb">remember</span> (well_formed_closed_mu_aux g (k + length (filter is_variable pmes))) <span class="kr">as</span> B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>HeqB</var><span class="hyp-type"><b>: </b><span>B =
well_formed_closed_mu_aux g
  (k + length (filter is_variable pmes))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_mu_aux p k,
    well_formed_closed_mu_aux g k
  &amp; wfcmu_pmes k pmes] =
[&amp;&amp; well_formed_closed_mu_aux g k,
    well_formed_closed_mu_aux p k
  &amp; wfcmu_pmes k pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">btauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk46a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk46a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux (foldr connect g pmes) k &amp;&amp;
true &amp;&amp; true =
well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk46b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk46b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux (foldr connect g pmes) k &amp;&amp;
true &amp;&amp; true =
well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk46c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk46c"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">g</span> : Pattern) (<span class="nv">k</span> : db_index),
  well_formed_closed_mu_aux
    (foldr connect g pmes) k =
  well_formed_closed_mu_aux g k &amp;&amp;
  wfcmu_pmes k pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes &amp;&amp;
true &amp;&amp; true =
well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk46d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk46d"><span class="nb">clear</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes &amp;&amp;
true &amp;&amp; true =
well_formed_closed_mu_aux g k &amp;&amp; wfcmu_pmes k pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">btauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk46e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk46e"><span class="kn">Lemma</span> <span class="nf">wfp_foldr_connect</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">g</span> <span class="nv">pmes</span> :
  well_formed_positive (foldr connect g pmes) 
  = well_formed_positive g
  &amp;&amp; wfp_pmes pmes
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive (foldr connect g pmes) =
well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk46f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk46f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive (foldr connect g pmes) =
well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk470" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk470"><span class="nb">move</span>: g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk471" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk471"><span class="nb">induction</span> pmes; <span class="nb">cbn</span>; <span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive g =
well_formed_positive g &amp;&amp; true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk472" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk472"><hr></label><div class="goal-conclusion">well_formed_positive
  (connect a (foldr connect g pmes)) =
well_formed_positive g &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes pmes
| pme_variable =&gt; wfp_pmes pmes
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk473" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk473">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive g =
well_formed_positive g &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk474" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk474"><span class="nb">rewrite</span> andb_true_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive g = well_formed_positive g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk475" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk475">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (connect a (foldr connect g pmes)) =
well_formed_positive g &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes pmes
| pme_variable =&gt; wfp_pmes pmes
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk476" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk476">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (connect a (foldr connect g pmes)) =
well_formed_positive g &amp;&amp;
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes pmes
| pme_variable =&gt; wfp_pmes pmes
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk477" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk477"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p &amp;&amp;
well_formed_positive (foldr connect g pmes) =
[&amp;&amp; well_formed_positive g, well_formed_positive p
  &amp; wfp_pmes pmes]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk478" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk478"><hr></label><div class="goal-conclusion">well_formed_positive (foldr connect g pmes) &amp;&amp; true &amp;&amp;
true = well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk479" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk479">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p &amp;&amp;
well_formed_positive (foldr connect g pmes) =
[&amp;&amp; well_formed_positive g, well_formed_positive p
  &amp; wfp_pmes pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk47a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk47a"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive p, well_formed_positive g
  &amp; wfp_pmes pmes] =
[&amp;&amp; well_formed_positive g, well_formed_positive p
  &amp; wfp_pmes pmes]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk47b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk47b"><span class="nb">clear</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive p, well_formed_positive g
  &amp; wfp_pmes pmes] =
[&amp;&amp; well_formed_positive g, well_formed_positive p
  &amp; wfp_pmes pmes]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">btauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk47c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk47c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive (foldr connect g pmes) &amp;&amp; true &amp;&amp;
true = well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk47d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk47d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive (foldr connect g pmes) &amp;&amp; true &amp;&amp;
true = well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk47e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk47e"><span class="nb">rewrite</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHpmes</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">g</span> : Pattern,
  well_formed_positive (foldr connect g pmes) =
  well_formed_positive g &amp;&amp; wfp_pmes pmes</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive g &amp;&amp; wfp_pmes pmes &amp;&amp; true &amp;&amp;
true = well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk47f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk47f"><span class="nb">clear</span> IHpmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pmes</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive g &amp;&amp; wfp_pmes pmes &amp;&amp; true &amp;&amp;
true = well_formed_positive g &amp;&amp; wfp_pmes pmes</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">btauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk480" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk480"><span class="kn">Lemma</span> <span class="nf">evar_open_pmes_app</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">idx</span> <span class="nv">x</span> <span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span>:
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ)
  = (evar_open_pmes idx x l‚ÇÅ)
  ++ (evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
evar_open_pmes idx x l‚ÇÅ ++
evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk481" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk481"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
evar_open_pmes idx x l‚ÇÅ ++
evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk482" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk482"><span class="nb">move</span>: idx l‚ÇÇ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk483" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk483"><span class="nb">induction</span> l‚ÇÅ; <span class="nb">cbn</span>; <span class="nb">intros</span> idx l‚ÇÇ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes idx x l‚ÇÇ =
evar_open_pmes (idx + <span class="mi">0</span>) x l‚ÇÇ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk484" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk484"><hr></label><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
    :: evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ)
| pme_variable =&gt;
    pme_variable
    :: evar_open_pmes (S idx) x (l‚ÇÅ ++ l‚ÇÇ)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
    :: evar_open_pmes idx x l‚ÇÅ
| pme_variable =&gt;
    pme_variable :: evar_open_pmes (S idx) x l‚ÇÅ
<span class="kr">end</span> ++
evar_open_pmes
  (idx +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk485" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk485">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes idx x l‚ÇÇ =
evar_open_pmes (idx + <span class="mi">0</span>) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk486" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk486"><span class="nb">rewrite</span> Nat.add_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_open_pmes idx x l‚ÇÇ = evar_open_pmes idx x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk487" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk487">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
    :: evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ)
| pme_variable =&gt;
    pme_variable
    :: evar_open_pmes (S idx) x (l‚ÇÅ ++ l‚ÇÇ)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
    :: evar_open_pmes idx x l‚ÇÅ
| pme_variable =&gt;
    pme_variable :: evar_open_pmes (S idx) x l‚ÇÅ
<span class="kr">end</span> ++
evar_open_pmes
  (idx +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk488" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk488">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
    :: evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ)
| pme_variable =&gt;
    pme_variable
    :: evar_open_pmes (S idx) x (l‚ÇÅ ++ l‚ÇÇ)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
    :: evar_open_pmes idx x l‚ÇÅ
| pme_variable =&gt;
    pme_variable :: evar_open_pmes (S idx) x l‚ÇÅ
<span class="kr">end</span> ++
evar_open_pmes
  (idx +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk489" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk489"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes
     (idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk48a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk48a"><hr></label><div class="goal-conclusion">pme_variable :: evar_open_pmes (S idx) x (l‚ÇÅ ++ l‚ÇÇ) =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (idx + S (length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk48b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk48b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes
     (idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk48c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk48c"><span class="nb">rewrite</span> IHl‚ÇÅ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ =
pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes
     (idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk48d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk48d"><span class="nb">clear</span> IHl‚ÇÅ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ =
pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes
     (idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk48e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk48e"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes
     (idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ =
pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
:: evar_open_pmes idx x l‚ÇÅ ++
   evar_open_pmes
     (idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk48f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk48f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable :: evar_open_pmes (S idx) x (l‚ÇÅ ++ l‚ÇÇ) =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (idx + S (length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk490" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk490">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable :: evar_open_pmes (S idx) x (l‚ÇÅ ++ l‚ÇÇ) =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (idx + S (length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk491" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk491"><span class="nb">rewrite</span> IHl‚ÇÅ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl‚ÇÅ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  evar_open_pmes idx x (l‚ÇÅ ++ l‚ÇÇ) =
  evar_open_pmes idx x l‚ÇÅ ++
  evar_open_pmes (idx + foralls_count l‚ÇÅ) x l‚ÇÇ</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes (S idx + foralls_count l‚ÇÅ) x l‚ÇÇ =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (idx + S (length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk492" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk492"><span class="nb">clear</span> IHl‚ÇÅ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes (S idx + foralls_count l‚ÇÅ) x l‚ÇÇ =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (idx + S (length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk493" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk493"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (S idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (idx + S (length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk494" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk494"><span class="nb">rewrite</span> Nat.add_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (S idx + length (filter is_variable l‚ÇÅ)) x l‚ÇÇ =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (S (idx + length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk495" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk495"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (S (idx + length (filter is_variable l‚ÇÅ))) x l‚ÇÇ =
pme_variable
:: evar_open_pmes (S idx) x l‚ÇÅ ++
   evar_open_pmes
     (S (idx + length (filter is_variable l‚ÇÅ))) x l‚ÇÇ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk496" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk496"><span class="kn">Lemma</span> <span class="nf">wfp_pmes_app</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">l1</span> <span class="nv">l2</span>:
  wfp_pmes (l1 ++ l2) = wfp_pmes l1 &amp;&amp; wfp_pmes l2
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (l1 ++ l2) = wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk497" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk497"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (l1 ++ l2) = wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk498" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk498"><span class="nb">induction</span> l1; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes l2 = wfp_pmes l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk499" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk499"><hr></label><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes (l1 ++ l2)
| pme_variable =&gt; wfp_pmes (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes l1
| pme_variable =&gt; wfp_pmes l1
<span class="kr">end</span> &amp;&amp; wfp_pmes l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk49a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk49a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes l2 = wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk49b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk49b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes (l1 ++ l2)
| pme_variable =&gt; wfp_pmes (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes l1
| pme_variable =&gt; wfp_pmes l1
<span class="kr">end</span> &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk49c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk49c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes (l1 ++ l2)
| pme_variable =&gt; wfp_pmes (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes l1
| pme_variable =&gt; wfp_pmes l1
<span class="kr">end</span> &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk49d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk49d"><span class="nb">destruct</span> a <span class="kr">as</span> [p|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p &amp;&amp; wfp_pmes (l1 ++ l2) =
well_formed_positive p &amp;&amp; wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk49e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk49e"><hr></label><div class="goal-conclusion">wfp_pmes (l1 ++ l2) = wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk49f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk49f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p &amp;&amp; wfp_pmes (l1 ++ l2) =
well_formed_positive p &amp;&amp; wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a0"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive p, wfp_pmes l1 &amp; wfp_pmes l2] =
well_formed_positive p &amp;&amp; wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a1"><span class="nb">rewrite</span> andb_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p &amp;&amp; wfp_pmes l1 &amp;&amp; wfp_pmes l2 =
well_formed_positive p &amp;&amp; wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a2">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (l1 ++ l2) = wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfp_pmes (l1 ++ l2) =
wfp_pmes l1 &amp;&amp; wfp_pmes l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (l1 ++ l2) = wfp_pmes l1 &amp;&amp; wfp_pmes l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHl1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a4"><span class="kn">Lemma</span> <span class="nf">wfp_pmes_evar_open</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">l</span> <span class="nv">idx</span> <span class="nv">x</span>:
  wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a6"><span class="nb">move</span>: idx x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
  wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a7"><span class="nb">induction</span> l; <span class="nb">simpl</span>; <span class="nb">intros</span> idx x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4a8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4a8"><hr></label><div class="goal-conclusion">wfp_pmes
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes l
| pme_variable =&gt; wfp_pmes l
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4a9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4a9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4aa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4aa">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes l
| pme_variable =&gt; wfp_pmes l
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ab" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ab">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:idx‚Ü¶x}
      :: evar_open_pmes idx x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S idx) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_positive p &amp;&amp; wfp_pmes l
| pme_variable =&gt; wfp_pmes l
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ac" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ac"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} &amp;&amp;
wfp_pmes (evar_open_pmes idx x l) =
well_formed_positive p &amp;&amp; wfp_pmes l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4ad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4ad"><hr></label><div class="goal-conclusion">wfp_pmes (evar_open_pmes (S idx) x l) = wfp_pmes l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ae" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ae">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} &amp;&amp;
wfp_pmes (evar_open_pmes idx x l) =
well_formed_positive p &amp;&amp; wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4af" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4af"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} &amp;&amp; wfp_pmes l =
well_formed_positive p &amp;&amp; wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b0"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} =
well_formed_positive p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b1"><span class="nb">remember</span> (well_formed_positive p) <span class="kr">as</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>b = well_formed_positive p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b2"><span class="nb">symmetry in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b3"><span class="nb">destruct</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4b4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
  wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4b4"><hr></label><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b6"><span class="nb">apply</span> wfp_evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Heqb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4b9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4b9"><span class="nb">rewrite</span> -not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ba" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ba"><span class="nb">rewrite</span> -not_true_iff_false <span class="kr">in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p ‚â† true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4bb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4bb"><span class="nb">intros</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4bc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4bc"><span class="nb">apply</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_positive p^{<span class="nb">evar</span>:idx‚Ü¶x} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4bd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4bd"><span class="nb">apply</span> evar_open_positive <span class="kr">in</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_positive p ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_positive p = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive p = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> HContra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4be" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4be">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (evar_open_pmes (S idx) x l) = wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4bf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4bf">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes (evar_open_pmes (S idx) x l) = wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c0"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">idx</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>), wfp_pmes (evar_open_pmes idx x l) = wfp_pmes l</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfp_pmes l = wfp_pmes l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c1"><span class="kn">Lemma</span> <span class="nf">wfcmu_pmes_app</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">idx</span> <span class="nv">l1</span> <span class="nv">l2</span>:
  wfcmu_pmes idx (l1 ++ l2) = wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c3"><span class="nb">induction</span> l1; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes idx l2 = wfcmu_pmes idx l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4c4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4c4"><hr></label><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p idx &amp;&amp;
    wfcmu_pmes idx (l1 ++ l2)
| pme_variable =&gt; wfcmu_pmes idx (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p idx &amp;&amp;
    wfcmu_pmes idx l1
| pme_variable =&gt; wfcmu_pmes idx l1
<span class="kr">end</span> &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes idx l2 = wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p idx &amp;&amp;
    wfcmu_pmes idx (l1 ++ l2)
| pme_variable =&gt; wfcmu_pmes idx (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p idx &amp;&amp;
    wfcmu_pmes idx l1
| pme_variable =&gt; wfcmu_pmes idx l1
<span class="kr">end</span> &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p idx &amp;&amp;
    wfcmu_pmes idx (l1 ++ l2)
| pme_variable =&gt; wfcmu_pmes idx (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p idx &amp;&amp;
    wfcmu_pmes idx l1
| pme_variable =&gt; wfcmu_pmes idx l1
<span class="kr">end</span> &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4c8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4c8"><span class="nb">destruct</span> a <span class="kr">as</span> [p|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p idx &amp;&amp;
wfcmu_pmes idx (l1 ++ l2) =
well_formed_closed_mu_aux p idx &amp;&amp; wfcmu_pmes idx l1 &amp;&amp;
wfcmu_pmes idx l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4c9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4c9"><hr></label><div class="goal-conclusion">wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ca" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ca">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p idx &amp;&amp;
wfcmu_pmes idx (l1 ++ l2) =
well_formed_closed_mu_aux p idx &amp;&amp; wfcmu_pmes idx l1 &amp;&amp;
wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4cb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4cb"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_mu_aux p idx, wfcmu_pmes idx l1
  &amp; wfcmu_pmes idx l2] =
well_formed_closed_mu_aux p idx &amp;&amp; wfcmu_pmes idx l1 &amp;&amp;
wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4cc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4cc"><span class="nb">rewrite</span> andb_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p idx &amp;&amp; wfcmu_pmes idx l1 &amp;&amp;
wfcmu_pmes idx l2 =
well_formed_closed_mu_aux p idx &amp;&amp; wfcmu_pmes idx l1 &amp;&amp;
wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4cd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4cd">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ce" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ce">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>idx</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes idx (l1 ++ l2) =
wfcmu_pmes idx l1 &amp;&amp; wfcmu_pmes idx l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHl1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4cf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4cf"><span class="kn">Lemma</span> <span class="nf">foralls_count_app</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">l1</span> <span class="nv">l2</span>:
  foralls_count (l1 ++ l2) = foralls_count l1 + foralls_count l2
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (l1 ++ l2) =
foralls_count l1 + foralls_count l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (l1 ++ l2) =
foralls_count l1 + foralls_count l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d1"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter is_variable (l1 ++ l2)) =
length (filter is_variable l1) +
length (filter is_variable l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d2"><span class="nb">rewrite</span> filter_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (filter is_variable l1 ++ filter is_variable l2) =
length (filter is_variable l1) +
length (filter is_variable l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d3"><span class="nb">rewrite</span> app_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter is_variable l1) +
length (filter is_variable l2) =
length (filter is_variable l1) +
length (filter is_variable l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d4"><span class="kn">Lemma</span> <span class="nf">foralls_count_cons_pattern</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">l</span> <span class="nv">p</span>:
  foralls_count ((pme_pattern p)::l) = (foralls_count l)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (pme_pattern p :: l) = foralls_count l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (pme_pattern p :: l) = foralls_count l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (<span class="kr">if</span> decide (is_variable (pme_pattern p))
   <span class="kr">then</span> pme_pattern p :: filter is_variable l
   <span class="kr">else</span> filter is_variable l) = foralls_count l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d7"><span class="nb">unfold</span> decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter is_variable l) = foralls_count l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d8"><span class="kn">Lemma</span> <span class="nf">foralls_count_cons_variable</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">l</span>:
  foralls_count ((pme_variable)::l) = S (foralls_count l)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (pme_variable :: l) =
S (foralls_count l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4d9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4d9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foralls_count (pme_variable :: l) =
S (foralls_count l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4da" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4da"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (<span class="kr">if</span> decide (is_variable pme_variable)
   <span class="kr">then</span> pme_variable :: filter is_variable l
   <span class="kr">else</span> filter is_variable l) = S (foralls_count l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4db" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4db"><span class="nb">unfold</span> decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (pme_variable :: filter is_variable l) =
S (foralls_count l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4dc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4dc"><span class="kn">Lemma</span> <span class="nf">wfcex_pmes_app</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">k</span> <span class="nv">l1</span> <span class="nv">l2</span>:
  wfcex_pmes k (l1 ++ l2)
  = wfcex_pmes k l1 &amp;&amp; wfcex_pmes (k + foralls_count l1) l2
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes k (l1 ++ l2) =
wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + foralls_count l1) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4dd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4dd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes k (l1 ++ l2) =
wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + foralls_count l1) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4de" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4de"><span class="nb">move</span>: k l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4df" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4df"><span class="nb">induction</span> l1; <span class="nb">cbn</span>; <span class="nb">intros</span> k l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes k l2 = wfcex_pmes (k + <span class="mi">0</span>) l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4e0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4e0"><hr></label><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp;
    wfcex_pmes k (l1 ++ l2)
| pme_variable =&gt; wfcex_pmes (S k) (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1
| pme_variable =&gt; wfcex_pmes (S k) l1
<span class="kr">end</span> &amp;&amp;
wfcex_pmes
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable l1
      <span class="kr">else</span> filter is_variable l1)) l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes k l2 = wfcex_pmes (k + <span class="mi">0</span>) l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e2"><span class="nb">rewrite</span> Nat.add_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes k l2 = wfcex_pmes k l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp;
    wfcex_pmes k (l1 ++ l2)
| pme_variable =&gt; wfcex_pmes (S k) (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1
| pme_variable =&gt; wfcex_pmes (S k) l1
<span class="kr">end</span> &amp;&amp;
wfcex_pmes
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable l1
      <span class="kr">else</span> filter is_variable l1)) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp;
    wfcex_pmes k (l1 ++ l2)
| pme_variable =&gt; wfcex_pmes (S k) (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1
| pme_variable =&gt; wfcex_pmes (S k) l1
<span class="kr">end</span> &amp;&amp;
wfcex_pmes
  (k +
   length
     (<span class="kr">if</span> decide (is_variable a)
      <span class="kr">then</span> a :: filter is_variable l1
      <span class="kr">else</span> filter is_variable l1)) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e5"><span class="nb">destruct</span> a <span class="kr">as</span> [p|];<span class="nb">cbn</span>; <span class="nb">unfold</span> decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p k &amp;&amp;
wfcex_pmes k (l1 ++ l2) =
well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + length (filter is_variable l1)) l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4e6"><hr></label><div class="goal-conclusion">wfcex_pmes (S k) (l1 ++ l2) =
wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes
  (k + length (pme_variable :: filter is_variable l1))
  l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p k &amp;&amp;
wfcex_pmes k (l1 ++ l2) =
well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + length (filter is_variable l1)) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e8"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_ex_aux p k, wfcex_pmes k l1
  &amp; wfcex_pmes (k + foralls_count l1) l2] =
well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + length (filter is_variable l1)) l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4e9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4e9"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_closed_ex_aux p k, wfcex_pmes k l1
  &amp; wfcex_pmes (k + length (filter is_variable l1)) l2] =
well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + length (filter is_variable l1)) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ea" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ea"><span class="nb">rewrite</span> !andb_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + length (filter is_variable l1)) l2 =
well_formed_closed_ex_aux p k &amp;&amp; wfcex_pmes k l1 &amp;&amp;
wfcex_pmes (k + length (filter is_variable l1)) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4eb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4eb">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S k) (l1 ++ l2) =
wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes
  (k + length (pme_variable :: filter is_variable l1))
  l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ec" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ec">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S k) (l1 ++ l2) =
wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes
  (k + length (pme_variable :: filter is_variable l1))
  l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ed" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ed"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes (S k + foralls_count l1) l2 =
wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes
  (k + length (pme_variable :: filter is_variable l1))
  l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ee" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ee"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes (S k + length (filter is_variable l1)) l2 =
wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes
  (k + length (pme_variable :: filter is_variable l1))
  l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ef" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ef"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes (S (k + length (filter is_variable l1))) l2 =
wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes (k + S (length (filter is_variable l1))) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f0"><span class="nb">rewrite</span> Nat.add_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">k</span> : nat) (<span class="nv">l2</span> : list ProofModeEntry),
  wfcex_pmes k (l1 ++ l2) =
  wfcex_pmes k l1 &amp;&amp;
  wfcex_pmes (k + foralls_count l1) l2</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes (S (k + length (filter is_variable l1))) l2 =
wfcex_pmes (S k) l1 &amp;&amp;
wfcex_pmes (S (k + length (filter is_variable l1))) l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f1"><span class="kn">Lemma</span> <span class="nf">wfc_mu_aux_body_iff&#39;</span> {<span class="nv">Œ£</span> : Signature}:
	 <span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : svar),
     well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n      
     = well_formed_closed_mu_aux phi (S n)
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n =
  well_formed_closed_mu_aux phi (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> : nat) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n =
  well_formed_closed_mu_aux phi (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n =
well_formed_closed_mu_aux phi (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f4"><span class="nb">remember</span> (well_formed_closed_mu_aux phi (S n)) <span class="kr">as</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>b = well_formed_closed_mu_aux phi (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f5"><span class="nb">symmetry in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f6"><span class="nb">destruct</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk4f7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk4f7"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4f9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4f9"><span class="nb">apply</span> wfc_mu_aux_body_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi (S n) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Heqb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4fa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4fa">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4fb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4fb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4fc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4fc"><span class="nb">rewrite</span> -not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4fd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4fd"><span class="nb">rewrite</span> -not_true_iff_false <span class="kr">in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) ‚â† true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4fe" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4fe"><span class="nb">intros</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk4ff" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk4ff"><span class="nb">apply</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi (S n) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk500" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk500"><span class="nb">clear</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi^{svar:n‚Ü¶X} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi (S n) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk501" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk501"><span class="nb">rewrite</span> -wfc_mu_aux_body_iff <span class="kr">in</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi (S n) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> HContra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk502" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk502"><span class="kn">Lemma</span> <span class="nf">wfc_mu_aux_body_ex_iff&#39;</span> {<span class="nv">Œ£</span> : Signature}:
	 <span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> <span class="nv">n&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
     well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n      
     = well_formed_closed_mu_aux phi n
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> <span class="nv">n&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
  well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n =
  well_formed_closed_mu_aux phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk503" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk503"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">n</span> <span class="nv">n&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
  well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n =
  well_formed_closed_mu_aux phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk504" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk504"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n =
well_formed_closed_mu_aux phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk505" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk505"><span class="nb">remember</span> (well_formed_closed_mu_aux phi n) <span class="kr">as</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>b = well_formed_closed_mu_aux phi n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk506" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk506"><span class="nb">symmetry in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk507" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk507"><span class="nb">destruct</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk508" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = false</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk508"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk509" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk509">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk50a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk50a"><span class="nb">apply</span> wfc_mu_aux_body_ex_imp1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Heqb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk50b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk50b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk50c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk50c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk50d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk50d"><span class="nb">rewrite</span> -not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk50e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk50e"><span class="nb">rewrite</span> -not_true_iff_false <span class="kr">in</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n ‚â† true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n ‚â† true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk50f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk50f"><span class="nb">intros</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk510" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk510"><span class="nb">apply</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqb</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n ‚â† true</span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi n = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk511" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk511"><span class="nb">clear</span> Heqb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi^{<span class="nb">evar</span>:n&#39;‚Ü¶x} n =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk512" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk512"><span class="nb">apply</span> wfc_mu_aux_body_ex_imp2 <span class="kr">in</span> HContra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>HContra</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi n = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> HContra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk513" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk513"><span class="kn">Lemma</span> <span class="nf">wfcmu_pmes_evar_open_pmes</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">m</span> <span class="nv">m&#39;</span> <span class="nv">x</span> <span class="nv">l</span>:
  wfcmu_pmes m (evar_open_pmes m&#39; x l)
  = wfcmu_pmes m l
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk514" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk514"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk515" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk515"><span class="nb">move</span>: m m&#39; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
  wfcmu_pmes m (evar_open_pmes m&#39; x l) =
  wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk516" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk516"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span> m m&#39; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk517" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk517"><hr></label><div class="goal-conclusion">wfcmu_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m&#39;‚Ü¶x}
      :: evar_open_pmes m&#39; x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m&#39;) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l
| pme_variable =&gt; wfcmu_pmes m l
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk518" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk518">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk519" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk519">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m&#39;‚Ü¶x}
      :: evar_open_pmes m&#39; x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m&#39;) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l
| pme_variable =&gt; wfcmu_pmes m l
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk51a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk51a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes m
  <span class="kr">match</span> a <span class="kr">with</span>
  | pme_pattern p =&gt;
      pme_pattern p^{<span class="nb">evar</span>:m&#39;‚Ü¶x}
      :: evar_open_pmes m&#39; x l
  | pme_variable =&gt;
      pme_variable :: evar_open_pmes (S m&#39;) x l
  <span class="kr">end</span> =
<span class="kr">match</span> a <span class="kr">with</span>
| pme_pattern p =&gt;
    well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l
| pme_variable =&gt; wfcmu_pmes m l
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk51b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk51b"><span class="nb">destruct</span> a <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p^{<span class="nb">evar</span>:m&#39;‚Ü¶x} m &amp;&amp;
wfcmu_pmes m (evar_open_pmes m&#39; x l) =
well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk51c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk51c"><hr></label><div class="goal-conclusion">wfcmu_pmes m (evar_open_pmes (S m&#39;) x l) =
wfcmu_pmes m l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk51d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk51d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p^{<span class="nb">evar</span>:m&#39;‚Ü¶x} m &amp;&amp;
wfcmu_pmes m (evar_open_pmes m&#39; x l) =
well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk51e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk51e"><span class="nb">rewrite</span> wfc_mu_aux_body_ex_iff&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p m &amp;&amp;
wfcmu_pmes m (evar_open_pmes m&#39; x l) =
well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk51f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk51f"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l =
well_formed_closed_mu_aux p m &amp;&amp; wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk520" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk520">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes m (evar_open_pmes (S m&#39;) x l) =
wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk521" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk521">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes m (evar_open_pmes (S m&#39;) x l) =
wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk522" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk522"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">m</span> <span class="nv">m&#39;</span> : nat) (<span class="nv">x</span> : <span class="nb">evar</span>),
wfcmu_pmes m (evar_open_pmes m&#39; x l) = wfcmu_pmes m l</span></span></span><br><span><var>m, m'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">wfcmu_pmes m l = wfcmu_pmes m l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wf_simpl_rules</span> := (
  @wfc_ex_aux_foldr_connect&#39;,
  @wfc_mu_aux_foldr_connect,
  @wfp_foldr_connect,
  @wfp_pmes_app,
  @wfp_pmes_evar_open,
  @wfcmu_pmes_app,
  @foralls_count_app,
  @foralls_count_evar_open_pmes,
  @foralls_count_cons_pattern,
  @foralls_count_cons_variable,
  @wfcex_pmes_app,
  @wfcex_pmes_evar_open_pmes_iff,
  @wfcmu_pmes_evar_open_pmes
).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">wf_simpl_goal</span> :=
  <span class="nb">rewrite</span> <span class="nl">?wf_simpl_rules</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">_wf_simpl_hyp</span> H :=
  <span class="nb">rewrite</span> <span class="nl">?wf_simpl_rules</span> <span class="kr">in</span> H
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;wf_simpl_hyp&quot;</span> <span class="kn">ident</span>(H) :=
  _wf_simpl_hyp H
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 Set</span> simplify_wf_goal_hook <span class="kr">as</span> oldhook := <span class="kr">fun</span> () =&gt;
  <span class="kp">try</span> ltac1:(wf_simpl_goal);
  oldhook ()
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 Set</span> simplify_wf_hyp_part_hook <span class="kr">as</span> oldhook := <span class="kr">fun</span> (<span class="nv">h</span> : ident) =&gt;
  ltac1:(h |- wf_simpl_hyp h) (Ltac1.of_ident h);
  oldhook h
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk523" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk523"><span class="kn">Lemma</span> <span class="nf">top_holds_in_any_context</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">Œì</span> <span class="nv">l</span>:
  well_formed (foldr connect patt_top l) -&gt;
  Œì ‚ä¢i foldr connect patt_top l <span class="nb">using</span> AnyReasoning
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)
‚Üí Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk524" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk524"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)
‚Üí Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk525" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk525"><span class="nb">remember</span> (S (length l)) <span class="kr">as</span> len.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen</var><span class="hyp-type"><b>: </b><span>len = S (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)
‚Üí Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk526" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk526"><span class="nb">assert</span> (Hlen : S (length l) &lt;= len) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen</var><span class="hyp-type"><b>: </b><span>len = S (length l)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l) ‚â§ len</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)
‚Üí Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk527" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk527"><span class="nb">clear</span> Heqlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l) ‚â§ len</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)
‚Üí Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk528" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk528"><span class="nb">move</span>: l Hlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk529" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk529"><span class="nb">induction</span> len; <span class="nb">intros</span> l Hlen Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk52a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect Top l)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk52a"><hr></label><div class="goal-conclusion">Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk52b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk52b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk52c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk52c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk52d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk52d"><span class="nb">destruct</span> l; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i Top <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk52e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed (connect p (foldr connect Top l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk52e"><hr></label><div class="goal-conclusion">Œì ‚ä¢i connect p (foldr connect Top l)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk52f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk52f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i Top <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk530" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk530">useBasicReasoning.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i Top <span class="nb">using</span> BasicReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk531" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk531"><span class="nb">apply</span> A_impl_A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed ‚ä•</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk532" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk532">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed (connect p (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i connect p (foldr connect Top l)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk533" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk533"><span class="nb">destruct</span> p <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i p ---&gt; foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk534" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk534"><hr></label><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk535" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk535">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i p ---&gt; foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk536" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk536"><span class="nb">eapply</span> MP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="nl">?œï‚ÇÅ</span> <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk537" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk537"><hr></label><div class="goal-conclusion">Œì ‚ä¢i <span class="nl">?œï‚ÇÅ</span> ---&gt; p ---&gt; foldr connect Top l
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk538" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk538"><span class="mi">2</span>: useBasicReasoning; <span class="nb">apply</span> ProofInfo.P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk539" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk539"><hr></label><div class="goal-conclusion">well_formed (foldr connect Top l)</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk53a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk53a"><hr></label><div class="goal-conclusion">well_formed p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk53b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk53b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk53c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk53c"><span class="nb">apply</span> IHlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length l) ‚â§ len</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk53d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk53d"><hr></label><div class="goal-conclusion">well_formed (foldr connect Top l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk53e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk53e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length l) ‚â§ len</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk53f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk53f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk540" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk540">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk541" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk541">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk542" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p) (foldr connect Top l))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk542"><hr></label><div class="goal-conclusion">well_formed p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk543" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk543">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk544" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk544">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk545" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk545"><span class="nb">remember</span> (fresh_evar (foldr connect patt_top l)) <span class="kr">as</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect Top l <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk546" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk546"><span class="nb">replace</span> (foldr connect patt_top l)
      <span class="kr">with</span> (evar_quantify x <span class="mi">0</span> (evar_open x <span class="mi">0</span> (foldr connect patt_top l)))
    .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i <span class="kp">all</span> , (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk547" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk547"><hr></label><div class="goal-conclusion">(foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
foldr connect Top l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk548" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk548"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
foldr connect Top l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk549" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk549"><span class="nb">apply</span> evar_quantify_evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àâ free_evars (foldr connect Top l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk54a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk54a"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect Top l) <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk54b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk54b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚àâ free_evars (foldr connect Top l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk54c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk54c"><span class="nb">subst</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_evar (foldr connect Top l)
‚àâ free_evars (foldr connect Top l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> set_evar_fresh_is_fresh.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk54d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk54d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (foldr connect Top l) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk54e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk54e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i <span class="kp">all</span> , (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk54f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk54f"><span class="nb">apply</span> universal_generalization.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false)
  AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk550" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk550"><hr></label><div class="goal-conclusion">well_formed (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk551" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk551"><hr></label><div class="goal-conclusion">Œì ‚ä¢i (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk552" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk552">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false)
  AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pile_any.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk553" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk553">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk554" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk554"><hr></label><div class="goal-conclusion">Œì ‚ä¢i (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk555" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk555">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk556" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk556">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i (foldr connect Top l)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk557" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk557"><span class="nb">rewrite</span> evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect Top^{<span class="nb">evar</span>:<span class="mi">0</span> + foralls_count l‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk558" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk558"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect Top^{<span class="nb">evar</span>:foralls_count l‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk559" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk559">mlSimpl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect Top (evar_open_pmes <span class="mi">0</span> x l)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk55a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk55a"><span class="nb">apply</span> IHlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes <span class="mi">0</span> x l)) ‚â§ len</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk55b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk55b"><hr></label><div class="goal-conclusion">well_formed (foldr connect Top (evar_open_pmes <span class="mi">0</span> x l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk55c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk55c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes <span class="mi">0</span> x l)) ‚â§ len</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk55d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk55d"><span class="nb">rewrite</span> length_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length l) ‚â§ len</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk55e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk55e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top (evar_open_pmes <span class="mi">0</span> x l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk55f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk55f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l</span> : list ProofModeEntry,
  S (length l) ‚â§ len
  ‚Üí well_formed (foldr connect Top l)
    ‚Üí Œì ‚ä¢i foldr connect Top l
      <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l)) ‚â§ S len</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable (foldr connect Top l))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x = fresh_evar (foldr connect Top l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect Top (evar_open_pmes <span class="mi">0</span> x l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">Check evar_open_pmes.</span>
<span class="c">Lemma evar_open_fresh_iter_base_foldr_connect</span>
<span class="c">  {Œ£ : Signature} (base idx : nat) (a : Pattern) l:</span>
<span class="c">  evar_open_fresh_iter_base evs base idx (foldr connect a l)</span>
<span class="c">  = foldr</span>
<span class="c">      connect</span>
<span class="c">      (evar_open_fresh_iter_base evs base idx a)</span>
<span class="c">      (evar_open_pmes ).</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk560" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk560"><span class="kn">Lemma</span> <span class="nf">nested_const_middle_fa</span> {<span class="nv">Œ£</span> : Signature} <span class="nv">Œì</span> <span class="nv">a</span> <span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> :
  well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true -&gt;
  well_formed ((fold_right connect a (l‚ÇÅ ++ (pme_pattern a) :: l‚ÇÇ))) = true -&gt;
  Œì ‚ä¢i (fold_right connect (a) (l‚ÇÅ ++ (pme_pattern a) :: l‚ÇÇ))
  <span class="nb">using</span> AnyReasoning.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true
‚Üí well_formed
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
  true
  ‚Üí Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
    <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk561" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk561"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true
‚Üí well_formed
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
  true
  ‚Üí Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
    <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk562" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk562"><span class="nb">remember</span> (S (length l‚ÇÅ)) <span class="kr">as</span> len.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen</var><span class="hyp-type"><b>: </b><span>len = S (length l‚ÇÅ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true
‚Üí well_formed
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
  true
  ‚Üí Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
    <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk563" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk563"><span class="nb">assert</span> (Hlen : S (length l‚ÇÅ) &lt;= len) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen</var><span class="hyp-type"><b>: </b><span>len = S (length l‚ÇÅ)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l‚ÇÅ) ‚â§ len</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true
‚Üí well_formed
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
  true
  ‚Üí Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
    <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk564" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk564"><span class="nb">clear</span> Heqlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l‚ÇÅ) ‚â§ len</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true
‚Üí well_formed
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
  true
  ‚Üí Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
    <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk565" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk565"><span class="nb">move</span>: a l‚ÇÅ l‚ÇÇ Hlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) =
    true
    ‚Üí well_formed
        (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
      true
      ‚Üí Œì
        ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk566" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk566"><span class="nb">induction</span> len; <span class="nb">intros</span> a l‚ÇÅ l‚ÇÇ Hlen Ha H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l‚ÇÅ) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) =
true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk567" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l‚ÇÅ) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) =
true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk567"><hr></label><div class="goal-conclusion">Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk568" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk568">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l‚ÇÅ) ‚â§ <span class="mi">0</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) =
true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk569" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk569">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (length l‚ÇÅ) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) =
true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk56a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk56a"><span class="nb">destruct</span> l‚ÇÅ; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (a ---&gt; foldr connect a l‚ÇÇ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i a ---&gt; foldr connect a l‚ÇÇ <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk56b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable p)
      <span class="kr">then</span> p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect p
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk56b"><hr></label><div class="goal-conclusion">Œì
‚ä¢i connect p
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk56c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk56c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (a ---&gt; foldr connect a l‚ÇÇ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i a ---&gt; foldr connect a l‚ÇÇ <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk56d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk56d"><span class="nb">apply</span> nested_const_fa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (a ---&gt; foldr connect a l‚ÇÇ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk56e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (a ---&gt; foldr connect a l‚ÇÇ) = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk56e"><hr></label><div class="goal-conclusion">well_formed (foldr connect ‚ä• l‚ÇÇ) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk56f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk56f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (a ---&gt; foldr connect a l‚ÇÇ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed a = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk570" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk570">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (a ---&gt; foldr connect a l‚ÇÇ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect ‚ä• l‚ÇÇ) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk571" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk571">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (a ---&gt; foldr connect a l‚ÇÇ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (foldr connect ‚ä• l‚ÇÇ) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk572" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk572">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable p)
      <span class="kr">then</span> p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect p
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i connect p
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk573" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk573">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ProofModeEntry</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable p)
      <span class="kr">then</span> p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect p
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i connect p
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk574" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk574"><span class="nb">destruct</span> p <span class="kr">as</span> [p|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i p ---&gt; foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk575" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable pme_variable)
      <span class="kr">then</span> pme_variable :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk575"><hr></label><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk576" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk576">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i p ---&gt; foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk577" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk577"><span class="nb">eapply</span> MP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="nl">?œï‚ÇÅ</span> <span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk578" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk578"><hr></label><div class="goal-conclusion">Œì
‚ä¢i <span class="nl">?œï‚ÇÅ</span> ---&gt;
   p ---&gt; foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk579" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk579"><span class="mi">2</span>: useBasicReasoning; <span class="nb">apply</span> ProofInfo.P1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk57a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk57a"><hr></label><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk57b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk57b"><hr></label><div class="goal-conclusion">well_formed p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk57c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk57c"><span class="mi">2</span>,<span class="mi">3</span>: wf_auto2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk57d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk57d"><span class="nb">apply</span> IHlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length l‚ÇÅ) ‚â§ len</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk57e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk57e"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk57f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk57f"><hr></label><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk580" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk580">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length l‚ÇÅ) ‚â§ len</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk581" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk581">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk582" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk582"><hr></label><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk583" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk583">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a (foralls_count l‚ÇÅ) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk584" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk584">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk585" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk585">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable (pme_pattern p))
      <span class="kr">then</span> pme_pattern p :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect (pme_pattern p)
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk586" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk586">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable pme_variable)
      <span class="kr">then</span> pme_variable :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk587" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk587">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> decide (is_variable pme_variable)
      <span class="kr">then</span> pme_variable :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk588" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk588"><span class="nb">unfold</span> decide <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (length
     (<span class="kr">if</span> is_variable_dec pme_variable
      <span class="kr">then</span> pme_variable :: filter is_variable l‚ÇÅ
      <span class="kr">else</span> filter is_variable l‚ÇÅ)) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk589" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk589"><span class="nb">simpl</span> <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk58a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk58a"><span class="nb">remember</span> (fresh_evar (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) <span class="kr">as</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì ‚ä¢i <span class="kp">all</span> , foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk58b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk58b"><span class="nb">replace</span> (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))
        <span class="kr">with</span> (evar_quantify x <span class="mi">0</span> (evar_open x <span class="mi">0</span> (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))))
      .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i <span class="kp">all</span> ,
   (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk58c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk58c"><hr></label><div class="goal-conclusion">(foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk58d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk58d"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk58e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk58e"><span class="nb">apply</span> evar_quantify_evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x
‚àâ free_evars
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk58f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk58f"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk590" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk590">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x
‚àâ free_evars
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk591" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk591"><span class="nb">subst</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))
‚àâ free_evars
    (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> set_evar_fresh_is_fresh.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk592" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk592">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk593" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk593">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i <span class="kp">all</span> ,
   (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk594" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk594"><span class="nb">apply</span> universal_generalization.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false)
  AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk595" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk595"><hr></label><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk596" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk596"><hr></label><div class="goal-conclusion">Œì
‚ä¢i (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk597" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk597">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ProofInfoLe
  (ExGen := {[x]}, SVSubst := ‚àÖ, KT := false)
  AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pile_any.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk598" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk598">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk599" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk599"><hr></label><div class="goal-conclusion">Œì
‚ä¢i (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk59a" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk59a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk59b" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk59b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk59c" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk59c"><span class="nb">rewrite</span> evar_open_foldr_connect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:<span class="mi">0</span> +
             foralls_count (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk59d" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk59d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:foralls_count (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk59e" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk59e"><span class="nb">rewrite</span> evar_open_pmes_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:foralls_count (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      evar_open_pmes (<span class="mi">0</span> + foralls_count l‚ÇÅ) x
        (pme_pattern a :: l‚ÇÇ)) <span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk59f" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk59f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (connect pme_variable
     (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:foralls_count (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a^{<span class="nb">evar</span>:foralls_count l‚ÇÅ‚Ü¶x}
      :: evar_open_pmes (foralls_count l‚ÇÅ) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a0"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:foralls_count (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a^{<span class="nb">evar</span>:foralls_count l‚ÇÅ‚Ü¶x}
      :: evar_open_pmes (foralls_count l‚ÇÅ) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a1"><span class="nb">unfold</span> foralls_count.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:length
               (filter is_variable
                  (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a2"><span class="nb">rewrite</span> filter_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:length
               (filter is_variable l‚ÇÅ ++
                filter is_variable
                  (pme_pattern a :: l‚ÇÇ))‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a3"><span class="nb">rewrite</span> app_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
             length
               (filter is_variable
                  (pme_pattern a :: l‚ÇÇ))‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a4"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
             length
               (<span class="kr">if</span>
                 decide (is_variable (pme_pattern a))
                <span class="kr">then</span>
                 pme_pattern a
                 :: filter is_variable l‚ÇÇ
                <span class="kr">else</span> filter is_variable l‚ÇÇ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a5"><span class="nb">unfold</span> decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
             length (filter is_variable l‚ÇÇ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a6"><span class="nb">remember</span> (a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) + length (filter is_variable l‚ÇÇ)‚Ü¶x}) <span class="kr">as</span> a&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a7"><span class="nb">remember</span> (a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}) <span class="kr">as</span> a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a8"><span class="nb">unfold</span> decide <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5a9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5a9"><span class="nb">cbn</span> <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">a</span> : Pattern) (<span class="nv">l‚ÇÅ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry),
  S (length l‚ÇÅ) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a
      (foralls_count l‚ÇÅ) = true
    ‚Üí well_formed
        (foldr connect a
           (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a
             (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÅ, l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5aa" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5aa"><span class="nb">specialize</span> (IHlen a&#39; (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">l‚ÇÇ</span> : list ProofModeEntry,
  S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
  ‚Üí well_formed_closed_ex_aux a&#39;
      (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
    true
    ‚Üí well_formed
        (foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39; :: l‚ÇÇ)) = true
      ‚Üí Œì
        ‚ä¢i foldr connect a&#39;
             (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
              pme_pattern a&#39; :: l‚ÇÇ)
        <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5ab" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5ab"><span class="nb">specialize</span> (IHlen (evar_open_pmes (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5ac" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5ac">feed <span class="nb">specialize</span> IHlen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5ad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5ad"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux a&#39;
  (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5ae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5ae"><hr></label><div class="goal-conclusion">well_formed
  (foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)) =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5af" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5af"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b1"><span class="nb">rewrite</span> length_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length l‚ÇÅ) ‚â§ len</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b2">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39;
  (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5b3"><hr></label><div class="goal-conclusion">well_formed
  (foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)) =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5b4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5b4"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b5" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39;
  (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b6"><span class="nb">rewrite</span> foralls_count_evar_open_pmes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a&#39; (foralls_count l‚ÇÅ) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)) =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5b8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5b8"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5b9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5b9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux a&#39;
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect a&#39;
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern a&#39;
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect a&#39;
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern a&#39;
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5ba" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5ba"><span class="nb">subst</span> a&#39; a&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>S (length (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) ‚â§ len
‚Üí well_formed_closed_ex_aux
    a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
    (foralls_count (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ)) =
  true
  ‚Üí well_formed
      (foldr connect
         a^{<span class="nb">evar</span>:length
                   (filter is_variable l‚ÇÅ)‚Ü¶x}
         (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
          pme_pattern
            a^{<span class="nb">evar</span>:length
                      (filter is_variable l‚ÇÅ)‚Ü¶x}
          :: evar_open_pmes
               (length (filter is_variable l‚ÇÅ))
               x l‚ÇÇ)) = true
    ‚Üí Œì
      ‚ä¢i foldr connect
           a^{<span class="nb">evar</span>:length
                     (filter is_variable l‚ÇÅ)‚Ü¶x}
           (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
            pme_pattern
              a^{<span class="nb">evar</span>:length
                       (filter is_variable l‚ÇÅ)‚Ü¶x}
            :: evar_open_pmes
                 (length
                    (filter is_variable l‚ÇÅ)) x
                 l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5bb" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5bb"><span class="nb">clear</span> -H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect
     a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5bc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5bc"><span class="nb">fold</span> (foralls_count l‚ÇÅ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed
  (foldr connect a^{<span class="nb">evar</span>:foralls_count l‚ÇÅ‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a^{<span class="nb">evar</span>:foralls_count l‚ÇÅ‚Ü¶x}
      :: evar_open_pmes (foralls_count l‚ÇÅ) x l‚ÇÇ)) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5bd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5bd">wf_auto2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÅ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>wfcex_pmes <span class="mi">1</span> l‚ÇÅ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÅ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive a = true</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ)) =
true</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ)) = true</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S (foralls_count l‚ÇÅ)) l‚ÇÇ = true</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÇ = true</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÇ = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  a^[<span class="nb">evar</span>:foralls_count l‚ÇÅ‚Ü¶patt_free_evar x]
  (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5be" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5be">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÅ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>wfcex_pmes <span class="mi">1</span> l‚ÇÅ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÅ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive a = true</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ)) =
true</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ)) = true</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S (foralls_count l‚ÇÅ)) l‚ÇÇ = true</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÇ = true</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÇ = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux
  a^[<span class="nb">evar</span>:foralls_count l‚ÇÅ‚Ü¶patt_free_evar x]
  (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5bf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5bf"><span class="nb">apply</span> wfc_ex_aux_bsvar_subst_le;[<span class="bp">lia</span>|<span class="kp">idtac</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÅ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>wfcex_pmes <span class="mi">1</span> l‚ÇÅ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÅ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive a = true</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ)) =
true</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ)) = true</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S (foralls_count l‚ÇÅ)) l‚ÇÇ = true</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÇ = true</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÇ = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ)) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5c0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÅ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>wfcex_pmes <span class="mi">1</span> l‚ÇÅ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÅ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive a = true</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ)) =
true</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ)) = true</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S (foralls_count l‚ÇÅ)) l‚ÇÇ = true</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÇ = true</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÇ = true</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5c0"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x)
  (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c1" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c1">wf_auto2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÅ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>wfcex_pmes <span class="mi">1</span> l‚ÇÅ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÅ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive a = true</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ)) =
true</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (foralls_count l‚ÇÅ)) = true</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>wfcex_pmes (S (foralls_count l‚ÇÅ)) l‚ÇÇ = true</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux a <span class="mi">0</span> = true</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>wfcmu_pmes <span class="mi">0</span> l‚ÇÇ = true</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>wfp_pmes l‚ÇÇ = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux (patt_free_evar x)
  (foralls_count l‚ÇÅ + foralls_count l‚ÇÇ) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c2" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c2">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        length (filter is_variable l‚ÇÇ)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      

</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c3" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c3"><span class="nb">remember</span> (length (filter is_variable l‚ÇÇ)) <span class="kr">as</span> len2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>len2 = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) + len2‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c4" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c4"><span class="nb">destruct</span> len2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) + <span class="mi">0</span>‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5c5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S len2 = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S len2‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5c5"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c6" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) + <span class="mi">0</span>‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c7" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c7"><span class="nb">rewrite</span> Nat.add_0_r <span class="kr">in</span> Heqa&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c8" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c8"><span class="nb">subst</span> a&#39;&#39; a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = length (filter is_variable l‚ÇÇ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect
     a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern
        a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHlen.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5c9" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5c9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S len2 = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S len2‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5ca" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5ca"><span class="nb">assert</span> (a&#39;&#39; = a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S len2 = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S len2‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39;&#39; = a&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S len2 = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S len2‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; = a&#39;</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5cb"><hr></label><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5cc" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5cc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S len2 = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S len2‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39;&#39; = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5cd" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5cd"><span class="nb">destruct</span> len2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) + <span class="mi">1</span>‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39;&#39; = a&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ProofMode2-v-chk5ce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S (S len2) = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S (S len2)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><label class="goal-separator" for="ProofMode2-v-chk5ce"><hr></label><div class="goal-conclusion">a&#39;&#39; = a&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5cf" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5cf"><span class="nb">admit</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S (S len2) = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S (S len2)‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39;&#39; = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ProofMode2-v-chk5d0" style="display: none" type="checkbox"><label class="alectryon-input" for="ProofMode2-v-chk5d0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>Theory</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l‚ÇÅ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>l‚ÇÇ</var><span class="hyp-type"><b>: </b><span>list ProofModeEntry</span></span></span><br><span><var>IHlen</var><span class="hyp-type"><b>: </b><span>Œì
‚ä¢i foldr connect a&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x
           l‚ÇÇ) <span class="nb">using</span> AnyReasoning</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>S (S (length l‚ÇÅ)) ‚â§ S len</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux a
  (S (length (filter is_variable l‚ÇÅ))) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed
  (<span class="kp">all</span> ,
   foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ)) =
true</span></span></span><br><span><var>Heqx</var><span class="hyp-type"><b>: </b><span>x =
fresh_evar
  (foldr connect a (l‚ÇÅ ++ pme_pattern a :: l‚ÇÇ))</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>len2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqlen2</var><span class="hyp-type"><b>: </b><span>S len2 = length (filter is_variable l‚ÇÇ)</span></span></span><br><span><var>Heqa''</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; =
a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ) +
        S len2‚Ü¶x}</span></span></span><br><span><var>Heqa'</var><span class="hyp-type"><b>: </b><span>a&#39; = a^{<span class="nb">evar</span>:length (filter is_variable l‚ÇÅ)‚Ü¶x}</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a&#39;&#39; = a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œì
‚ä¢i foldr connect a&#39;&#39;
     (evar_open_pmes <span class="mi">0</span> x l‚ÇÅ ++
      pme_pattern a&#39;
      :: evar_open_pmes
           (length (filter is_variable l‚ÇÅ)) x l‚ÇÇ)
<span class="nb">using</span> AnyReasoning</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
      <span class="c">(* apply IHlen. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> ml_scope.</span><span class="alectryon-wsp">
</span></span></pre></article></body></html>