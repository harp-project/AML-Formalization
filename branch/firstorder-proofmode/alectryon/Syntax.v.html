<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Syntax.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect ssrfun ssrbool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Setoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Ensembles.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Strings.String.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Logic.Classical_Prop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk0"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> countable infinite.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> pmap gmap mapset fin_sets propset.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> stdpp_ext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> extralibrary.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> MatchingLogic <span class="kn">Require Export</span>
  Signature
  Pattern
  Substitution
  Freshness
  SyntacticConstruct
  PatternContext
  ApplicationContext
  SyntaxLemmas.FreshnessSubstitution
  SyntaxLemmas.PatternCtxApplicationCtx
  SyntaxLemmas.FreshnessApplicationCtx
  SyntaxLemmas.ApplicationCtxSubstitution
  wftactics
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> MatchingLogic.Substitution.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Theory</span> {<span class="nv">Σ</span> : Signature} := propset Pattern.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> boolean_if_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">syntax</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Σ</span> : Signature}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">is_subformula_of_ind</span> : Pattern -&gt; Pattern -&gt; <span class="kt">Prop</span> :=
  | sub_eq ϕ₁ ϕ₂ : ϕ₁ = ϕ₂ -&gt; is_subformula_of_ind ϕ₁ ϕ₂
  | sub_app_l ϕ₁ ϕ₂ ϕ₃ : is_subformula_of_ind ϕ₁ ϕ₂ -&gt; is_subformula_of_ind ϕ₁ (patt_app ϕ₂ ϕ₃)
  | sub_app_r ϕ₁ ϕ₂ ϕ₃ : is_subformula_of_ind ϕ₁ ϕ₃ -&gt; is_subformula_of_ind ϕ₁ (patt_app ϕ₂ ϕ₃)
  | sub_imp_l ϕ₁ ϕ₂ ϕ₃ : is_subformula_of_ind ϕ₁ ϕ₂ -&gt; is_subformula_of_ind ϕ₁ (patt_imp ϕ₂ ϕ₃)
  | sub_imp_r ϕ₁ ϕ₂ ϕ₃ : is_subformula_of_ind ϕ₁ ϕ₃ -&gt; is_subformula_of_ind ϕ₁ (patt_imp ϕ₂ ϕ₃)
  | sub_exists ϕ₁ ϕ₂ : is_subformula_of_ind ϕ₁ ϕ₂ -&gt; is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)
  | sub_mu ϕ₁ ϕ₂ : is_subformula_of_ind ϕ₁ ϕ₂ -&gt; is_subformula_of_ind ϕ₁ (patt_mu ϕ₂)
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">is_subformula_of</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> : bool :=
    (decide_rel (=) ϕ₁ ϕ₂)
    || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
       | patt_app l r | patt_imp l r =&gt; is_subformula_of ϕ₁ l || is_subformula_of ϕ₁ r
       | patt_exists phi | patt_mu phi =&gt; is_subformula_of ϕ₁ phi
       | _ =&gt; false
       <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2"><span class="kn">Lemma</span> <span class="nf">is_subformula_of_P</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> : reflect (is_subformula_of_ind ϕ₁ ϕ₂) (is_subformula_of ϕ₁ ϕ₂).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ ϕ₂)
  (is_subformula_of ϕ₁ ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ ϕ₂)
  (is_subformula_of ϕ₁ ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4"><span class="nb">unfold</span> is_subformula_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ ϕ₂)
  ((<span class="kr">fix</span> is_subformula_of
      (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
      decide_rel eq ϕ₁ ϕ₂
      || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
         | patt_app l r | patt_imp l r =&gt;
             is_subformula_of ϕ₁ l
             || is_subformula_of ϕ₁ r
         | patt_exists phi | patt_mu phi =&gt;
             is_subformula_of ϕ₁ phi
         | _ =&gt; false
         <span class="kr">end</span>) ϕ₁ ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5"><span class="nb">remember</span> ϕ₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
  ((<span class="kr">fix</span> is_subformula_of
      (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
      decide_rel eq ϕ₁ ϕ₂
      || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
         | patt_app l r | patt_imp l r =&gt;
             is_subformula_of ϕ₁ l
             || is_subformula_of ϕ₁ r
         | patt_exists phi | patt_mu phi =&gt;
             is_subformula_of ϕ₁ phi
         | _ =&gt; false
         <span class="kr">end</span>) ϕ₁ p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk6"><span class="nb">revert</span> p Heqp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      ((<span class="kr">fix</span> is_subformula_of
          (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
          decide_rel eq ϕ₁ ϕ₂
          || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
             | patt_app l r | patt_imp l r =&gt;
                 is_subformula_of ϕ₁ l
                 || is_subformula_of ϕ₁ r
             | patt_exists phi | patt_mu phi =&gt;
                 is_subformula_of ϕ₁ phi
             | _ =&gt; false
             <span class="kr">end</span>) ϕ₁ p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* TODO *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk7"><span class="nb">induction</span> ϕ₂; <span class="nb">move</span>=&gt; p Heqp; <span class="nb">destruct</span> (decide_rel (=) ϕ₁ p) <span class="nb">eqn</span>:Heq2;
                           <span class="nb">rewrite</span> Heqp; <span class="nb">rewrite</span> -Heqp; <span class="nb">rewrite</span> Heq2; <span class="nb">simpl</span>; <span class="nb">rewrite</span> Heqp;
                             <span class="kp">try</span> (<span class="nb">apply</span> ReflectT; <span class="nb">subst</span>; <span class="nb">apply</span> sub_eq; <span class="bp">reflexivity</span>);
                             <span class="kp">try</span> (<span class="nb">apply</span> ReflectF; <span class="nb">intros</span> Contra; <span class="nb">inversion</span> Contra; <span class="nb">subst</span>; <span class="bp">contradiction</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      ((<span class="kr">fix</span> is_subformula_of
          (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} :
            bool :=
          decide_rel eq ϕ₁ ϕ₂
          || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
             | patt_app l r | patt_imp l r =&gt;
                 is_subformula_of ϕ₁ l
                 || is_subformula_of ϕ₁ r
             | patt_exists phi |
               patt_mu phi =&gt;
                 is_subformula_of ϕ₁ phi
             | _ =&gt; false
             <span class="kr">end</span>) ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      ((<span class="kr">fix</span> is_subformula_of
          (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} :
            bool :=
          decide_rel eq ϕ₁ ϕ₂
          || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
             | patt_app l r | patt_imp l r =&gt;
                 is_subformula_of ϕ₁ l
                 || is_subformula_of ϕ₁ r
             | patt_exists phi |
               patt_mu phi =&gt;
                 is_subformula_of ϕ₁ phi
             | _ =&gt; false
             <span class="kr">end</span>) ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2))
  ((<span class="kr">fix</span> is_subformula_of
      (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
      decide_rel eq ϕ₁ ϕ₂
      || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
         | patt_app l r | patt_imp l r =&gt;
             is_subformula_of ϕ₁ l
             || is_subformula_of ϕ₁ r
         | patt_exists phi | patt_mu phi =&gt;
             is_subformula_of ϕ₁ phi
         | _ =&gt; false
         <span class="kr">end</span>) ϕ₁ ϕ₂1
   || (<span class="kr">fix</span> is_subformula_of
         (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
         decide_rel eq ϕ₁ ϕ₂
         || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
            | patt_app l r | patt_imp l r =&gt;
                is_subformula_of ϕ₁ l
                || is_subformula_of ϕ₁ r
            | patt_exists phi | patt_mu phi =&gt;
                is_subformula_of ϕ₁ phi
            | _ =&gt; false
            <span class="kr">end</span>) ϕ₁ ϕ₂2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      ((<span class="kr">fix</span> is_subformula_of
          (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} :
            bool :=
          decide_rel eq ϕ₁ ϕ₂
          || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
             | patt_app l r | patt_imp l r =&gt;
                 is_subformula_of ϕ₁ l
                 || is_subformula_of ϕ₁ r
             | patt_exists phi |
               patt_mu phi =&gt;
                 is_subformula_of ϕ₁ phi
             | _ =&gt; false
             <span class="kr">end</span>) ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      ((<span class="kr">fix</span> is_subformula_of
          (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} :
            bool :=
          decide_rel eq ϕ₁ ϕ₂
          || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
             | patt_app l r | patt_imp l r =&gt;
                 is_subformula_of ϕ₁ l
                 || is_subformula_of ϕ₁ r
             | patt_exists phi |
               patt_mu phi =&gt;
                 is_subformula_of ϕ₁ phi
             | _ =&gt; false
             <span class="kr">end</span>) ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk8"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2))
  ((<span class="kr">fix</span> is_subformula_of
      (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
      decide_rel eq ϕ₁ ϕ₂
      || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
         | patt_app l r | patt_imp l r =&gt;
             is_subformula_of ϕ₁ l
             || is_subformula_of ϕ₁ r
         | patt_exists phi | patt_mu phi =&gt;
             is_subformula_of ϕ₁ phi
         | _ =&gt; false
         <span class="kr">end</span>) ϕ₁ ϕ₂1
   || (<span class="kr">fix</span> is_subformula_of
         (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
         decide_rel eq ϕ₁ ϕ₂
         || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
            | patt_app l r | patt_imp l r =&gt;
                is_subformula_of ϕ₁ l
                || is_subformula_of ϕ₁ r
            | patt_exists phi | patt_mu phi =&gt;
                is_subformula_of ϕ₁ phi
            | _ =&gt; false
            <span class="kr">end</span>) ϕ₁ ϕ₂2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      ((<span class="kr">fix</span> is_subformula_of
          (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} :
            bool :=
          decide_rel eq ϕ₁ ϕ₂
          || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
             | patt_app l r | patt_imp l r =&gt;
                 is_subformula_of ϕ₁ l
                 || is_subformula_of ϕ₁ r
             | patt_exists phi | patt_mu phi =&gt;
                 is_subformula_of ϕ₁ phi
             | _ =&gt; false
             <span class="kr">end</span>) ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk9"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂))
  ((<span class="kr">fix</span> is_subformula_of
      (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
      decide_rel eq ϕ₁ ϕ₂
      || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
         | patt_app l r | patt_imp l r =&gt;
             is_subformula_of ϕ₁ l
             || is_subformula_of ϕ₁ r
         | patt_exists phi | patt_mu phi =&gt;
             is_subformula_of ϕ₁ phi
         | _ =&gt; false
         <span class="kr">end</span>) ϕ₁ ϕ₂)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      ((<span class="kr">fix</span> is_subformula_of
          (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} :
            bool :=
          decide_rel eq ϕ₁ ϕ₂
          || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
             | patt_app l r | patt_imp l r =&gt;
                 is_subformula_of ϕ₁ l
                 || is_subformula_of ϕ₁ r
             | patt_exists phi | patt_mu phi =&gt;
                 is_subformula_of ϕ₁ phi
             | _ =&gt; false
             <span class="kr">end</span>) ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chka"><hr></label><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  ((<span class="kr">fix</span> is_subformula_of
      (ϕ₁ ϕ₂ : Pattern) {<span class="kr">struct</span> ϕ₂} : bool :=
      decide_rel eq ϕ₁ ϕ₂
      || <span class="kr">match</span> ϕ₂ <span class="kr">with</span>
         | patt_app l r | patt_imp l r =&gt;
             is_subformula_of ϕ₁ l
             || is_subformula_of ϕ₁ r
         | patt_exists phi | patt_mu phi =&gt;
             is_subformula_of ϕ₁ phi
         | _ =&gt; false
         <span class="kr">end</span>) ϕ₁ ϕ₂)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb"><span class="kp">all</span>: <span class="nb">fold</span> is_subformula_of <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2))
  (is_subformula_of ϕ₁ ϕ₂1 || is_subformula_of ϕ₁ ϕ₂2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkc"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2))
  (is_subformula_of ϕ₁ ϕ₂1 || is_subformula_of ϕ₁ ϕ₂2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkd"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂))
  (is_subformula_of ϕ₁ ϕ₂)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chke"><hr></label><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  (is_subformula_of ϕ₁ ϕ₂)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2))
  (is_subformula_of ϕ₁ ϕ₂1 || is_subformula_of ϕ₁ ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk10"><span class="nb">destruct</span> (IHϕ₂1 ϕ₂1),(IHϕ₂2 ϕ₂2); <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk11"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk12"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk13"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk14">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk15"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk16"><span class="nb">apply</span> sub_app_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk17">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk18"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk19"><span class="nb">apply</span> sub_app_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1b"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1c"><span class="nb">apply</span> sub_app_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)) false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1e"><span class="nb">apply</span> ReflectF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1f"><span class="nb">intros</span> Contra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_app ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br><span><var>Contra</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ (patt_app ϕ₂1 ϕ₂2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Contra; <span class="nb">subst</span>; <span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2))
  (is_subformula_of ϕ₁ ϕ₂1 || is_subformula_of ϕ₁ ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk21"><span class="nb">destruct</span> (IHϕ₂1 ϕ₂1),(IHϕ₂2 ϕ₂2); <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk22"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk23"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk24"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk25">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk26"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk27"><span class="nb">apply</span> sub_imp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk28">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk29"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2a"><span class="nb">apply</span> sub_imp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2c"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d"><span class="nb">apply</span> sub_imp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)) false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f"><span class="nb">apply</span> ReflectF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk30"><span class="nb">intros</span> Contra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂1, ϕ₂2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂1
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>IHϕ₂2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂2
  → ssrbool.reflect
      (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_imp ϕ₂1 ϕ₂2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂1</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂2</span></span></span><br><span><var>Contra</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ (patt_imp ϕ₂1 ϕ₂2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Contra; <span class="nb">subst</span>; <span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂))
  (is_subformula_of ϕ₁ ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk32"><span class="nb">destruct</span> (IHϕ₂ ϕ₂).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ϕ₂ = ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk33"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)) true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk34"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)) false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk35"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)) true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk36"><hr></label><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)) false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk37">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)) true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk38"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk39"><span class="nb">apply</span> sub_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect
  (is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)) false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b"><span class="nb">apply</span> ReflectF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c"><span class="nb">intros</span> Contra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_exists ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>Contra</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ (patt_exists ϕ₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Contra; <span class="nb">subst</span>; <span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  (is_subformula_of ϕ₁ ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e"><span class="nb">destruct</span> (IHϕ₂ ϕ₂).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ϕ₂ = ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3f"><hr></label><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk40"><hr></label><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk41"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk42"><hr></label><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk43">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk44"><span class="nb">apply</span> ReflectT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ (patt_mu ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk45"><span class="nb">apply</span> sub_mu.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk46">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ssrbool.reflect (is_subformula_of_ind ϕ₁ (patt_mu ϕ₂))
  false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk47"><span class="nb">apply</span> ReflectF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ is_subformula_of_ind ϕ₁ (patt_mu ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk48"><span class="nb">intros</span> Contra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₂</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">p</span> : Pattern,
  p = ϕ₂
  → ssrbool.reflect (is_subformula_of_ind ϕ₁ p)
      (is_subformula_of ϕ₁ p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Heqp</var><span class="hyp-type"><b>: </b><span>p = patt_mu ϕ₂</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ϕ₁ ≠ p</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>decide_rel eq ϕ₁ p = <span class="nb">right</span> n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>Contra</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ (patt_mu ϕ₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Contra; <span class="nb">subst</span>; <span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk49"><span class="kn">Lemma</span> <span class="nf">is_subformula_of_refl</span> <span class="nv">ϕ</span>:
    is_subformula_of ϕ ϕ = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of ϕ ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of ϕ ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b"><span class="nb">destruct</span> (is_subformula_of_P ϕ ϕ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ ϕ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4c"><hr></label><div class="goal-conclusion">false = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f"><span class="nb">assert</span> (H: is_subformula_of_ind ϕ ϕ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ ϕ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ ϕ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ ϕ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk50"><hr></label><div class="goal-conclusion">false = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk51"><span class="nb">apply</span> sub_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ϕ = ϕ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ ϕ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ ϕ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk52"><hr></label><div class="goal-conclusion">false = true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk53"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ is_subformula_of_ind ϕ ϕ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk54"><span class="kn">Lemma</span> <span class="nf">bsvar_subst_contains_subformula</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span> :
    bsvar_occur ϕ₁ dbi = true -&gt;
    is_subformula_of_ind ϕ₂ (ϕ₁^[svar: dbi ↦ ϕ₂]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ₁ dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ₁ dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk56"><span class="nb">generalize dependent</span> dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk57"><span class="nb">induction</span> ϕ₁; <span class="nb">intros</span> dbi H; <span class="nb">simpl</span>; <span class="nb">simpl</span> <span class="kr">in</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk58"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk59"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5a"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂ (patt_exists ϕ₁^[svar:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ (S dbi) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5b"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂ (patt_mu ϕ₁^[svar:S dbi↦ϕ₂])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d">case_match; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat dbi dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar dbi
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt;
      patt_bound_svar (Nat.pred dbi)
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ dbi</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (n = dbi) = <span class="nb">right</span> n0</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5e"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat dbi dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar dbi
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt;
      patt_bound_svar (Nat.pred dbi)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk60">case_match; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>dbi = dbi</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>compare_nat dbi dbi = Nat_equal dbi dbi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk61"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>dbi = dbi</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>compare_nat dbi dbi = Nat_equal dbi dbi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ϕ₂ = ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk62">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ dbi</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (n = dbi) = <span class="nb">right</span> n0</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk64"><span class="nb">specialize</span> (IHϕ₁1 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk65"><span class="nb">specialize</span> (IHϕ₁2 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁2 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk66"><span class="nb">move</span>: H H1 IHϕ₁1 IHϕ₁2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true
→ bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true
  → (bsvar_occur ϕ₁1 dbi = true
     → is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂])
    → (bsvar_occur ϕ₁2 dbi = true
       → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂])
      → is_subformula_of_ind ϕ₂
          (patt_app ϕ₁1^[svar:dbi↦ϕ₂]
             ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk67"><span class="nb">case</span>: (bsvar_occur ϕ₁1 dbi); <span class="nb">case</span>: (bsvar_occur ϕ₁2 dbi); <span class="nb">move</span>=&gt; H H1 IHϕ₁₁ IHϕ₁₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk68"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk69"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk6a"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk6b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk6c"><span class="nb">apply</span> sub_app_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk6d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk6e"><span class="nb">apply</span> sub_app_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk6f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk70"><span class="nb">apply</span> sub_app_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk71">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk72">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk73"><span class="nb">specialize</span> (IHϕ₁1 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk74"><span class="nb">specialize</span> (IHϕ₁2 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁2 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk75"><span class="nb">move</span>: H H1 IHϕ₁1 IHϕ₁2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true
→ bsvar_occur ϕ₁1 dbi || bsvar_occur ϕ₁2 dbi = true
  → (bsvar_occur ϕ₁1 dbi = true
     → is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂])
    → (bsvar_occur ϕ₁2 dbi = true
       → is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂])
      → is_subformula_of_ind ϕ₂
          (patt_imp ϕ₁1^[svar:dbi↦ϕ₂]
             ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk76"><span class="nb">case</span>: (bsvar_occur ϕ₁1 dbi); <span class="nb">case</span>: (bsvar_occur ϕ₁2 dbi); <span class="nb">move</span>=&gt; H H1 IHϕ₁₁ IHϕ₁₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk77"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk78"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk79"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk7a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk7b"><span class="nb">apply</span> sub_imp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk7c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk7d"><span class="nb">apply</span> sub_imp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk7e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk7f"><span class="nb">apply</span> sub_imp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk80">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[svar:dbi↦ϕ₂] ϕ₁2^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk81">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ (patt_exists ϕ₁^[svar:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk82"><span class="nb">apply</span> sub_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ (S dbi) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ (patt_mu ϕ₁^[svar:S dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk84"><span class="nb">apply</span> sub_mu.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ (S dbi) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁^[svar:S dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk85"><span class="nb">apply</span> IHϕ₁.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bsvar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ (S dbi) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ₁ (S dbi) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk86"><span class="kn">Lemma</span> <span class="nf">bevar_subst_contains_subformula</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span> :
    bevar_occur ϕ₁ dbi = true -&gt;
    is_subformula_of_ind ϕ₂ (ϕ₁^[<span class="nb">evar</span>: dbi ↦ ϕ₂]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ₁ dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ₁ dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk88"><span class="nb">generalize dependent</span> dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk89"><span class="nb">induction</span> ϕ₁; <span class="nb">intros</span> dbi H; <span class="nb">simpl</span>; <span class="nb">simpl</span> <span class="kr">in</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk8a"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk8b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk8b"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ (S dbi) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk8c"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_exists ϕ₁^[<span class="nb">evar</span>:S dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk8d"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂ (patt_mu ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk8e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk8f">case_match; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat dbi dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar dbi
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt;
      patt_bound_evar (Nat.pred dbi)
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ dbi</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (n = dbi) = <span class="nb">right</span> n0</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk90"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk91">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat dbi dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar dbi
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt;
      patt_bound_evar (Nat.pred dbi)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk92">case_match; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>dbi = dbi</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>compare_nat dbi dbi = Nat_equal dbi dbi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk93"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (dbi = dbi) = <span class="nb">left</span> (erefl dbi)</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>dbi = dbi</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>compare_nat dbi dbi = Nat_equal dbi dbi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ϕ₂ = ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk94">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ dbi</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (n = dbi) = <span class="nb">right</span> n0</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk95">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk96"><span class="nb">specialize</span> (IHϕ₁1 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk97"><span class="nb">specialize</span> (IHϕ₁2 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁2 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk98"><span class="nb">move</span>: H H1 IHϕ₁1 IHϕ₁2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true
→ bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true
  → (bevar_occur ϕ₁1 dbi = true
     → is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂])
    → (bevar_occur ϕ₁2 dbi = true
       → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])
      → is_subformula_of_ind ϕ₂
          (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
             ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk99"><span class="nb">case</span>: (bevar_occur ϕ₁1 dbi); <span class="nb">case</span>: (bevar_occur ϕ₁2 dbi); <span class="nb">move</span>=&gt; H H1 IHϕ₁₁ IHϕ₁₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk9a"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk9b"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk9c"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk9d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk9e"><span class="nb">apply</span> sub_app_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk9f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka0"><span class="nb">apply</span> sub_app_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka2"><span class="nb">apply</span> sub_app_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_app ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁1 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka5"><span class="nb">specialize</span> (IHϕ₁1 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁2 dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka6"><span class="nb">specialize</span> (IHϕ₁2 dbi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁2 dbi = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka7"><span class="nb">move</span>: H H1 IHϕ₁1 IHϕ₁2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true
→ bevar_occur ϕ₁1 dbi || bevar_occur ϕ₁2 dbi = true
  → (bevar_occur ϕ₁1 dbi = true
     → is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂])
    → (bevar_occur ϕ₁2 dbi = true
       → is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])
      → is_subformula_of_ind ϕ₂
          (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
             ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chka8"><span class="nb">case</span>: (bevar_occur ϕ₁1 dbi); <span class="nb">case</span>: (bevar_occur ϕ₁2 dbi); <span class="nb">move</span>=&gt; H H1 IHϕ₁₁ IHϕ₁₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chka9"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkaa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkaa"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkab"><hr></label><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkac">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkad"><span class="nb">apply</span> sub_imp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkae">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkaf"><span class="nb">apply</span> sub_imp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>true || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb1"><span class="nb">apply</span> sub_imp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || true = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>true = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>false || false = true</span></span></span><br><span><var>IHϕ₁₁</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁₂</var><span class="hyp-type"><b>: </b><span>false = true
→ is_subformula_of_ind ϕ₂ ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_imp ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂] ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ (S dbi) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂
  (patt_exists ϕ₁^[<span class="nb">evar</span>:S dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb4"><span class="nb">apply</span> sub_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ (S dbi) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:S dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ (patt_mu ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb6"><span class="nb">apply</span> sub_mu.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb7"><span class="nb">apply</span> IHϕ₁.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  bevar_occur ϕ₁ dbi = true
  → is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H, H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ₁ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb8"><span class="kn">Lemma</span> <span class="nf">free_evars_subformula</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> :
    is_subformula_of_ind ϕ₁ ϕ₂ -&gt; free_evars ϕ₁ ⊆ free_evars ϕ₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ free_evars ϕ₁ ⊆ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkb9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ free_evars ϕ₁ ⊆ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkba"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkbb"><span class="nb">induction</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ϕ₁ = ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkbc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkbc"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_app ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkbd"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_app ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkbe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkbe"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_imp ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkbf"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_imp ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkc0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkc0"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_exists ϕ₂)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkc1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkc1"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_mu ϕ₂)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkc2">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ϕ₁ = ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkc3"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₂ ⊆ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> PreOrder_Reflexive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkc4">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_app ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkc5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkc6"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkc7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkc7"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkc8"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₂ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkc9">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_app ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkca"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkcb"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkcc"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkcd"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₃ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkce">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_imp ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkcf"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd0"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkd1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkd1"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd2"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₂ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd3">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_imp ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd5"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkd6"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd7"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₃ ⊆ free_evars ϕ₂ ∪ free_evars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd8">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_exists ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkd9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkda">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars (patt_mu ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkdb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkdc"><span class="kn">Corollary</span> <span class="nf">evar_fresh_in_subformula</span> <span class="nv">x</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> :
    is_subformula_of_ind ϕ₁ ϕ₂ -&gt;
    evar_is_fresh_in x ϕ₂ -&gt;
    evar_is_fresh_in x ϕ₁.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ evar_is_fresh_in x ϕ₂ → evar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ evar_is_fresh_in x ϕ₂ → evar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkde"><span class="nb">unfold</span> evar_is_fresh_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ x ∉ free_evars ϕ₂ → x ∉ free_evars ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkdf"><span class="nb">intros</span> Hsub Hfresh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_evars ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke0"><span class="nb">apply</span> free_evars_subformula <span class="kr">in</span> Hsub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁ ⊆ free_evars ϕ₂</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_evars ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke1"><span class="kn">Corollary</span> <span class="nf">evar_fresh_in_subformula&#39;</span> <span class="nv">x</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> :
    is_subformula_of ϕ₁ ϕ₂ -&gt;
    evar_is_fresh_in x ϕ₂ -&gt;
    evar_is_fresh_in x ϕ₁.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of ϕ₁ ϕ₂
→ evar_is_fresh_in x ϕ₂ → evar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of ϕ₁ ϕ₂
→ evar_is_fresh_in x ϕ₂ → evar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke3"><span class="nb">intros</span> Hsub Hfr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of ϕ₁ ϕ₂</span></span></span><br><span><var>Hfr</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke4"><span class="nb">pose proof</span> (H := elimT (is_subformula_of_P ϕ₁ ϕ₂) Hsub).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of ϕ₁ ϕ₂</span></span></span><br><span><var>Hfr</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ϕ₂</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke5"><span class="nb">eapply</span> evar_fresh_in_subformula.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of ϕ₁ ϕ₂</span></span></span><br><span><var>Hfr</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ϕ₂</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ <span class="nl">?ϕ₂</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chke6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of ϕ₁ ϕ₂</span></span></span><br><span><var>Hfr</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ϕ₂</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chke6"><hr></label><div class="goal-conclusion">evar_is_fresh_in x <span class="nl">?ϕ₂</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke7"><span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of ϕ₁ ϕ₂</span></span></span><br><span><var>Hfr</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ϕ₂</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke8"><span class="kn">Lemma</span> <span class="nf">free_svars_subformula</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> :
    is_subformula_of_ind ϕ₁ ϕ₂ -&gt; free_svars ϕ₁ ⊆ free_svars ϕ₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ free_svars ϕ₁ ⊆ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chke9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ free_svars ϕ₁ ⊆ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkea"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkeb"><span class="nb">induction</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ϕ₁ = ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkec"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_app ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chked" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chked"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_app ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkee"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_imp ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkef"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_imp ϕ₂ ϕ₃)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkf0"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_exists ϕ₂)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkf1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkf1"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_mu ϕ₂)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf2">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ϕ₁ = ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf3"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₂ ⊆ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> PreOrder_Reflexive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf4">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_app ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf6"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkf7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkf7"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf8"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₂ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkf9">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_app ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkfa"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkfb"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chkfc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chkfc"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkfd"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₃ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkfe">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_imp ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chkff"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk100"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk101" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk101"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk102"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₂ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk103">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_imp ϕ₂ ϕ₃)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk104"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk105"><span class="nb">eapply</span> PreOrder_Transitive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk106" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk106"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk107"><span class="nb">apply</span> IHis_subformula_of_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂, ϕ₃</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₃</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₃</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₃ ⊆ free_svars ϕ₂ ∪ free_svars ϕ₃</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk108">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_exists ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk109"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk10a">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars (patt_mu ϕ₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk10b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>IHis_subformula_of_ind</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk10c"><span class="kn">Corollary</span> <span class="nf">svar_fresh_in_subformula</span> <span class="nv">x</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> :
    is_subformula_of_ind ϕ₁ ϕ₂ -&gt;
    svar_is_fresh_in x ϕ₂ -&gt;
    svar_is_fresh_in x ϕ₁.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ svar_is_fresh_in x ϕ₂ → svar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk10d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ svar_is_fresh_in x ϕ₂ → svar_is_fresh_in x ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk10e"><span class="nb">unfold</span> svar_is_fresh_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₁ ϕ₂
→ x ∉ free_svars ϕ₂ → x ∉ free_svars ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk10f"><span class="nb">intros</span> Hsub Hfresh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₁ ϕ₂</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x ∉ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_svars ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk110"><span class="nb">apply</span> free_svars_subformula <span class="kr">in</span> Hsub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁ ⊆ free_svars ϕ₂</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x ∉ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_svars ϕ₁</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk111"><span class="kn">Lemma</span> <span class="nf">free_evars_bsvar_subst</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span>:
    free_evars (ϕ₁^[svar: dbi ↦ ϕ₂]) ⊆ free_evars ϕ₁ ∪ free_evars ϕ₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁^[svar:dbi↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁^[svar:dbi↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk113"><span class="nb">generalize dependent</span> dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk114"><span class="nb">induction</span> ϕ₁; <span class="nb">intros</span> db; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[x]} ⊆ {[x]} ∪ free_evars ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk115" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk115"><hr></label><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk116"><hr></label><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk117"><hr></label><div class="goal-conclusion">free_evars
  <span class="kr">match</span> compare_nat n db <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span> ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>sigma</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk118"><hr></label><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk119"><hr></label><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk11a"><hr></label><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk11b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk11b"><hr></label><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk11c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk11c"><hr></label><div class="goal-conclusion">free_evars ϕ₁^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk11d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk11d"><hr></label><div class="goal-conclusion">free_evars ϕ₁^[svar:S db↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[x]} ⊆ {[x]} ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk11f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk120">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk121">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars
  <span class="kr">match</span> compare_nat n db <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span> ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk122">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>sigma</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk123">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk124"><span class="nb">specialize</span> (IHϕ₁1 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁1^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk125"><span class="nb">specialize</span> (IHϕ₁2 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁1^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk126"><span class="nb">remember</span> (free_evars (ϕ₁1^[svar: db ↦ ϕ₂])) <span class="kr">as</span> A1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk127"><span class="nb">remember</span> (free_evars (ϕ₁2^[svar: db ↦ ϕ₂])) <span class="kr">as</span> A2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk128"><span class="nb">remember</span> (free_evars ϕ₁1) <span class="kr">as</span> B1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_evars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk129"><span class="nb">remember</span> (free_evars ϕ₁2) <span class="kr">as</span> B2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_evars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk12a"><span class="nb">remember</span> (free_evars ϕ₂) <span class="kr">as</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk12b"><span class="nb">rewrite</span> &lt;- union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk12c"><span class="nb">rewrite</span> {<span class="mi">1</span>}[B2 ∪ C]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk12d"><span class="nb">rewrite</span> -{<span class="mi">1</span>}[C]union_idemp_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk12e"><span class="nb">rewrite</span> -[C ∪ C ∪ B2]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ (C ∪ B2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk12f"><span class="nb">rewrite</span> [B1 ∪ _]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk130"><span class="nb">rewrite</span> [C ∪ B2]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk131">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk132">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk133"><span class="nb">specialize</span> (IHϕ₁1 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁1^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk134"><span class="nb">specialize</span> (IHϕ₁2 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁1^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1^[svar:db↦ϕ₂]
∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk135"><span class="nb">remember</span> (free_evars (ϕ₁1^[svar: db ↦ ϕ₂])) <span class="kr">as</span> A1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ free_evars ϕ₁2^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk136"><span class="nb">remember</span> (free_evars (ϕ₁2^[svar: db ↦ ϕ₂])) <span class="kr">as</span> A2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_evars ϕ₁1 ∪ free_evars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2
⊆ free_evars ϕ₁1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk137"><span class="nb">remember</span> (free_evars ϕ₁1) <span class="kr">as</span> B1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_evars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_evars ϕ₁2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ free_evars ϕ₁2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk138"><span class="nb">remember</span> (free_evars ϕ₁2) <span class="kr">as</span> B2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_evars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ free_evars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk139"><span class="nb">remember</span> (free_evars ϕ₂) <span class="kr">as</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk13a"><span class="nb">rewrite</span> &lt;- union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk13b"><span class="nb">rewrite</span> {<span class="mi">1</span>}[B2 ∪ C]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk13c"><span class="nb">rewrite</span> -{<span class="mi">1</span>}[C]union_idemp_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk13d"><span class="nb">rewrite</span> -[C ∪ C ∪ B2]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ (C ∪ B2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk13e"><span class="nb">rewrite</span> [B1 ∪ _]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk13f"><span class="nb">rewrite</span> [C ∪ B2]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_evars ϕ₁1^[svar:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_evars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_evars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_evars ϕ₁2^[svar:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>EVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_evars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk140">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁^[svar:db↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk141">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁^[svar:dbi↦ϕ₂]
  ⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁^[svar:S db↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk142"><span class="kn">Lemma</span> <span class="nf">free_svars_bevar_subst</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span>:
    free_svars (ϕ₁^[<span class="nb">evar</span>: dbi ↦ ϕ₂]) ⊆ free_svars ϕ₁ ∪ free_svars ϕ₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk143"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk144"><span class="nb">generalize dependent</span> dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk145"><span class="nb">induction</span> ϕ₁; <span class="nb">intros</span> db; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk146" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk146"><hr></label><div class="goal-conclusion">{[x]} ⊆ {[x]} ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk147" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk147"><hr></label><div class="goal-conclusion">free_svars
  <span class="kr">match</span> compare_nat n db <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk148" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk148"><hr></label><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk149" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>sigma</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk149"><hr></label><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk14a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk14a"><hr></label><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk14b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk14b"><hr></label><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk14c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk14c"><hr></label><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk14d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk14d"><hr></label><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:S db↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk14e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk14e"><hr></label><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk14f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk150">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[x]} ⊆ {[x]} ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_subseteq_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk151">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars
  <span class="kr">match</span> compare_nat n db <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ϕ₂
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk152">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk153">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>sigma</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk154">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk155"><span class="nb">specialize</span> (IHϕ₁1 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk156"><span class="nb">specialize</span> (IHϕ₁2 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk157"><span class="nb">remember</span> (free_svars (ϕ₁1^[<span class="nb">evar</span>: db ↦ ϕ₂])) <span class="kr">as</span> A1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk158"><span class="nb">remember</span> (free_svars (ϕ₁2^[<span class="nb">evar</span>: db ↦ ϕ₂])) <span class="kr">as</span> A2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk159"><span class="nb">remember</span> (free_svars ϕ₁1) <span class="kr">as</span> B1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_svars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk15a"><span class="nb">remember</span> (free_svars ϕ₁2) <span class="kr">as</span> B2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_svars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk15b"><span class="nb">remember</span> (free_svars ϕ₂) <span class="kr">as</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk15c"><span class="nb">rewrite</span> &lt;- union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk15d"><span class="nb">rewrite</span> {<span class="mi">1</span>}[B2 ∪ C]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk15e"><span class="nb">rewrite</span> -{<span class="mi">1</span>}[C]union_idemp_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk15f"><span class="nb">rewrite</span> -[C ∪ C ∪ B2]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ (C ∪ B2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk160"><span class="nb">rewrite</span> [B1 ∪ _]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk161"><span class="nb">rewrite</span> [C ∪ B2]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk162">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ ∅ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk163">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk164"><span class="nb">specialize</span> (IHϕ₁1 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk165"><span class="nb">specialize</span> (IHϕ₁2 db).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]
∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk166"><span class="nb">remember</span> (free_svars (ϕ₁1^[<span class="nb">evar</span>: db ↦ ϕ₂])) <span class="kr">as</span> A1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk167"><span class="nb">remember</span> (free_svars (ϕ₁2^[<span class="nb">evar</span>: db ↦ ϕ₂])) <span class="kr">as</span> A2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ free_svars ϕ₁1 ∪ free_svars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2
⊆ free_svars ϕ₁1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk168"><span class="nb">remember</span> (free_svars ϕ₁1) <span class="kr">as</span> B1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_svars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ free_svars ϕ₁2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ free_svars ϕ₁2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk169"><span class="nb">remember</span> (free_svars ϕ₁2) <span class="kr">as</span> B2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ free_svars ϕ₂</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ free_svars ϕ₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk16a"><span class="nb">remember</span> (free_svars ϕ₂) <span class="kr">as</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ B2 ∪ C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk16b"><span class="nb">rewrite</span> &lt;- union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk16c"><span class="nb">rewrite</span> {<span class="mi">1</span>}[B2 ∪ C]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk16d"><span class="nb">rewrite</span> -{<span class="mi">1</span>}[C]union_idemp_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk16e"><span class="nb">rewrite</span> -[C ∪ C ∪ B2]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ (C ∪ (C ∪ B2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk16f"><span class="nb">rewrite</span> [B1 ∪ _]union_assoc_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (C ∪ B2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk170"><span class="nb">rewrite</span> [C ∪ B2]union_comm_L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>A1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA1</var><span class="hyp-type"><b>: </b><span>A1 = free_svars ϕ₁1^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B1</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB1</var><span class="hyp-type"><b>: </b><span>B1 = free_svars ϕ₁1</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqC</var><span class="hyp-type"><b>: </b><span>C = free_svars ϕ₂</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span>A1 ⊆ B1 ∪ C</span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqA2</var><span class="hyp-type"><b>: </b><span>A2 = free_svars ϕ₁2^[<span class="nb">evar</span>:db↦ϕ₂]</span></span></span><br><span><var>B2</var><span class="hyp-type"><b>: </b><span>SVarSet</span></span></span><br><span><var>HeqB2</var><span class="hyp-type"><b>: </b><span>B2 = free_svars ϕ₁2</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span>A2 ⊆ B2 ∪ C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A1 ∪ A2 ⊆ B1 ∪ C ∪ (B2 ∪ C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk171">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:S db↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk172">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:db↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk173"><span class="kn">Lemma</span> <span class="nf">free_evars_bsvar_subst_1</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span>:
    free_evars ϕ₁ ⊆ free_evars (ϕ₁^[svar: dbi ↦ ϕ₂]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk174"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk175"><span class="nb">generalize dependent</span> dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk176"><span class="nb">induction</span> ϕ₁; <span class="nb">intros</span> dbi; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="nb">apply</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅
⊆ free_evars
    <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
    | Nat_less _ _ _ =&gt; patt_bound_svar n
    | Nat_equal _ _ _ =&gt; ϕ₂
    | Nat_greater _ _ _ =&gt;
        patt_bound_svar (Nat.pred n)
    <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk177" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1
  ⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2
  ⊆ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk177"><hr></label><div class="goal-conclusion">free_evars ϕ₁1 ∪ free_evars ϕ₁2
⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ∪ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk178" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1
  ⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2
  ⊆ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk178"><hr></label><div class="goal-conclusion">free_evars ϕ₁1 ∪ free_evars ϕ₁2
⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ∪ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk179" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk179"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk17a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk17a"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:S dbi↦ϕ₂]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk17b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅
⊆ free_evars
    <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
    | Nat_less _ _ _ =&gt; patt_bound_svar n
    | Nat_equal _ _ _ =&gt; ϕ₂
    | Nat_greater _ _ _ =&gt;
        patt_bound_svar (Nat.pred n)
    <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk17c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1
  ⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2
  ⊆ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1 ∪ free_evars ϕ₁2
⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ∪ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk17d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁1
  ⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁2
  ⊆ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁1 ∪ free_evars ϕ₁2
⊆ free_evars ϕ₁1^[svar:dbi↦ϕ₂]
  ∪ free_evars ϕ₁2^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk17e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk17f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:S dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk180"><span class="kn">Lemma</span> <span class="nf">free_svars_bevar_subst_1</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span>:
    free_svars ϕ₁ ⊆ free_svars (ϕ₁^[<span class="nb">evar</span>: dbi ↦ ϕ₂]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk181"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk182"><span class="nb">generalize dependent</span> dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk183"><span class="nb">induction</span> ϕ₁; <span class="nb">intros</span> dbi; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="nb">apply</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅
⊆ free_svars
    <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
    | Nat_less _ _ _ =&gt; patt_bound_evar n
    | Nat_equal _ _ _ =&gt; ϕ₂
    | Nat_greater _ _ _ =&gt;
        patt_bound_evar (Nat.pred n)
    <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk184" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1
  ⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2
  ⊆ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk184"><hr></label><div class="goal-conclusion">free_svars ϕ₁1 ∪ free_svars ϕ₁2
⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ∪ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk185" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1
  ⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2
  ⊆ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk185"><hr></label><div class="goal-conclusion">free_svars ϕ₁1 ∪ free_svars ϕ₁2
⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ∪ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk186" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk186"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:S dbi↦ϕ₂]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk187" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk187"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk188">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅
⊆ free_svars
    <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
    | Nat_less _ _ _ =&gt; patt_bound_evar n
    | Nat_equal _ _ _ =&gt; ϕ₂
    | Nat_greater _ _ _ =&gt;
        patt_bound_evar (Nat.pred n)
    <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> empty_subseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk189">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1
  ⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2
  ⊆ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1 ∪ free_svars ϕ₁2
⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ∪ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk18a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁1, ϕ₁2, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁1
  ⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>IHϕ₁2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁2
  ⊆ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁1 ∪ free_svars ϕ₁2
⊆ free_svars ϕ₁1^[<span class="nb">evar</span>:dbi↦ϕ₂]
  ∪ free_svars ϕ₁2^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> union_mono; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk18b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:S dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk18c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ₁</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk18d"><span class="kn">Corollary</span> <span class="nf">free_evars_bsvar_subst_eq</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span>:
    bsvar_occur ϕ₁ dbi -&gt;
    free_evars (ϕ₁^[svar: dbi ↦ ϕ₂]) = free_evars ϕ₁ ∪ free_evars ϕ₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ₁ dbi
→ free_evars ϕ₁^[svar:dbi↦ϕ₂] =
  free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk18e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ₁ dbi
→ free_evars ϕ₁^[svar:dbi↦ϕ₂] =
  free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk18f"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁^[svar:dbi↦ϕ₂] =
free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk190"><span class="nb">apply</span> (anti_symm subseteq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁^[svar:dbi↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk191" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk191"><hr></label><div class="goal-conclusion">free_evars ϕ₁ ∪ free_evars ϕ₂
⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk192">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁^[svar:dbi↦ϕ₂]
⊆ free_evars ϕ₁ ∪ free_evars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> free_evars_bsvar_subst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk193">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ∪ free_evars ϕ₂
⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk194"><span class="nb">apply</span> union_least.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk195" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk195"><hr></label><div class="goal-conclusion">free_evars ϕ₂ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk196">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₁ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> free_evars_bsvar_subst_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk197">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₂ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk198"><span class="nb">pose proof</span> (Hsub := bsvar_subst_contains_subformula ϕ₁ ϕ₂ dbi H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_evars ϕ₂ ⊆ free_evars ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk199"><span class="nb">apply</span> free_evars_subformula.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ₁ dbi</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁^[svar:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk19a"><span class="kn">Corollary</span> <span class="nf">free_svars_bevar_subst_eq</span> <span class="nv">ϕ₁</span> <span class="nv">ϕ₂</span> <span class="nv">dbi</span>:
    bevar_occur ϕ₁ dbi -&gt;
    free_svars (ϕ₁^[<span class="nb">evar</span>: dbi ↦ ϕ₂]) = free_svars ϕ₁ ∪ free_svars ϕ₂.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ₁ dbi
→ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂] =
  free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk19b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ₁ dbi
→ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂] =
  free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk19c"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂] =
free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk19d"><span class="nb">apply</span> (anti_symm subseteq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk19e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk19e"><hr></label><div class="goal-conclusion">free_svars ϕ₁ ∪ free_svars ϕ₂
⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk19f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]
⊆ free_svars ϕ₁ ∪ free_svars ϕ₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> free_svars_bevar_subst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ∪ free_svars ϕ₂
⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a1"><span class="nb">apply</span> union_least.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1a2"><hr></label><div class="goal-conclusion">free_svars ϕ₂ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₁ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> free_svars_bevar_subst_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₂ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a5"><span class="nb">pose proof</span> (Hsub := bevar_subst_contains_subformula ϕ₁ ϕ₂ dbi H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_svars ϕ₂ ⊆ free_svars ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a6"><span class="nb">apply</span> free_svars_subformula.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ₁, ϕ₂</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ₁ dbi</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_subformula_of_ind ϕ₂ ϕ₁^[<span class="nb">evar</span>:dbi↦ϕ₂]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a7"><span class="kn">Lemma</span> <span class="nf">wfc_mu_aux_implies_not_bsvar_occur</span> <span class="nv">phi</span> <span class="nv">ns</span> :
    well_formed_closed_mu_aux phi ns -&gt;
    bsvar_occur phi ns = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi ns
→ bsvar_occur phi ns = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi ns
→ bsvar_occur phi ns = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1a9"><span class="nb">move</span>: ns.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi ns
  → bsvar_occur phi ns = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1aa"><span class="nb">induction</span> phi; <span class="nb">intros</span> ns Hwfc; <span class="nb">simpl</span>; <span class="nb">simpl</span> <span class="kr">in</span> Hwfc; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n &lt; ns) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n = ns) <span class="kr">then</span> true <span class="kr">else</span> false) = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns &amp;&amp;
well_formed_closed_mu_aux phi2 ns</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ab"><hr></label><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns &amp;&amp;
well_formed_closed_mu_aux phi2 ns</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ac"><hr></label><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1ad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n &lt; ns) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n = ns) <span class="kr">then</span> true <span class="kr">else</span> false) = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1ae"><span class="kp">repeat</span> case_match; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ n &lt; ns</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (n &lt; ns) = <span class="nb">right</span> n0</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>false</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = ns</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (n = ns) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1af">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns &amp;&amp;
well_formed_closed_mu_aux phi2 ns</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1b0"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> Hwfc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true
∧ well_formed_closed_mu_aux phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1b1"><span class="nb">destruct</span> Hwfc <span class="kr">as</span> [Hwfc1 Hwfc2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1b2"><span class="nb">destruct</span> (bsvar_occur phi1 ns) <span class="nb">eqn</span>:Heq1, (bsvar_occur phi2 ns) <span class="nb">eqn</span>:Heq2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1b3"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1b4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1b4"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1b5"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1b6"><span class="nb">rewrite</span> IHphi1 <span class="kr">in</span> Heq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi1 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1b7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1b7"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1b8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1b8"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1b9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1b9"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ba"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1bb"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1bc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1bc"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1bd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1bd"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1be"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1bf"><span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1c0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1c0"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1c1"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1c2"><span class="nb">rewrite</span> IHphi1 <span class="kr">in</span> Heq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi1 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1c3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1c3"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1c4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1c4"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1c5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1c5"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1c6"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1c7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1c7"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1c8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1c8"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1c9"><span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ca"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1cb"><span class="nb">rewrite</span> IHphi2 <span class="kr">in</span> Heq2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi2 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1cc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1cc"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1cd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1cd"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1ce"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1cf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1cf"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d0"><span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d1"><span class="nb">rewrite</span> IHphi2 <span class="kr">in</span> Heq2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi2 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1d2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1d2"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d3"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns &amp;&amp;
well_formed_closed_mu_aux phi2 ns</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d5"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> Hwfc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true
∧ well_formed_closed_mu_aux phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d6"><span class="nb">destruct</span> Hwfc <span class="kr">as</span> [Hwfc1 Hwfc2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur phi1 ns || bsvar_occur phi2 ns = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1d7"><span class="nb">destruct</span> (bsvar_occur phi1 ns) <span class="nb">eqn</span>:Heq1, (bsvar_occur phi2 ns) <span class="nb">eqn</span>:Heq2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1d8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1d8"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1d9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1d9"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1da" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1da"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1db"><span class="nb">rewrite</span> IHphi1 <span class="kr">in</span> Heq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi1 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1dc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1dc"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1dd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1dd"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1de" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1de"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1df" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1df"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1e0"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1e1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1e1"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1e2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1e2"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1e3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1e3"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1e4"><span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1e5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1e5"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1e6"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1e7"><span class="nb">rewrite</span> IHphi1 <span class="kr">in</span> Heq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi1 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1e8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1e8"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1e9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1e9"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ea"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1eb"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ec"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ed" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ed"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1ee"><span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1ef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1ef"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1f0"><span class="nb">rewrite</span> IHphi2 <span class="kr">in</span> Heq2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi2 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1f1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1f1"><hr></label><div class="goal-conclusion">true = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1f2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1f2"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1f3"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1f4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1f4"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1f5"><span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1f6"><span class="nb">rewrite</span> IHphi2 <span class="kr">in</span> Heq2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi2 ns</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1f7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1f7"><hr></label><div class="goal-conclusion">false = false</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1f8"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi1 ns
  → bsvar_occur phi1 ns = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ns</span> : db_index,
  well_formed_closed_mu_aux phi2 ns
  → bsvar_occur phi2 ns = false</span></span></span><br><span><var>ns</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi1 ns = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi2 ns = true</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 ns = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1f9"><span class="kn">Lemma</span> <span class="nf">wfc_ex_aux_implies_not_bevar_occur</span> <span class="nv">phi</span> <span class="nv">ne</span> :
    well_formed_closed_ex_aux phi ne -&gt;
    bevar_occur phi ne = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi ne
→ bevar_occur phi ne = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1fa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi ne
→ bevar_occur phi ne = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1fb"><span class="nb">move</span>: ne.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi ne
  → bevar_occur phi ne = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1fc"><span class="nb">induction</span> phi; <span class="nb">intros</span> ne Hwfc; <span class="nb">simpl</span>; <span class="nb">simpl</span> <span class="kr">in</span> Hwfc; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n &lt; ne) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n = ne) <span class="kr">then</span> true <span class="kr">else</span> false) = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1fd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne &amp;&amp;
well_formed_closed_ex_aux phi2 ne</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1fd"><hr></label><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk1fe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne &amp;&amp;
well_formed_closed_ex_aux phi2 ne</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk1fe"><hr></label><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk1ff">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n &lt; ne) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n = ne) <span class="kr">then</span> true <span class="kr">else</span> false) = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk200"><span class="nb">apply</span> bool_decide_eq_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n &lt; ne) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n ≠ ne</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">case_match;[<span class="bp">lia</span>|<span class="bp">congruence</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk201">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne &amp;&amp;
well_formed_closed_ex_aux phi2 ne</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk202"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> Hwfc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne = true
∧ well_formed_closed_ex_aux phi2 ne = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk203"><span class="nb">destruct</span> Hwfc <span class="kr">as</span> [Hwfc1 Hwfc2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi2 ne = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">erewrite</span> IHphi1; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk204">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne &amp;&amp;
well_formed_closed_ex_aux phi2 ne</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk205"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> Hwfc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne = true
∧ well_formed_closed_ex_aux phi2 ne = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk206"><span class="nb">destruct</span> Hwfc <span class="kr">as</span> [Hwfc1 Hwfc2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi1 ne
  → bevar_occur phi1 ne = false</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">ne</span> : db_index,
  well_formed_closed_ex_aux phi2 ne
  → bevar_occur phi2 ne = false</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwfc1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi1 ne = true</span></span></span><br><span><var>Hwfc2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi2 ne = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur phi1 ne || bevar_occur phi2 ne = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">erewrite</span> IHphi1, IHphi2; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk207"><span class="kn">Corollary</span> <span class="nf">wfc_mu_implies_not_bsvar_occur</span> <span class="nv">phi</span> <span class="nv">n</span> :
    well_formed_closed_mu_aux phi <span class="mi">0</span> -&gt;
    ~ bsvar_occur phi n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi <span class="mi">0</span> → ¬ bsvar_occur phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk208"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi <span class="mi">0</span> → ¬ bsvar_occur phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk209"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk20a"><span class="nb">erewrite</span> wfc_mu_aux_implies_not_bsvar_occur.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk20b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk20b"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux phi n</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk20c"><span class="bp">exact</span> notF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk20d"><span class="nb">unfold</span> well_formed_closed <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk20e"><span class="nb">eapply</span> well_formed_closed_mu_aux_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?ind_svar1</span> ≤ n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk20f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk20f"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux phi <span class="nl">?ind_svar1</span> = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk210"><span class="mi">2</span>: <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ≤ n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk211"><span class="kn">Lemma</span> <span class="nf">wfc_ex_implies_not_bevar_occur</span> <span class="nv">phi</span> <span class="nv">n</span> :
    well_formed_closed_ex_aux phi <span class="mi">0</span> -&gt;
    bevar_occur phi n = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi <span class="mi">0</span>
→ bevar_occur phi n = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk212"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi <span class="mi">0</span>
→ bevar_occur phi n = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk213"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur phi n = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk214"><span class="nb">erewrite</span> wfc_ex_aux_implies_not_bevar_occur.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk215" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk215"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux phi n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk216">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk217">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux phi n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk218"><span class="nb">eapply</span> well_formed_closed_ex_aux_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?ind_evar1</span> ≤ n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk219" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk219"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux phi <span class="nl">?ind_evar1</span> = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk21a"><span class="mi">2</span>: <span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux phi <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ≤ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk21b"><span class="kn">Lemma</span> <span class="nf">not_bsvar_occur_bsvar_subst</span> <span class="nv">phi</span> <span class="nv">psi</span> <span class="nv">n</span>:
    well_formed_closed_mu_aux psi <span class="mi">0</span> -&gt; well_formed_closed_mu_aux phi n -&gt;
    ~ bsvar_occur (phi^[svar: n ↦ psi]) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux psi <span class="mi">0</span>
→ well_formed_closed_mu_aux phi n
  → ¬ bsvar_occur phi^[svar:n↦psi] n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk21c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux psi <span class="mi">0</span>
→ well_formed_closed_mu_aux phi n
  → ¬ bsvar_occur phi^[svar:n↦psi] n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk21d"><span class="nb">move</span>: n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi n
    → ¬ bsvar_occur phi^[svar:n↦psi] n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk21e"><span class="nb">induction</span> phi; <span class="nb">intros</span> n&#39; H H0; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur
    <span class="kr">match</span> compare_nat n n&#39; <span class="kr">with</span>
    | Nat_less _ _ _ =&gt; patt_bound_svar n
    | Nat_equal _ _ _ =&gt; psi
    | Nat_greater _ _ _ =&gt;
        patt_bound_svar (Nat.pred n)
    <span class="kr">end</span> n&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk21f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk21f"><hr></label><div class="goal-conclusion">¬ bsvar_occur phi1^[svar:n&#39;↦psi] n&#39;
  || bsvar_occur phi2^[svar:n&#39;↦psi] n&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk220" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk220"><hr></label><div class="goal-conclusion">¬ bsvar_occur phi1^[svar:n&#39;↦psi] n&#39;
  || bsvar_occur phi2^[svar:n&#39;↦psi] n&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk221">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur
    <span class="kr">match</span> compare_nat n n&#39; <span class="kr">with</span>
    | Nat_less _ _ _ =&gt; patt_bound_svar n
    | Nat_equal _ _ _ =&gt; psi
    | Nat_greater _ _ _ =&gt;
        patt_bound_svar (Nat.pred n)
    <span class="kr">end</span> n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk222"><span class="nb">intros</span> Hcontra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur
  <span class="kr">match</span> compare_nat n n&#39; <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; psi
  | Nat_greater _ _ _ =&gt;
      patt_bound_svar (Nat.pred n)
  <span class="kr">end</span> n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk223">case_match.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur (patt_bound_svar n) n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk224" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_equal n n&#39; e</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur psi n&#39;</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk224"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk225" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur (patt_bound_svar (Nat.pred n))
  n&#39;</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk225"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk226">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur (patt_bound_svar n) n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk227"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur (patt_bound_svar n) n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk228"><span class="nb">simpl</span> <span class="kr">in</span> Hcontra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk229">case_match.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n = n&#39;) = <span class="nb">left</span> e</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk22a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n = n&#39;) = <span class="nb">right</span> n0</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk22a"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk22b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n = n&#39;) = <span class="nb">left</span> e</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk22c">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_less n n&#39; l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n = n&#39;) = <span class="nb">right</span> n0</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk22d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_equal n n&#39; e</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur psi n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk22e"><span class="nb">apply</span> wfc_mu_implies_not_bsvar_occur <span class="kr">with</span> (n := n&#39;) <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur psi n&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_equal n n&#39; e</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur psi n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk22f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur (patt_bound_svar (Nat.pred n))
  n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk230"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur (patt_bound_svar (Nat.pred n))
  n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk231"><span class="nb">simpl</span> <span class="kr">in</span> Hcontra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (Nat.pred n = n&#39;)
<span class="kr">then</span> true
<span class="kr">else</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk232"><span class="nb">inversion</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (Nat.pred n = n&#39;)
<span class="kr">then</span> true
<span class="kr">else</span> false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n &lt; n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk233">case_match.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (Nat.pred n = n&#39;)
<span class="kr">then</span> true
<span class="kr">else</span> false</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n &lt; n&#39;) = <span class="nb">left</span> l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk234" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (Nat.pred n = n&#39;)
<span class="kr">then</span> true
<span class="kr">else</span> false</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ n &lt; n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n &lt; n&#39;) = <span class="nb">right</span> n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk234"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk235">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (Nat.pred n = n&#39;)
<span class="kr">then</span> true
<span class="kr">else</span> false</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n &lt; n&#39;) = <span class="nb">left</span> l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk236">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) n&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; n&#39;</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>compare_nat n n&#39; = Nat_greater n n&#39; g</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (Nat.pred n = n&#39;)
<span class="kr">then</span> true
<span class="kr">else</span> false</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ n &lt; n&#39;</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>decide (n &lt; n&#39;) = <span class="nb">right</span> n0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk237">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi1^[svar:n&#39;↦psi] n&#39;
  || bsvar_occur phi2^[svar:n&#39;↦psi] n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk238"><span class="nb">intros</span> Hcontra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39;
|| bsvar_occur phi2^[svar:n&#39;↦psi] n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk239"><span class="nb">destruct</span> (bsvar_occur (phi1^[svar: n&#39; ↦ psi]) n&#39;) <span class="nb">eqn</span>:Heq1, (bsvar_occur (phi2^[svar: n&#39; ↦ psi]) n&#39;) <span class="nb">eqn</span>:Heq2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk23a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk23a"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk23b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk23b"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk23c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk23c"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk23d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk23e"><span class="nb">eapply</span> IHphi2; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi2 n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk23f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk240"><span class="nb">eapply</span> IHphi1; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi1 n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk241">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk242"><span class="nb">eapply</span> IHphi2; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi2 n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk243">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk244"><span class="nb">simpl</span> <span class="kr">in</span> Hcontra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk245">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi1^[svar:n&#39;↦psi] n&#39;
  || bsvar_occur phi2^[svar:n&#39;↦psi] n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk246"><span class="nb">intros</span> Hcontra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39;
|| bsvar_occur phi2^[svar:n&#39;↦psi] n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk247"><span class="nb">destruct</span> (bsvar_occur ((phi1^[svar: n&#39; ↦ psi])) n&#39;)
               <span class="nb">eqn</span>:Heq1, (bsvar_occur ((phi2^[svar: n&#39; ↦ psi])) n&#39;) <span class="nb">eqn</span>:Heq2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk248" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk248"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk249" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk249"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk24a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk24a"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk24b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk24c"><span class="nb">eapply</span> IHphi1; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi1 n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk24d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk24e"><span class="nb">eapply</span> IHphi1; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>true || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi1 n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk24f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk250"><span class="nb">eapply</span> IHphi2; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = true</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux phi2 n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk251">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk252"><span class="nb">simpl</span> <span class="kr">in</span> Hcontra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2, psi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi1 n
    → ¬ bsvar_occur phi1^[svar:n↦psi] n</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_closed_mu_aux psi <span class="mi">0</span>
  → well_formed_closed_mu_aux phi2 n
    → ¬ bsvar_occur phi2^[svar:n↦psi] n</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux psi <span class="mi">0</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp phi1 phi2) n&#39;</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2^[svar:n&#39;↦psi] n&#39; = false</span></span></span><br><span><var>Hcontra</var><span class="hyp-type"><b>: </b><span>false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk253"><span class="kn">Lemma</span> <span class="nf">not_bsvar_occur_impl_no_neg_occ_and_no_pos_occ</span> <span class="nv">phi</span> <span class="nv">n</span>:
    ~ bsvar_occur phi n -&gt;
    no_negative_occurrence_db_b n phi &amp;&amp; no_positive_occurrence_db_b n phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi n
→ no_negative_occurrence_db_b n phi &amp;&amp;
  no_positive_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk254"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi n
→ no_negative_occurrence_db_b n phi &amp;&amp;
  no_positive_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk255"><span class="nb">move</span>: n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi n
  → no_negative_occurrence_db_b n phi &amp;&amp;
    no_positive_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk256"><span class="nb">induction</span> phi; <span class="nb">intros</span> n&#39; H; <span class="nb">simpl</span>; <span class="nb">simpl</span> <span class="kr">in</span> H; <span class="nb">cbn</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ (<span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> false <span class="kr">else</span> true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk257" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi1 n
  → no_negative_occurrence_db_b n phi1 &amp;&amp;
    no_positive_occurrence_db_b n phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39; || bsvar_occur phi2 n&#39;</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk257"><hr></label><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk258" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi1 n
  → no_negative_occurrence_db_b n phi1 &amp;&amp;
    no_positive_occurrence_db_b n phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39; || bsvar_occur phi2 n&#39;</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk258"><hr></label><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk259">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ (<span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> false <span class="kr">else</span> true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk25a"><span class="nb">unfold</span> not <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) → <span class="kt">False</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> false <span class="kr">else</span> true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk25b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi1 n
  → no_negative_occurrence_db_b n phi1 &amp;&amp;
    no_positive_occurrence_db_b n phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39; || bsvar_occur phi2 n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk25c"><span class="nb">destruct</span> (bsvar_occur phi1 n&#39;) <span class="nb">eqn</span>: Heq3;
        <span class="nb">destruct</span> (bsvar_occur phi2 n&#39;) <span class="nb">eqn</span>:Heq4;
        <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi1 n
  → no_negative_occurrence_db_b n phi1 &amp;&amp;
    no_positive_occurrence_db_b n phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk25d"><span class="nb">specialize</span> (IHphi1 n&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39;
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk25e"><span class="nb">specialize</span> (IHphi2 n&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39;
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi2 n&#39;
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk25f"><span class="nb">rewrite</span> Heq3 <span class="kr">in</span> IHphi1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi2 n&#39;
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk260"><span class="nb">rewrite</span> Heq4 <span class="kr">in</span> IHphi2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk261"><span class="nb">clear</span> Heq3 Heq4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk262"><span class="nb">specialize</span> (IHphi1 ssrbool.not_false_is_true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk263"><span class="nb">specialize</span> (IHphi2 ssrbool.not_false_is_true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk264"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> IHphi1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true
∧ no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk265"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> IHphi2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true
∧ no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true
∧ no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk266"><span class="nb">destruct</span> IHphi1 <span class="kr">as</span> [H1n H1p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true
∧ no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk267"><span class="nb">destruct</span> IHphi2 <span class="kr">as</span> [H2n H2p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk268"><span class="nb">rewrite</span> H1n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; true &amp;&amp; no_negative_occurrence_db_b n&#39; phi2,
    no_positive_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk269"><span class="nb">rewrite</span> H1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; true &amp;&amp; no_negative_occurrence_db_b n&#39; phi2, true
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk26a"><span class="nb">rewrite</span> H2n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; true &amp;&amp; true, true
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk26b"><span class="nb">rewrite</span> H2p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; true &amp;&amp; true, true &amp; true]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk26c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk26d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi1 n
  → no_negative_occurrence_db_b n phi1 &amp;&amp;
    no_positive_occurrence_db_b n phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39; || bsvar_occur phi2 n&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk26e"><span class="nb">destruct</span> (bsvar_occur phi1 n&#39;) <span class="nb">eqn</span>: Heq3;
        <span class="nb">destruct</span> (bsvar_occur phi2 n&#39;) <span class="nb">eqn</span>:Heq4;
        <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi1 n
  → no_negative_occurrence_db_b n phi1 &amp;&amp;
    no_positive_occurrence_db_b n phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk26f"><span class="nb">specialize</span> (IHphi1 n&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39;
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ¬ bsvar_occur phi2 n
  → no_negative_occurrence_db_b n phi2 &amp;&amp;
    no_positive_occurrence_db_b n phi2</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk270"><span class="nb">specialize</span> (IHphi2 n&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi1 n&#39;
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi2 n&#39;
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk271"><span class="nb">rewrite</span> Heq3 <span class="kr">in</span> IHphi1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi2 n&#39;
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk272"><span class="nb">rewrite</span> Heq4 <span class="kr">in</span> IHphi2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Heq3</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi1 n&#39; = false</span></span></span><br><span><var>Heq4</var><span class="hyp-type"><b>: </b><span>bsvar_occur phi2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk273"><span class="nb">clear</span> Heq3 Heq4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk274"><span class="nb">specialize</span> (IHphi1 ssrbool.not_false_is_true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>¬ false
→ no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
  no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk275"><span class="nb">specialize</span> (IHphi2 ssrbool.not_false_is_true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi1</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk276"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> IHphi1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true
∧ no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 &amp;&amp;
no_positive_occurrence_db_b n&#39; phi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk277"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> IHphi2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>IHphi1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true
∧ no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true
∧ no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk278"><span class="nb">destruct</span> IHphi1 <span class="kr">as</span> [H1n H1p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>IHphi2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true
∧ no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk279"><span class="nb">destruct</span> IHphi2 <span class="kr">as</span> [H2n H2p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
           <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
           no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
           no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
           no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
           no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
           no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk27a"><span class="nb">fold</span> no_negative_occurrence_db_b no_positive_occurrence_db_b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_positive_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2,
    no_negative_occurrence_db_b n&#39; phi1
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk27b"><span class="nb">rewrite</span> H1n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; no_positive_occurrence_db_b n&#39; phi1 &amp;&amp;
    no_negative_occurrence_db_b n&#39; phi2, true
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk27c"><span class="nb">rewrite</span> H1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; true &amp;&amp; no_negative_occurrence_db_b n&#39; phi2, true
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk27d"><span class="nb">rewrite</span> H2n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; true &amp;&amp; true, true
  &amp; no_positive_occurrence_db_b n&#39; phi2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk27e"><span class="nb">rewrite</span> H2p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; true &amp;&amp; true, true &amp; true]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk27f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi1, phi2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ false || false</span></span></span><br><span><var>H1n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H1p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi1 = true</span></span></span><br><span><var>H2n</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n&#39; phi2 = true</span></span></span><br><span><var>H2p</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n&#39; phi2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk280"><span class="kn">Corollary</span> <span class="nf">not_bsvar_occur_impl_pos_occ_db</span> <span class="nv">phi</span> <span class="nv">n</span>:
    ~ bsvar_occur phi n -&gt;
    no_positive_occurrence_db_b n phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi n
→ no_positive_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk281"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi n
→ no_positive_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk282"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk283" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk283"><span class="nb">pose proof</span> (H1 := not_bsvar_occur_impl_no_neg_occ_and_no_pos_occ _ _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi n</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n phi &amp;&amp;
no_positive_occurrence_db_b n phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk284"><span class="kn">Corollary</span> <span class="nf">not_bsvar_occur_impl_neg_occ_db</span> <span class="nv">phi</span> <span class="nv">n</span>:
    ~ bsvar_occur phi n -&gt;
    no_negative_occurrence_db_b n phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi n
→ no_negative_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk285"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ bsvar_occur phi n
→ no_negative_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk286"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk287"><span class="nb">pose proof</span> (H1 := not_bsvar_occur_impl_no_neg_occ_and_no_pos_occ _ _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>¬ bsvar_occur phi n</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n phi &amp;&amp;
no_positive_occurrence_db_b n phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> andb_true_iff <span class="kr">in</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">



</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk288"><span class="kn">Lemma</span> <span class="nf">x_eq_fresh_impl_x_notin_free_evars</span> <span class="nv">x</span> <span class="nv">ϕ</span>:
    x = fresh_evar ϕ -&gt;
    x ∉ free_evars ϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = fresh_evar ϕ → x ∉ free_evars ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk289"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = fresh_evar ϕ → x ∉ free_evars ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk28a"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x = fresh_evar ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_evars ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk28b"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x = fresh_evar ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_evar ϕ ∉ free_evars ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk28c"><span class="nb">unfold</span> fresh_evar.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x = fresh_evar ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_fresh_s (free_evars ϕ) ∉ free_evars ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> set_evar_fresh_is_fresh&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Resolve</span> x_eq_fresh_impl_x_notin_free_evars : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">syntax</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* TODO: change Bot and Top to unicode symbols *)</span>
  <span class="c">(* TODO: this associativity is wrong! However, stdpp disallows defining it otherwise. We could use @ instead, associated to the left *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;a $ b&quot;</span> := (patt_app a b) (<span class="kn">at level</span> <span class="mi">65</span>, <span class="kn">right associativity</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Bot&#39;&quot;</span> := patt_bott : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;⊥&quot;</span> := patt_bott : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;a ---&gt; b&quot;</span>  := (patt_imp a b) (<span class="kn">at level</span> <span class="mi">75</span>, <span class="kn">right associativity</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;ex&#39; , phi&quot;</span> := (patt_exists phi) (<span class="kn">at level</span> <span class="mi">80</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;mu&#39; , phi&quot;</span> := (patt_mu phi) (<span class="kn">at level</span> <span class="mi">80</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*Notation &quot;AC [ p ]&quot; := (subst_ctx AC p) (at level 90) : ml_scope.*)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;C [ p ]&quot;</span> := (emplace C p) (<span class="kn">at level</span> <span class="mi">90</span>) : ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">BoundVarSugar</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Element variables - bound *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b0</span> := (patt_bound_evar <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b1</span> := (patt_bound_evar <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b2</span> := (patt_bound_evar <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b3</span> := (patt_bound_evar <span class="mi">3</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b4</span> := (patt_bound_evar <span class="mi">4</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b5</span> := (patt_bound_evar <span class="mi">5</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b6</span> := (patt_bound_evar <span class="mi">6</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b7</span> := (patt_bound_evar <span class="mi">7</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b8</span> := (patt_bound_evar <span class="mi">8</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">b9</span> := (patt_bound_evar <span class="mi">9</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B0</span> := (patt_bound_svar <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B1</span> := (patt_bound_svar <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B2</span> := (patt_bound_svar <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B3</span> := (patt_bound_svar <span class="mi">3</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B4</span> := (patt_bound_svar <span class="mi">4</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B5</span> := (patt_bound_svar <span class="mi">5</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B6</span> := (patt_bound_svar <span class="mi">6</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B7</span> := (patt_bound_svar <span class="mi">7</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B8</span> := (patt_bound_svar <span class="mi">8</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">B9</span> := (patt_bound_svar <span class="mi">9</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">BoundVarSugar</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span>
 evar_is_fresh_in_richer
 set_evar_fresh_is_fresh
 set_svar_fresh_is_fresh
 x_eq_fresh_impl_x_notin_free_evars
  : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Extern</span> <span class="mi">0</span> (is_true (@well_formed _ _)) =&gt; <span class="nb">unfold</span> is_true : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_bott : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_imp : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_app : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wf_sctx : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_ex_app : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_impl_well_formed_ex : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_free_evar_subst : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_free_evar_subst_0 : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> &lt;- evar_is_fresh_in_exists : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> evar_is_fresh_in_evar_quantify : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Tactics for resolving goals involving sets *)</span>
<span class="c">(*</span>
<span class="c">        eauto 5 using @sets.elem_of_union_l, @sets.elem_of_union_r with typeclass_instances.</span>
<span class="c"> *)</span>
<span class="c">(*</span>
<span class="c">  eauto depth using @sets.union_subseteq_l, @sets.union_subseteq_r</span>
<span class="c">    with typeclass_instances.</span>
<span class="c"> *)</span>

<span class="c">(*</span>
<span class="c">#[export]</span>
<span class="c"> Hint Extern 10 (free_evars _ ⊆ free_evars _) =&gt; solve_free_evars_inclusion : core.</span>
<span class="c"> *)</span>


</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wf_imp_wfc : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfc_ex_implies_not_bevar_occur : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">with_signature</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Σ</span> : Signature}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">evar_quantify_ctx</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index) (<span class="nv">C</span> : PatternCtx) : PatternCtx :=
    <span class="kr">match</span> decide (x = pcEvar C)  <span class="kr">with</span>
    | <span class="nb">left</span> _ =&gt; C
    | <span class="nb">right</span> pf =&gt; Build_PatternCtx (pcEvar C) ((pcPattern C)^{{<span class="nb">evar</span>: x ↦ n}})
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk28d"><span class="kn">Lemma</span> <span class="nf">is_linear_context_evar_quantify</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index) (<span class="nv">C</span> : PatternCtx) :
    is_linear_context C -&gt;
    is_linear_context (evar_quantify_ctx x n C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context C
→ is_linear_context (evar_quantify_ctx x n C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk28e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context C
→ is_linear_context (evar_quantify_ctx x n C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk28f"><span class="nb">intros</span> Hlin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>is_linear_context C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context (evar_quantify_ctx x n C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk290"><span class="nb">unfold</span> evar_quantify_ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>is_linear_context C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context
  (<span class="kr">if</span> decide (x = pcEvar C)
   <span class="kr">then</span> C
   <span class="kr">else</span>
    {|
      pcEvar := pcEvar C;
      pcPattern := (pcPattern C)^{{<span class="nb">evar</span>:x↦n}}
    |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk291"><span class="nb">unfold</span> is_linear_context <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences (pcEvar C) (pcPattern C) =
<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences
  (pcEvar
     (<span class="kr">if</span> decide (x = pcEvar C)
      <span class="kr">then</span> C
      <span class="kr">else</span>
       {|
         pcEvar := pcEvar C;
         pcPattern := (pcPattern C)^{{<span class="nb">evar</span>:x↦n}}
       |}))
  (pcPattern
     (<span class="kr">if</span> decide (x = pcEvar C)
      <span class="kr">then</span> C
      <span class="kr">else</span>
       {|
         pcEvar := pcEvar C;
         pcPattern := (pcPattern C)^{{<span class="nb">evar</span>:x↦n}}
       |})) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk292"><span class="nb">destruct</span> (decide (x = pcEvar C)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences (pcEvar C) (pcPattern C) =
<span class="mi">1</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = pcEvar C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences (pcEvar C) (pcPattern C) = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk293" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences (pcEvar C) (pcPattern C) =
<span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar C</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk293"><hr></label><div class="goal-conclusion">count_evar_occurrences (pcEvar C)
  (pcPattern C)^{{<span class="nb">evar</span>:x↦n}} = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk294">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences (pcEvar C) (pcPattern C) =
<span class="mi">1</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = pcEvar C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences (pcEvar C) (pcPattern C) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk295">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences (pcEvar C) (pcPattern C) =
<span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences (pcEvar C)
  (pcPattern C)^{{<span class="nb">evar</span>:x↦n}} = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk296"><span class="nb">destruct</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences
  (PatternContext.pcEvar
     {|
       pcEvar := pcEvar; pcPattern := pcPattern
     |})
  (PatternContext.pcPattern
     {|
       pcEvar := pcEvar; pcPattern := pcPattern
     |}) = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x
≠ PatternContext.pcEvar
    {|
      pcEvar := pcEvar; pcPattern := pcPattern
    |}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences
  (PatternContext.pcEvar
     {| pcEvar := pcEvar; pcPattern := pcPattern |})
  (PatternContext.pcPattern
     {| pcEvar := pcEvar; pcPattern := pcPattern |})^{{<span class="nb">evar</span>:x↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk297"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar pcPattern = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar pcPattern^{{<span class="nb">evar</span>:x↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk298"><span class="nb">rename</span> pcEvar <span class="nb">into</span> pcEvar0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern^{{<span class="nb">evar</span>:x↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk299"><span class="nb">rename</span> pcPattern <span class="nb">into</span> pcPattern0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk29a"><span class="nb">assert</span> (count_evar_occurrences pcEvar0 (pcPattern0^{{<span class="nb">evar</span>: x ↦ n}})
              = count_evar_occurrences pcEvar0 pcPattern0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk29b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0
  pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk29b"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk29c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk29d"><span class="nb">clear</span> Hlin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk29e"><span class="nb">move</span>: n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk29f"><span class="nb">induction</span> pcPattern0; <span class="nb">intros</span> n&#39;; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0, x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (x = x0)
   <span class="kr">then</span> patt_bound_evar n&#39;
   <span class="kr">else</span> patt_free_evar x0) =
(<span class="kr">if</span> decide (x0 = pcEvar0) <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2a0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2a0"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{<span class="nb">evar</span>:x↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2a1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2a1"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{<span class="nb">evar</span>:x↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2a2"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{<span class="nb">evar</span>:x↦S n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2a3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2a3"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2a4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0, x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (x = x0)
   <span class="kr">then</span> patt_bound_evar n&#39;
   <span class="kr">else</span> patt_free_evar x0) =
(<span class="kr">if</span> decide (x0 = pcEvar0) <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2a5"><span class="nb">destruct</span> (decide (x0 = pcEvar0)); <span class="nb">subst</span>; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (x = pcEvar0)
   <span class="kr">then</span> patt_bound_evar n&#39;
   <span class="kr">else</span> patt_free_evar pcEvar0) = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2a6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0, x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x0 ≠ pcEvar0</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2a6"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (x = x0)
   <span class="kr">then</span> patt_bound_evar n&#39;
   <span class="kr">else</span> patt_free_evar x0) = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2a7">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (x = pcEvar0)
   <span class="kr">then</span> patt_bound_evar n&#39;
   <span class="kr">else</span> patt_free_evar pcEvar0) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2a8"><span class="nb">destruct</span> (decide (x = pcEvar0)); <span class="kp">try</span> <span class="bp">contradiction</span>; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (pcEvar0 = pcEvar0) <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2a9"><span class="nb">destruct</span> (decide (pcEvar0 = pcEvar0)); <span class="kp">try</span> <span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>pcEvar0 = pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2aa">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0, x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x0 ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (x = x0)
   <span class="kr">then</span> patt_bound_evar n&#39;
   <span class="kr">else</span> patt_free_evar x0) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ab"><span class="nb">destruct</span> (decide (x = x0)); <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0, x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x0 ≠ pcEvar0</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>x ≠ x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x0 = pcEvar0) <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ac"><span class="nb">destruct</span> (decide (x0 = pcEvar0)); <span class="kp">try</span> <span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0, x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x0 ≠ pcEvar0</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>x ≠ x0</span></span></span><br><span><var>n2</var><span class="hyp-type"><b>: </b><span>x0 ≠ pcEvar0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ad">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{<span class="nb">evar</span>:x↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ae"><span class="nb">rewrite</span> IHpcPattern0_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2af"><span class="nb">rewrite</span> IHpcPattern0_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2 =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{<span class="nb">evar</span>:x↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b1"><span class="nb">rewrite</span> IHpcPattern0_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b2"><span class="nb">rewrite</span> IHpcPattern0_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2 =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{<span class="nb">evar</span>:x↦S n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b4"><span class="nb">rewrite</span> IHpcPattern0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0 =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{<span class="nb">evar</span>:x↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b6"><span class="nb">rewrite</span> IHpcPattern0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0 =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>x ≠ pcEvar0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0
  pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{<span class="nb">evar</span>:x↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">svar_quantify_ctx</span> (<span class="nv">X</span> : svar) (<span class="nv">n</span> : db_index) (<span class="nv">C</span> : PatternCtx) : PatternCtx :=
    Build_PatternCtx (pcEvar C) ((pcPattern C)^{{svar: X ↦ n}}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b8"><span class="kn">Lemma</span> <span class="nf">is_linear_context_svar_quantify</span> (<span class="nv">X</span> : svar) (<span class="nv">n</span> : db_index) (<span class="nv">C</span> : PatternCtx) :
    is_linear_context C -&gt;
    is_linear_context (svar_quantify_ctx X n C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context C
→ is_linear_context (svar_quantify_ctx X n C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2b9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context C
→ is_linear_context (svar_quantify_ctx X n C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ba"><span class="nb">intros</span> Hlin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>is_linear_context C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context (svar_quantify_ctx X n C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2bb"><span class="nb">unfold</span> svar_quantify_ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>is_linear_context C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_linear_context
  {|
    pcEvar := pcEvar C;
    pcPattern := (pcPattern C)^{{svar:X↦n}}
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2bc"><span class="nb">unfold</span> is_linear_context <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences (pcEvar C) (pcPattern C) =
<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences
  (pcEvar
     {|
       pcEvar := pcEvar C;
       pcPattern := (pcPattern C)^{{svar:X↦n}}
     |})
  (pcPattern
     {|
       pcEvar := pcEvar C;
       pcPattern := (pcPattern C)^{{svar:X↦n}}
     |}) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2bd"><span class="nb">destruct</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences
  (PatternContext.pcEvar
     {|
       pcEvar := pcEvar; pcPattern := pcPattern
     |})
  (PatternContext.pcPattern
     {|
       pcEvar := pcEvar; pcPattern := pcPattern
     |}) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences
  (PatternContext.pcEvar
     {|
       pcEvar :=
         PatternContext.pcEvar
           {|
             pcEvar := pcEvar; pcPattern := pcPattern
           |};
       pcPattern :=
         (PatternContext.pcPattern
            {|
              pcEvar := pcEvar; pcPattern := pcPattern
            |})^{{svar:X↦n}}
     |})
  (PatternContext.pcPattern
     {|
       pcEvar :=
         PatternContext.pcEvar
           {|
             pcEvar := pcEvar; pcPattern := pcPattern
           |};
       pcPattern :=
         (PatternContext.pcPattern
            {|
              pcEvar := pcEvar; pcPattern := pcPattern
            |})^{{svar:X↦n}}
     |}) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2be"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar pcPattern = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar pcPattern^{{svar:X↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2bf"><span class="nb">rename</span> pcEvar <span class="nb">into</span> pcEvar0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern^{{svar:X↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2c0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2c0"><span class="nb">rename</span> pcPattern <span class="nb">into</span> pcPattern0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{svar:X↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2c1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2c1"><span class="nb">assert</span> (count_evar_occurrences pcEvar0 (pcPattern0^{{svar: X ↦ n}})
            = count_evar_occurrences pcEvar0 pcPattern0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{svar:X↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2c2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0
  pcPattern0^{{svar:X↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2c2"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{svar:X↦n}} =
<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2c3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2c3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{svar:X↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2c4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2c4"><span class="nb">clear</span> Hlin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{svar:X↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2c5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2c5"><span class="nb">move</span>: n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2c6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2c6"><span class="nb">induction</span> pcPattern0; <span class="nb">intros</span> n&#39;; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar n&#39;
   <span class="kr">else</span> patt_free_svar x) = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2c7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2c7"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{svar:X↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2c8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2c8"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{svar:X↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2c9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2c9"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2ca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2ca"><hr></label><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{svar:X↦S n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2cb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2cb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar n&#39;
   <span class="kr">else</span> patt_free_svar x) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">subst</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2cc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2cc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{svar:X↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2cd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2cd"><span class="nb">rewrite</span> IHpcPattern0_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ce" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ce"><span class="nb">rewrite</span> IHpcPattern0_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2 =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2cf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2cf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0_1^{{svar:X↦n&#39;}} +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d0"><span class="nb">rewrite</span> IHpcPattern0_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0
  pcPattern0_2^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d1"><span class="nb">rewrite</span> IHpcPattern0_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0_1, pcPattern0_2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0_1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_1^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_1</span></span></span><br><span><var>IHpcPattern0_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0_2^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0_2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2 =
count_evar_occurrences pcEvar0 pcPattern0_1 +
count_evar_occurrences pcEvar0 pcPattern0_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{svar:X↦n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d3"><span class="nb">rewrite</span> IHpcPattern0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0 =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0
  pcPattern0^{{svar:X↦S n&#39;}} =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d5"><span class="nb">rewrite</span> IHpcPattern0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHpcPattern0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  count_evar_occurrences pcEvar0
    pcPattern0^{{svar:X↦n}} =
  count_evar_occurrences pcEvar0
    pcPattern0</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0 =
count_evar_occurrences pcEvar0 pcPattern0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern0</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hlin</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0 pcPattern0 = <span class="mi">1</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar0
  pcPattern0^{{svar:X↦n}} =
count_evar_occurrences pcEvar0 pcPattern0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar0 pcPattern0^{{svar:X↦n}} =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d7"><span class="kn">Lemma</span> <span class="nf">svar_quantify_free_evar_subst</span> <span class="nv">ψ</span> <span class="nv">ϕ</span> <span class="nv">x</span> <span class="nv">X</span> <span class="nv">n</span>:
    ψ^[[<span class="nb">evar</span>: x ↦ ϕ]]^{{svar: X ↦ n}} =
    ψ^{{svar: X ↦ n}}^[[<span class="nb">evar</span>: x ↦ ϕ^{{svar: X ↦ n}}]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2d9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2d9"><span class="nb">move</span>: n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2da" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2da"><span class="nb">induction</span> ψ; <span class="nb">intros</span> n&#39;; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x = x0) <span class="kr">then</span> ϕ <span class="kr">else</span> patt_free_evar x0)^{{svar:X↦n&#39;}} =
(<span class="kr">if</span> decide (x = x0)
 <span class="kr">then</span> ϕ^{{svar:X↦n&#39;}}
 <span class="kr">else</span> patt_free_evar x0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2db" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2db"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> decide (X = x0)
 <span class="kr">then</span> patt_bound_svar n&#39;
 <span class="kr">else</span> patt_free_svar x0) =
(<span class="kr">if</span> decide (X = x0)
 <span class="kr">then</span> patt_bound_svar n&#39;
 <span class="kr">else</span> patt_free_svar x0)^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2dc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2dc"><hr></label><div class="goal-conclusion">patt_app ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}}
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_app ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2dd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2dd"><hr></label><div class="goal-conclusion">patt_imp ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}}
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_imp ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2de" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2de"><hr></label><div class="goal-conclusion">patt_exists ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_exists ψ^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2df" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2df"><hr></label><div class="goal-conclusion">patt_mu ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦S n&#39;}} =
patt_mu ψ^{{svar:X↦S n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x = x0) <span class="kr">then</span> ϕ <span class="kr">else</span> patt_free_evar x0)^{{svar:X↦n&#39;}} =
(<span class="kr">if</span> decide (x = x0)
 <span class="kr">then</span> ϕ^{{svar:X↦n&#39;}}
 <span class="kr">else</span> patt_free_evar x0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e1">case_match.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ϕ^{{svar:X↦n&#39;}} = ϕ^{{svar:X↦n&#39;}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2e2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x ≠ x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2e2"><hr></label><div class="goal-conclusion">(patt_free_evar x0)^{{svar:X↦n&#39;}} = patt_free_evar x0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ϕ^{{svar:X↦n&#39;}} = ϕ^{{svar:X↦n&#39;}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x ≠ x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(patt_free_evar x0)^{{svar:X↦n&#39;}} = patt_free_evar x0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>x ≠ x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">right</span> n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_free_evar x0 = patt_free_evar x0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (X = x0)
 <span class="kr">then</span> patt_bound_svar n&#39;
 <span class="kr">else</span> patt_free_svar x0) =
(<span class="kr">if</span> decide (X = x0)
 <span class="kr">then</span> patt_bound_svar n&#39;
 <span class="kr">else</span> patt_free_svar x0)^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}}
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_app ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e8"><span class="nb">rewrite</span> IHψ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_app ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2e9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2e9"><span class="nb">rewrite</span> IHψ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]] =
patt_app ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ea" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ea">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}}
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_imp ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2eb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2eb"><span class="nb">rewrite</span> IHψ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_imp ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ec" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ec"><span class="nb">rewrite</span> IHψ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ1, ψ2, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ1^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ1^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>IHψ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  ψ2^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
  ψ2^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]] =
patt_imp ψ1^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]
  ψ2^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ed" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ed">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} = ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n&#39;}} =
patt_exists ψ^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ee" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ee"><span class="nb">rewrite</span> IHψ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} = ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists ψ^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]] =
patt_exists ψ^{{svar:X↦n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ef" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} = ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦S n&#39;}} =
patt_mu ψ^{{svar:X↦S n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f0"><span class="nb">rewrite</span> IHψ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} = ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu ψ^{{svar:X↦S n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦S n&#39;}}]] =
patt_mu ψ^{{svar:X↦S n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f1"><span class="kn">Fail</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
Σ : Signature
ψ, ϕ : Pattern
x : <span class="nb">evar</span>
X : svar
IHψ : <span class="kr">∀</span> <span class="nv">n</span> : db_index,
        ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} =
        ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]
n&#39; : db_index
Unable to <span class="nb">unify</span>
 <span class="s2">&quot;patt_mu ψ^{{svar:X↦S n&#39;}}^[[evar:x↦ϕ^{{svar:X↦n&#39;}}]]&quot;</span>
<span class="kr">with</span>
 <span class="s2">&quot;patt_mu</span>
<span class="s2">    ψ^{{svar:X↦S n&#39;}}^[[evar:x↦ϕ^{{svar:X↦S n&#39;}}]]&quot;</span>.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ψ, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHψ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
ψ^[[<span class="nb">evar</span>:x↦ϕ]]^{{svar:X↦n}} = ψ^{{svar:X↦n}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n}}]]</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu ψ^{{svar:X↦S n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦S n&#39;}}]] =
patt_mu ψ^{{svar:X↦S n&#39;}}^[[<span class="nb">evar</span>:x↦ϕ^{{svar:X↦n&#39;}}]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span><span class="alectryon-wsp"> <span class="c">(* OOPS, does not hold. The problem is that [free_evar_subst&#39;] does not wrap the target</span>
<span class="c">            in nest_mu. *)</span>


</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f2"><span class="kn">Lemma</span> <span class="nf">svar_quantify_emplace</span> <span class="nv">X</span> <span class="nv">n</span> <span class="nv">C</span> <span class="nv">ϕ</span>:
    (emplace C ϕ)^{{svar: X ↦ n}} = emplace (svar_quantify_ctx X n C) (ϕ^{{svar: X ↦ n}}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(emplace C ϕ)^{{svar:X↦n}} =
emplace (svar_quantify_ctx X n C) ϕ^{{svar:X↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(emplace C ϕ)^{{svar:X↦n}} =
emplace (svar_quantify_ctx X n C) ϕ^{{svar:X↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f4"><span class="nb">destruct</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(emplace
   {| pcEvar := pcEvar; pcPattern := pcPattern |} ϕ)^{{svar:X↦n}} =
emplace
  (svar_quantify_ctx X n
     {| pcEvar := pcEvar; pcPattern := pcPattern |})
  ϕ^{{svar:X↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f5"><span class="nb">unfold</span> svar_quantify_ctx,emplace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(PatternContext.pcPattern
   {| pcEvar := pcEvar; pcPattern := pcPattern |})^[[<span class="nb">evar</span>:
PatternContext.pcEvar
  {| pcEvar := pcEvar; pcPattern := pcPattern |}↦ϕ]]^{{svar:X↦n}} =
(PatternContext.pcPattern
   {|
     pcEvar :=
       PatternContext.pcEvar
         {|
           pcEvar := pcEvar; pcPattern := pcPattern
         |};
     pcPattern :=
       (PatternContext.pcPattern
          {|
            pcEvar := pcEvar; pcPattern := pcPattern
          |})^{{svar:X↦n}}
   |})^[[<span class="nb">evar</span>:PatternContext.pcEvar
                {|
                  pcEvar :=
                    PatternContext.pcEvar
                      {|
                        pcEvar := pcEvar;
                        pcPattern := pcPattern
                      |};
                  pcPattern :=
                    (PatternContext.pcPattern
                       {|
                         pcEvar := pcEvar;
                         pcPattern := pcPattern
                       |})^{{svar:X↦n}}
                |}↦ϕ^{{svar:X↦n}}]]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>pcPattern, ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pcPattern^[[<span class="nb">evar</span>:pcEvar↦ϕ]]^{{svar:X↦n}} =
pcPattern^{{svar:X↦n}}^[[<span class="nb">evar</span>:pcEvar↦ϕ^{{svar:X↦n}}]]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f7"><span class="kn">Lemma</span> <span class="nf">evar_quantify_subst_ctx</span> <span class="nv">x</span> <span class="nv">n</span> <span class="nv">AC</span> <span class="nv">ϕ</span>:
    x ∉ AC_free_evars AC -&gt;
    (subst_ctx AC ϕ)^{{<span class="nb">evar</span>: x ↦ n}} = subst_ctx AC (ϕ^{{<span class="nb">evar</span>: x ↦ n}}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2f9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2f9"><span class="nb">intros</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2fa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2fa"><span class="nb">induction</span> AC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars box</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(subst_ctx box ϕ)^{{<span class="nb">evar</span>:x↦n}} =
subst_ctx box ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2fb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars (ctx_app_l AC p Prf)</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2fb"><hr></label><div class="goal-conclusion">(subst_ctx (ctx_app_l AC p Prf) ϕ)^{{<span class="nb">evar</span>:x↦n}} =
subst_ctx (ctx_app_l AC p Prf) ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk2fc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars (ctx_app_r p AC Prf)</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk2fc"><hr></label><div class="goal-conclusion">(subst_ctx (ctx_app_r p AC Prf) ϕ)^{{<span class="nb">evar</span>:x↦n}} =
subst_ctx (ctx_app_r p AC Prf) ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2fd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2fd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars box</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(subst_ctx box ϕ)^{{<span class="nb">evar</span>:x↦n}} =
subst_ctx box ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2fe" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2fe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars (ctx_app_l AC p Prf)</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(subst_ctx (ctx_app_l AC p Prf) ϕ)^{{<span class="nb">evar</span>:x↦n}} =
subst_ctx (ctx_app_l AC p Prf) ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk2ff" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk2ff"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars (ctx_app_l AC p Prf)</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} p^{{<span class="nb">evar</span>:x↦n}} =
patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk300" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk300"><span class="nb">simpl</span> <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} p^{{<span class="nb">evar</span>:x↦n}} =
patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk301" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk301"><span class="nb">rewrite</span> IHAC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ AC_free_evars AC</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk302" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk302"><hr></label><div class="goal-conclusion">patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p^{{<span class="nb">evar</span>:x↦n}} =
patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk303" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk303">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ AC_free_evars AC</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk304" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk304">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p^{{<span class="nb">evar</span>:x↦n}} =
patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk305" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk305"><span class="nb">rewrite</span> [p^{{<span class="nb">evar</span>: x ↦ n}}]evar_quantify_fresh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk306" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk306"><hr></label><div class="goal-conclusion">patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p =
patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk307" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk307"><span class="nb">unfold</span> evar_is_fresh_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_evars p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk308" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk308"><hr></label><div class="goal-conclusion">patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p =
patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk309" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk309">set_solver.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p =
patt_app (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk30a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk30a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars (ctx_app_r p AC Prf)</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(subst_ctx (ctx_app_r p AC Prf) ϕ)^{{<span class="nb">evar</span>:x↦n}} =
subst_ctx (ctx_app_r p AC Prf) ϕ^{{<span class="nb">evar</span>:x↦n}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk30b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk30b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars (ctx_app_r p AC Prf)</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app p^{{<span class="nb">evar</span>:x↦n}} (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk30c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk30c"><span class="nb">simpl</span> <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app p^{{<span class="nb">evar</span>:x↦n}} (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk30d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk30d"><span class="nb">rewrite</span> IHAC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ AC_free_evars AC</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk30e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk30e"><hr></label><div class="goal-conclusion">patt_app p^{{<span class="nb">evar</span>:x↦n}} (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) =
patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}})</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk30f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk30f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ AC_free_evars AC</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk310" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk310">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app p^{{<span class="nb">evar</span>:x↦n}} (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) =
patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk311" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk311"><span class="nb">rewrite</span> [p^{{<span class="nb">evar</span>: x ↦ n}}]evar_quantify_fresh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evar_is_fresh_in x p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk312" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk312"><hr></label><div class="goal-conclusion">patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) =
patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}})</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk313" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk313"><span class="nb">unfold</span> evar_is_fresh_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_evars p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk314" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk314"><hr></label><div class="goal-conclusion">patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) =
patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}})</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk315" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk315">set_solver.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>AC</var><span class="hyp-type"><b>: </b><span>Application_context</span></span></span><br><span><var>Prf</var><span class="hyp-type"><b>: </b><span>well_formed p</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∉ free_evars p ∪ AC_free_evars AC</span></span></span><br><span><var>IHAC</var><span class="hyp-type"><b>: </b><span>x ∉ AC_free_evars AC
→ (subst_ctx AC ϕ)^{{<span class="nb">evar</span>:x↦n}} =
  subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}}) =
patt_app p (subst_ctx AC ϕ^{{<span class="nb">evar</span>:x↦n}})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk316" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk316"><span class="kn">Lemma</span> <span class="nf">Private_no_negative_occurrence_svar_quantify</span> <span class="nv">ϕ</span> <span class="nv">level</span> <span class="nv">X</span>:
    (
      no_negative_occurrence_db_b level ϕ = true -&gt;
      svar_has_negative_occurrence X ϕ = false -&gt;
      no_negative_occurrence_db_b level (ϕ^{{svar: X ↦ level}}) = true
    )
    /\
    (
      no_positive_occurrence_db_b level ϕ = true -&gt;
      svar_has_positive_occurrence X ϕ = false -&gt;
      no_positive_occurrence_db_b level (ϕ^{{svar: X ↦ level}}) = true
    ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(no_negative_occurrence_db_b level ϕ = true
 → svar_has_negative_occurrence X ϕ = false
   → no_negative_occurrence_db_b level
       ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
   → svar_has_positive_occurrence X ϕ = false
     → no_positive_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk317" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk317"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(no_negative_occurrence_db_b level ϕ = true
 → svar_has_negative_occurrence X ϕ = false
   → no_negative_occurrence_db_b level
       ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
   → svar_has_positive_occurrence X ϕ = false
     → no_positive_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk318" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk318"><span class="nb">move</span>: level.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ = true
   → svar_has_negative_occurrence X ϕ = false
     → no_negative_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ = true
     → svar_has_positive_occurrence X ϕ = false
       → no_positive_occurrence_db_b level
           ϕ^{{svar:X↦level}} = true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk319" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk319"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> level; <span class="nb">split</span>; <span class="nb">intros</span> HnoX Hnolevel; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar level
   <span class="kr">else</span> patt_free_svar x) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk31a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (X = x) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk31a"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b level
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar level
   <span class="kr">else</span> patt_free_svar x) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk31b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 &amp;&amp;
no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1
|| svar_has_negative_occurrence X ϕ2 =
false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk31b"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk31c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 &amp;&amp;
no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1
|| svar_has_positive_occurrence X ϕ2 =
false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk31c"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk31d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 &amp;&amp;
no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1
|| svar_has_negative_occurrence X ϕ2 =
false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk31d"><hr></label><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk31e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 &amp;&amp;
no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1
|| svar_has_positive_occurrence X ϕ2 =
false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk31e"><hr></label><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk31f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ = true
   → svar_has_negative_occurrence X ϕ = false
     → no_negative_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ = true
     → svar_has_positive_occurrence X ϕ = false
       → no_positive_occurrence_db_b level
           ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk31f"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk320" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ = true
   → svar_has_negative_occurrence X ϕ = false
     → no_negative_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ = true
     → svar_has_positive_occurrence X ϕ = false
       → no_positive_occurrence_db_b level
           ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk320"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk321" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ = true
   → svar_has_negative_occurrence X ϕ = false
     → no_negative_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ = true
     → svar_has_positive_occurrence X ϕ = false
       → no_positive_occurrence_db_b level
           ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b (S level) ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk321"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b 
  (S level) ϕ^{{svar:X↦S level}} = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk322" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ = true
   → svar_has_negative_occurrence X ϕ = false
     → no_negative_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ = true
     → svar_has_positive_occurrence X ϕ = false
       → no_positive_occurrence_db_b level
           ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b (S level) ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk322"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b 
  (S level) ϕ^{{svar:X↦S level}} = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk323" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk323">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar level
   <span class="kr">else</span> patt_free_svar x) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk324" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk324">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (X = x) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar level
   <span class="kr">else</span> patt_free_svar x) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk325" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk325">case_match; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>true = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (level = level) <span class="kr">then</span> false <span class="kr">else</span> true) =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk326" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>X ≠ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">right</span> n</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk326"><hr></label><div class="goal-conclusion">true = true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk327" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk327"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>true = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (level = level) <span class="kr">then</span> false <span class="kr">else</span> true) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk328" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk328">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 &amp;&amp;
no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1
|| svar_has_negative_occurrence X ϕ2 =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk329" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk329"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnolevel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 &amp;&amp;
no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false
∧ svar_has_negative_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk32a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk32a">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk32b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk32b"><span class="nb">pose proof</span> (IH1 := IHϕ1 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ1 = true
 → svar_has_negative_occurrence X ϕ1 = false
   → no_negative_occurrence_db_b level
       ϕ1^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ1 = true
   → svar_has_positive_occurrence X ϕ1 = false
     → no_positive_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk32c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk32c"><span class="nb">destruct</span> IH1 <span class="kr">as</span> [IH11 _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → no_negative_occurrence_db_b level
      ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk32d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk32d"><span class="nb">specialize</span> (IH11 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk32e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk32e"><span class="nb">pose proof</span> (IH2 := IHϕ2 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ2 = true
 → svar_has_negative_occurrence X ϕ2 = false
   → no_negative_occurrence_db_b level
       ϕ2^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ2 = true
   → svar_has_positive_occurrence X ϕ2 = false
     → no_positive_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk32f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk32f"><span class="nb">destruct</span> IH2 <span class="kr">as</span> [IH21 _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH21</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → no_negative_occurrence_db_b level
      ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk330" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk330"><span class="nb">specialize</span> (IH21 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH21</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk331" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk331">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 &amp;&amp;
no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1
|| svar_has_positive_occurrence X ϕ2 =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk332" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk332"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnolevel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 &amp;&amp;
no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false
∧ svar_has_positive_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk333" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk333">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk334" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk334"><span class="nb">pose proof</span> (IH1 := IHϕ1 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ1 = true
 → svar_has_negative_occurrence X ϕ1 = false
   → no_negative_occurrence_db_b level
       ϕ1^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ1 = true
   → svar_has_positive_occurrence X ϕ1 = false
     → no_positive_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk335" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk335"><span class="nb">destruct</span> IH1 <span class="kr">as</span> [_ IH12].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → no_positive_occurrence_db_b level
      ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk336" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk336"><span class="nb">specialize</span> (IH12 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk337" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk337"><span class="nb">pose proof</span> (IH2 := IHϕ2 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ2 = true
 → svar_has_negative_occurrence X ϕ2 = false
   → no_negative_occurrence_db_b level
       ϕ2^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ2 = true
   → svar_has_positive_occurrence X ϕ2 = false
     → no_positive_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk338" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk338"><span class="nb">destruct</span> IH2 <span class="kr">as</span> [_ IH22].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH22</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → no_positive_occurrence_db_b level
      ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk339" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk339"><span class="nb">specialize</span> (IH22 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH22</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk33a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk33a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 &amp;&amp;
no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1
|| svar_has_negative_occurrence X ϕ2 =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk33b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk33b"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnolevel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 &amp;&amp;
no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false
∧ svar_has_negative_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk33c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk33c">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk33d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk33d"><span class="nb">pose proof</span> (IH1 := IHϕ1 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ1 = true
 → svar_has_negative_occurrence X ϕ1 = false
   → no_negative_occurrence_db_b level
       ϕ1^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ1 = true
   → svar_has_positive_occurrence X ϕ1 = false
     → no_positive_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk33e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk33e"><span class="nb">destruct</span> IH1 <span class="kr">as</span> [_ IH12].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → no_positive_occurrence_db_b level
      ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk33f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk33f"><span class="nb">specialize</span> (IH12 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk340" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk340"><span class="nb">pose proof</span> (IH2 := IHϕ2 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ2 = true
 → svar_has_negative_occurrence X ϕ2 = false
   → no_negative_occurrence_db_b level
       ϕ2^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ2 = true
   → svar_has_positive_occurrence X ϕ2 = false
     → no_positive_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk341" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk341"><span class="nb">destruct</span> IH2 <span class="kr">as</span> [IH21 _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH21</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → no_negative_occurrence_db_b level
      ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk342" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk342"><span class="nb">specialize</span> (IH21 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IH12</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH21</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_negative_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk343" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk343">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 &amp;&amp;
no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1
|| svar_has_positive_occurrence X ϕ2 =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk344" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk344"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnolevel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 &amp;&amp;
no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false
∧ svar_has_positive_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk345" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk345">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk346" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk346"><span class="nb">pose proof</span> (IH1 := IHϕ1 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ1 = true
 → svar_has_negative_occurrence X ϕ1 = false
   → no_negative_occurrence_db_b level
       ϕ1^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ1 = true
   → svar_has_positive_occurrence X ϕ1 = false
     → no_positive_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk347" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk347"><span class="nb">destruct</span> IH1 <span class="kr">as</span> [IH11 _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → no_negative_occurrence_db_b level
      ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk348" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk348"><span class="nb">specialize</span> (IH11 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk349" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk349"><span class="nb">pose proof</span> (IH2 := IHϕ2 level).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ2 = true
 → svar_has_negative_occurrence X ϕ2 = false
   → no_negative_occurrence_db_b level
       ϕ2^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ2 = true
   → svar_has_positive_occurrence X ϕ2 = false
     → no_positive_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk34a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk34a"><span class="nb">destruct</span> IH2 <span class="kr">as</span> [_ IH22].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH22</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → no_positive_occurrence_db_b level
      ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk34b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk34b"><span class="nb">specialize</span> (IH22 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ1 = true
   → svar_has_negative_occurrence X ϕ1 = false
     → no_negative_occurrence_db_b level
         ϕ1^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ1 =
     true
     → svar_has_positive_occurrence X ϕ1 =
       false
       → no_positive_occurrence_db_b level
           ϕ1^{{svar:X↦level}} = true)</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
  (no_negative_occurrence_db_b level ϕ2 = true
   → svar_has_negative_occurrence X ϕ2 = false
     → no_negative_occurrence_db_b level
         ϕ2^{{svar:X↦level}} = true)
  ∧ (no_positive_occurrence_db_b level ϕ2 =
     true
     → svar_has_positive_occurrence X ϕ2 =
       false
       → no_positive_occurrence_db_b level
           ϕ2^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IH11</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level
  ϕ1^{{svar:X↦level}} = true</span></span></span><br><span><var>IH22</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level
  ϕ2^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) level
  ϕ1^{{svar:X↦level}} &amp;&amp;
no_positive_occurrence_db_b level ϕ2^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk34c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk34c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
(no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
→ no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
→ no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk34d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk34d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
(no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
→ no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
→ no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk34e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk34e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
(no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
→ no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
→ no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b (S level) ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b (S level)
  ϕ^{{svar:X↦S level}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk34f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk34f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">level</span> : db_index,
(no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
→ no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
→ no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} = true)</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>HnoX</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b (S level) ϕ = true</span></span></span><br><span><var>Hnolevel</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b (S level)
  ϕ^{{svar:X↦S level}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk350" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk350"><span class="kn">Lemma</span> <span class="nf">no_negative_occurrence_svar_quantify</span> <span class="nv">ϕ</span> <span class="nv">level</span> <span class="nv">X</span>:
    no_negative_occurrence_db_b level ϕ = true -&gt;
    svar_has_negative_occurrence X ϕ = false -&gt;
    no_negative_occurrence_db_b level (ϕ^{{svar: X ↦ level}}) = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → no_negative_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk351" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk351"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → no_negative_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk352" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk352"><span class="nb">intros</span> H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk353" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk353"><span class="nb">pose proof</span> (Htmp :=Private_no_negative_occurrence_svar_quantify ϕ level X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ = true
 → svar_has_negative_occurrence X ϕ = false
   → no_negative_occurrence_db_b level
       ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
   → svar_has_positive_occurrence X ϕ = false
     → no_positive_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk354" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk354"><span class="nb">destruct</span> Htmp <span class="kr">as</span> [Htmp1 Htmp2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>Htmp1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → no_negative_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</span></span></span><br><span><var>Htmp2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → no_positive_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk355" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk355"><span class="kn">Lemma</span> <span class="nf">no_positive_occurrence_svar_quantify</span> <span class="nv">ϕ</span> <span class="nv">level</span> <span class="nv">X</span>:
      no_positive_occurrence_db_b level ϕ = true -&gt;
      svar_has_positive_occurrence X ϕ = false -&gt;
      no_positive_occurrence_db_b level (ϕ^{{svar: X ↦ level}}) = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → no_positive_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk356" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk356"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → no_positive_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk357" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk357"><span class="nb">intros</span> H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk358" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk358"><span class="nb">pose proof</span> (Htmp :=Private_no_negative_occurrence_svar_quantify ϕ level X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>Htmp</var><span class="hyp-type"><b>: </b><span>(no_negative_occurrence_db_b level ϕ = true
 → svar_has_negative_occurrence X ϕ = false
   → no_negative_occurrence_db_b level
       ϕ^{{svar:X↦level}} = true)
∧ (no_positive_occurrence_db_b level ϕ = true
   → svar_has_positive_occurrence X ϕ = false
     → no_positive_occurrence_db_b level
         ϕ^{{svar:X↦level}} = true)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk359" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk359"><span class="nb">destruct</span> Htmp <span class="kr">as</span> [Htmp1 Htmp2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>level</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>Htmp1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b level ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → no_negative_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</span></span></span><br><span><var>Htmp2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b level ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → no_positive_occurrence_db_b level
      ϕ^{{svar:X↦level}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b level ϕ^{{svar:X↦level}} =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk35a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk35a"><span class="kn">Lemma</span> <span class="nf">no_negative_occurrence_svar_quantify_2</span> <span class="nv">X</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> <span class="nv">ϕ</span>:
    dbi1 &lt;&gt; dbi2 -&gt;
    no_negative_occurrence_db_b dbi1 (ϕ^{{svar: X ↦ dbi2}}) = no_negative_occurrence_db_b dbi1 ϕ
  <span class="kr">with</span> no_positive_occurrence_svar_quantify_2  X dbi1 dbi2 ϕ:
    dbi1 &lt;&gt; dbi2 -&gt;
    no_positive_occurrence_db_b dbi1 (ϕ^{{svar: X ↦ dbi2}}) = no_positive_occurrence_db_b dbi1 ϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2
→ no_negative_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
  no_negative_occurrence_db_b dbi1 ϕ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk35b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk35b"><hr></label><div class="goal-conclusion">dbi1 ≠ dbi2
→ no_positive_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
  no_positive_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk35c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk35c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2
→ no_negative_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
  no_negative_occurrence_db_b dbi1 ϕ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk35d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk35d"><hr></label><div class="goal-conclusion">dbi1 ≠ dbi2
→ no_positive_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
  no_positive_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk35e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk35e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2
→ no_negative_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
  no_negative_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk35f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk35f"><span class="nb">move</span>: dbi1 dbi2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk360" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk360"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi1 dbi2 Hdbi; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar dbi2
   <span class="kr">else</span> patt_free_svar x) =
no_negative_occurrence_db_b dbi1 (patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk361" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk361"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_app ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_app ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk362" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk362"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_imp ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk363" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk363"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_exists ϕ^{{svar:X↦dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_exists ϕ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk364" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk364"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_mu ϕ^{{svar:X↦S dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_mu ϕ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk365" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk365">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar dbi2
   <span class="kr">else</span> patt_free_svar x) =
no_negative_occurrence_db_b dbi1 (patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk366" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk366">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_app ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_app ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk367" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk367"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk368" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk368"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk369" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk369"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk36a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk36a"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk36b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk36b"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk36c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk36c"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2 =
no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk36d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk36d"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2 =
no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk36e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk36e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_imp ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk36f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk36f"><span class="nb">unfold</span> no_negative_occurrence_db_b <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk370" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk370"><span class="nb">fold</span> (no_positive_occurrence_db_b dbi1 (ϕ1^{{svar: X ↦ dbi2}})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk371" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk371"><span class="nb">fold</span> (no_negative_occurrence_db_b dbi1 (ϕ2^{{svar: X ↦ dbi2}})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk372" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk372"><span class="nb">rewrite</span> no_positive_occurrence_svar_quantify_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk373" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk373"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk374" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk374"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk375" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk375"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk376" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk376"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2 =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk377" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk377"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi1 ϕ2 =
no_negative_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk378" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk378">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_exists ϕ^{{svar:X↦dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_exists ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk379" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk379"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
no_negative_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk37a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk37a"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk37b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk37b"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ =
no_negative_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk37c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk37c"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ =
no_negative_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk37d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk37d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1
  (patt_mu ϕ^{{svar:X↦S dbi2}}) =
no_negative_occurrence_db_b dbi1 (patt_mu ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk37e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk37e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b (S dbi1)
  ϕ^{{svar:X↦S dbi2}} =
no_negative_occurrence_db_b (S dbi1) ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk37f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk37f"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S dbi1 ≠ S dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk380" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk380"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b (S dbi1) ϕ =
no_negative_occurrence_db_b (S dbi1) ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk381" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk381"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b (S dbi1) ϕ =
no_negative_occurrence_db_b (S dbi1) ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk382" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk382">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2
→ no_positive_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
  no_positive_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk383" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk383"><span class="nb">move</span>: dbi1 dbi2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk384" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk384"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi1 dbi2 Hdbi; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar dbi2
   <span class="kr">else</span> patt_free_svar x) =
no_positive_occurrence_db_b dbi1 (patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk385" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk385"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_app ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_app ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk386" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk386"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_imp ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk387" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk387"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_exists ϕ^{{svar:X↦dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_exists ϕ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk388" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk388"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_mu ϕ^{{svar:X↦S dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_mu ϕ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk389" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk389">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar dbi2
   <span class="kr">else</span> patt_free_svar x) =
no_positive_occurrence_db_b dbi1 (patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk38a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk38a">case_match; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (dbi2 = dbi1) <span class="kr">then</span> false <span class="kr">else</span> true) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk38b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>X ≠ x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">right</span> n</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk38b"><hr></label><div class="goal-conclusion">true = true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk38c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk38c"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (dbi2 = dbi1) <span class="kr">then</span> false <span class="kr">else</span> true) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk38d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk38d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_app ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_app ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk38e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk38e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk38f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk38f"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk390" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk390"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk391" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk391"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk392" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk392"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk393" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk393"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2 =
no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk394" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk394"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2 =
no_positive_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk395" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk395">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_imp ϕ1^{{svar:X↦dbi2}} ϕ2^{{svar:X↦dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk396" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk396"><span class="nb">unfold</span> no_positive_occurrence_db_b <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk397" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk397"><span class="nb">fold</span> (no_negative_occurrence_db_b dbi1 (ϕ1^{{svar: X ↦ dbi2}})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk398" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk398"><span class="nb">fold</span> (no_positive_occurrence_db_b dbi1 (ϕ2^{{svar: X ↦ dbi2}})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1^{{svar:X↦dbi2}} &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk399" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk399"><span class="nb">rewrite</span> no_negative_occurrence_svar_quantify_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk39a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk39a"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk39b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk39b"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk39c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk39c"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk39d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk39d"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2 =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk39e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk39e"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ1^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ2^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ2</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi1 ϕ2 =
no_positive_occurrence_db_b dbi1 (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk39f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk39f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_exists ϕ^{{svar:X↦dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_exists ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a0"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ^{{svar:X↦dbi2}} =
no_positive_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a1"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi1 ≠ dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3a2"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ =
no_positive_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a3"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1 ϕ =
no_positive_occurrence_db_b dbi1 ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi1
  (patt_mu ϕ^{{svar:X↦S dbi2}}) =
no_positive_occurrence_db_b dbi1 (patt_mu ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b (S dbi1)
  ϕ^{{svar:X↦S dbi2}} =
no_positive_occurrence_db_b (S dbi1) ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a6"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S dbi1 ≠ S dbi2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3a7"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b (S dbi1) ϕ =
no_positive_occurrence_db_b (S dbi1) ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a8"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_negative_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_negative_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_negative_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>no_positive_occurrence_svar_quantify_2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">X</span> : svar) 
  (<span class="nv">dbi1</span>
   <span class="nv">dbi2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b
      dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b
      dbi1 ϕ</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi1</span> <span class="nv">dbi2</span> : db_index,
  dbi1 ≠ dbi2
  → no_positive_occurrence_db_b dbi1
      ϕ^{{svar:X↦dbi2}} =
    no_positive_occurrence_db_b dbi1 ϕ</span></span></span><br><span><var>dbi1, dbi2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hdbi</var><span class="hyp-type"><b>: </b><span>dbi1 ≠ dbi2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b (S dbi1) ϕ =
no_positive_occurrence_db_b (S dbi1) ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3a9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3a9"><span class="kn">Lemma</span> <span class="nf">well_formed_positive_svar_quantify</span> <span class="nv">X</span> <span class="nv">dbi</span> <span class="nv">ϕ</span>:
    well_formed_positive ϕ -&gt;
    well_formed_positive (ϕ^{{svar: X ↦ dbi}}) = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ
→ well_formed_positive ϕ^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3aa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3aa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ
→ well_formed_positive ϕ^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ab" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ab"><span class="nb">intros</span> Hϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ac" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ac"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ad" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ad"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x)</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar dbi
   <span class="kr">else</span> patt_free_svar x) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3ae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2)</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3ae"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3af" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2)</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3af"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ)</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3b0"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{svar:X↦S dbi}} &amp;&amp;
well_formed_positive ϕ^{{svar:X↦S dbi}} = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X, x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x)</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x)
   <span class="kr">then</span> patt_bound_svar dbi
   <span class="kr">else</span> patt_free_svar x) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2)</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b3"><span class="nb">simpl</span> <span class="kr">in</span> Hϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b4">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b5"><span class="nb">specialize</span> (IHϕ1 <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b6"><span class="nb">specialize</span> (IHϕ2 <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ2^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b7"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ2^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b8"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ2^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3b9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3b9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2)</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ba" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ba"><span class="nb">simpl</span> <span class="kr">in</span> Hϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3bb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3bb">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ1^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3bc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3bc"><span class="nb">specialize</span> (IHϕ1 <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
    well_formed_positive ϕ2^{{svar:X↦dbi}} =
    true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3bd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3bd"><span class="nb">specialize</span> (IHϕ2 <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ2^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^{{svar:X↦dbi}} &amp;&amp;
well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3be" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3be"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ2^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2^{{svar:X↦dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3bf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3bf"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ1^{{svar:X↦dbi}} = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_positive ϕ2^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ)</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{svar:X↦S dbi}} &amp;&amp;
well_formed_positive ϕ^{{svar:X↦S dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c1"><span class="nb">simpl</span> <span class="kr">in</span> Hϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>Hϕ</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{svar:X↦S dbi}} &amp;&amp;
well_formed_positive ϕ^{{svar:X↦S dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c2">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ
→ <span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{svar:X↦S dbi}} &amp;&amp;
well_formed_positive ϕ^{{svar:X↦S dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c3"><span class="nb">specialize</span> (IHϕ <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{svar:X↦S dbi}} &amp;&amp;
well_formed_positive ϕ^{{svar:X↦S dbi}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c4"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{svar:X↦S dbi}} &amp;&amp;
true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c5"><span class="nb">rewrite</span> no_negative_occurrence_svar_quantify_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ≠ S dbi</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3c6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3c6"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp; true = true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c7"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index, well_formed_positive ϕ^{{svar:X↦dbi}} = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Lemma bevar_occur_positivity ψ dbi :</span>
<span class="c">    bsvar_occur ψ dbi = false -&gt;</span>
<span class="c">    no_negative_occurrence_db_b dbi ψ = true /\ no_positive_occurrence_db_b dbi ψ.</span>
<span class="c">  Proof.</span>
<span class="c">    induction ψ; intros H; cbn; auto.</span>
<span class="c">    * simpl in H. case_match; auto.</span>
<span class="c">    * *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3c8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3c8"><span class="kn">Lemma</span> <span class="nf">nno_free_svar_subst</span> <span class="nv">dbi</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">X</span>:
    well_formed_closed_mu_aux ψ dbi -&gt;
    no_negative_occurrence_db_b dbi (ϕ^[[svar: X ↦ ψ]])
    = no_negative_occurrence_db_b dbi ϕ
  <span class="kr">with</span> npo_free_svar_subst dbi ϕ ψ X:
    well_formed_closed_mu_aux ψ dbi -&gt;
    no_positive_occurrence_db_b dbi (ϕ^[[svar: X ↦ ψ]])
    = no_positive_occurrence_db_b dbi ϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ dbi
→ no_negative_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
  no_negative_occurrence_db_b dbi ϕ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3c9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3c9"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ψ dbi
→ no_positive_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
  no_positive_occurrence_db_b dbi ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ca" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ dbi
→ no_negative_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
  no_negative_occurrence_db_b dbi ϕ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3cb"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ψ dbi
→ no_positive_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
  no_positive_occurrence_db_b dbi ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3cc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3cc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ dbi
→ no_negative_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
  no_negative_occurrence_db_b dbi ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3cd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3cd"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ce" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ce"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hwf; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
no_negative_occurrence_db_b dbi (patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3cf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3cf"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_app ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_app ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3d0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3d0"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_imp ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_imp ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3d1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3d1"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_exists ϕ^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_exists ϕ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3d2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3d2"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_mu ϕ^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_mu ϕ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3d3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3d3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
no_negative_occurrence_db_b dbi (patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3d4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3d4">case_match; <span class="nb">cbn</span>; [|<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ψ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3d5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3d5"><span class="nb">eapply</span> Private_wfc_impl_no_neg_pos_occ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="nl">?maxsvar</span> = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3d6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3d6"><hr></label><div class="goal-conclusion"><span class="nl">?maxsvar</span> ≤ dbi</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3d7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3d7"><span class="bp">exact</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi ≤ dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3d8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3d8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_app ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_app ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3d9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3d9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1^[[svar:X↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3da" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3da"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3db" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3db">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_imp ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3dc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3dc"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi ϕ1^[[svar:X↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3dd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3dd"><span class="nb">fold</span> (no_positive_occurrence_db_b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1^[[svar:X↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3de" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3de"><span class="nb">rewrite</span> nno_free_svar_subst; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1^[[svar:X↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 =
no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> npo_free_svar_subst; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3df" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3df">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_exists ϕ^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_exists ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e0"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
no_negative_occurrence_db_b dbi ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi
  (patt_mu ϕ^[[svar:X↦ψ]]) =
no_negative_occurrence_db_b dbi (patt_mu ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e2"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b (S dbi) ϕ^[[svar:X↦ψ]] =
no_negative_occurrence_db_b (S dbi) ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e3"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ (S dbi)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e4"><span class="nb">eapply</span> well_formed_closed_mu_aux_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?ind_svar1</span> ≤ S dbi</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3e5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3e5"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="nl">?ind_svar1</span> = true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e6"><span class="mi">2</span>: <span class="bp">exact</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_negative_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi ≤ S dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ dbi
→ no_positive_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
  no_positive_occurrence_db_b dbi ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e8"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3e9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3e9"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hwf; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
no_positive_occurrence_db_b dbi (patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3ea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3ea"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_app ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_app ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3eb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3eb"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_imp ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_imp ϕ1 ϕ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3ec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3ec"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_exists ϕ^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_exists ϕ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3ed" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3ed"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_mu ϕ^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_mu ϕ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ee" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ee">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
no_positive_occurrence_db_b dbi (patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ef" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ef">case_match; <span class="nb">cbn</span>; [|<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ψ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f0"><span class="nb">eapply</span> Private_wfc_impl_no_neg_pos_occ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="nl">?maxsvar</span> = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk3f1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk3f1"><hr></label><div class="goal-conclusion"><span class="nl">?maxsvar</span> ≤ dbi</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f2"><span class="bp">exact</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi ≤ dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_app ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_app ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f4"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1^[[svar:X↦ψ]] &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f5"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_imp ϕ1^[[svar:X↦ψ]] ϕ2^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_imp ϕ1 ϕ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f7"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi ϕ1^[[svar:X↦ψ]] &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f8"><span class="nb">fold</span> (no_negative_occurrence_db_b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1^[[svar:X↦ψ]] &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3f9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3f9"><span class="nb">rewrite</span> nno_free_svar_subst; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ1^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ2^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ2</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2^[[svar:X↦ψ]] =
no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3fa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3fa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_exists ϕ^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_exists ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3fb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3fb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ^[[svar:X↦ψ]] =
no_positive_occurrence_db_b dbi ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3fc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3fc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi
  (patt_mu ϕ^[[svar:X↦ψ]]) =
no_positive_occurrence_db_b dbi (patt_mu ϕ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3fd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3fd"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b (S dbi) ϕ^[[svar:X↦ψ]] =
no_positive_occurrence_db_b (S dbi) ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3fe" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3fe"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ (S dbi)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk3ff" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk3ff"><span class="nb">eapply</span> well_formed_closed_mu_aux_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?ind_svar1</span> ≤ S dbi</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk400" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk400"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="nl">?ind_svar1</span> = true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk401" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk401"><span class="mi">2</span>: <span class="bp">exact</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_negative_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_negative_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>npo_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">dbi</span> : db_index) 
  (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ
    dbi
  → no_positive_occurrence_db_b
      dbi ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b
      dbi ϕ</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ψ dbi
  → no_positive_occurrence_db_b dbi
      ϕ^[[svar:X↦ψ]] =
    no_positive_occurrence_db_b dbi ϕ</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi ≤ S dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk402" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk402"><span class="kn">Lemma</span> <span class="nf">wfp_free_svar_subst_1</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">X</span>:
    well_formed_closed ψ = true -&gt;
    well_formed_positive ψ = true -&gt;
    well_formed_positive ϕ = true -&gt;
    well_formed_positive (ϕ^[[svar: X ↦ ψ]]) = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed ψ = true
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk403" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk403"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed ψ = true
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk404" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk404"><span class="nb">intros</span> wfcψ wfpψ wfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk405" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk405"><span class="nb">induction</span> ϕ; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk406" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk406"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk407" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk407"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk408" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk408"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk409" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk409">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk40a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk40a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk40b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk40b"><span class="nb">simpl</span> <span class="kr">in</span> wfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk40c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk40c">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk40d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk40d"><span class="nb">rewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk40e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk40e"><span class="nb">rewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk40f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk40f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk410" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk410"><span class="nb">simpl</span> <span class="kr">in</span> wfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk411" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk411">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk412" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk412"><span class="nb">rewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk413" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk413"><span class="nb">rewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk414" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk414">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk415" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk415"><span class="nb">simpl</span> <span class="kr">in</span> wfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>wfpϕ</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk416" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk416">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk417" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk417"><span class="nb">specialize</span> (IHϕ H0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk418" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk418"><span class="nb">rewrite</span> -&gt; IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp; true =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk419" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk419"><span class="nb">rewrite</span> nno_free_svar_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk41a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk41a"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp; true = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk41b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk41b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk41c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk41c"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> wfcψ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span> = true
∧ well_formed_closed_ex_aux ψ <span class="mi">0</span> = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> wfcψ.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk41d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk41d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk41e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk41e"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>wfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed ψ = true</span></span></span><br><span><var>wfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk41f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk41f"><span class="kn">Lemma</span> <span class="nf">wfp_free_svar_subst</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">X</span>:
    well_formed_closed_mu_aux ψ <span class="mi">0</span> -&gt;
    well_formed_positive ψ = true -&gt;
    well_formed_positive ϕ = true -&gt;
    svar_has_negative_occurrence X ϕ = false -&gt;
    well_formed_positive (ϕ^[[svar: X ↦ ψ]]) = true
  <span class="kr">with</span> wfp_neg_free_svar_subst ϕ ψ X:
    well_formed_closed_mu_aux ψ <span class="mi">0</span> -&gt;
    well_formed_positive ψ = true -&gt;
    well_formed_positive ϕ = true -&gt;
    svar_has_positive_occurrence X ϕ = false -&gt;
    well_formed_positive (ϕ^[[svar: X ↦ ψ]]) = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span>
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → svar_has_negative_occurrence X ϕ = false
      → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk420" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk420"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span>
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → svar_has_positive_occurrence X ϕ = false
      → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk421" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk421"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span>
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → svar_has_negative_occurrence X ϕ = false
      → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk422" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk422"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span>
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → svar_has_positive_occurrence X ϕ = false
      → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk423" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk423">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span>
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → svar_has_negative_occurrence X ϕ = false
      → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk424" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk424"><span class="nb">intros</span> Hwfcψ Hwfpψ Hwfpϕ Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk425" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk425"><span class="nb">induction</span> ϕ; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X
  (patt_free_svar x) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk426" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X
  (patt_app ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk426"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk427" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X
  (patt_imp ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk427"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk428" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X (patt_mu ϕ) =
false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk428"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk429" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk429">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X
  (patt_free_svar x) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk42a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk42a">case_match; [|<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X
  (patt_free_svar x) = false</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ψ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk42b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk42b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X
  (patt_app ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk42c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk42c"><span class="nb">cbn</span> <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1
|| svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk42d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk42d"><span class="nb">cbn</span> <span class="kr">in</span> Hwfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1
|| svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk42e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk42e"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false
∧ svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk42f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk42f">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk430" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk430"><span class="nb">specialize</span> (IHϕ1 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk431" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk431"><span class="nb">specialize</span> (IHϕ2 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk432" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk432">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X
  (patt_imp ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk433" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk433"><span class="nb">cbn</span> <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1
|| svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk434" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk434"><span class="nb">cbn</span> <span class="kr">in</span> Hwfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1
|| svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk435" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk435"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false
∧ svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk436" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk436">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk437" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk437"><span class="nb">pose proof</span> (IH1 := wfp_neg_free_svar_subst ϕ1 ψ X <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk438" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk438">feed <span class="nb">specialize</span> IH1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ψ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk439" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk439"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1 = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk43a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk43a"><hr></label><div class="goal-conclusion">svar_has_positive_occurrence X ϕ1 = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk43b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk43b"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk43c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk43c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ψ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk43d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk43d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk43e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk43e"><hr></label><div class="goal-conclusion">svar_has_positive_occurrence X ϕ1 = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk43f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk43f"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk440" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk440">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk441" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk441">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar_has_positive_occurrence X ϕ1 = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk442" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk442"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk443" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk443">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_positive_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar_has_positive_occurrence X ϕ1 = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk444" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk444">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_negative_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk445" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk445"><span class="nb">specialize</span> (IHϕ2 <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_positive_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_negative_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ2 = false
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk446" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk446">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X (patt_mu ϕ) =
false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk447" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk447"><span class="nb">cbn</span> <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk448" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk448"><span class="nb">cbn</span> <span class="kr">in</span> Hwfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk449" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk449">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk44a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk44a"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk44b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk44b"><hr></label><div class="goal-conclusion">svar_has_negative_occurrence X ϕ = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk44c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk44c"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp; true =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk44d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk44d"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar_has_negative_occurrence X ϕ = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk44e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk44e"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp; true =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk44f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk44f"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp; true =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk450" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk450">split_and!; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk451" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk451"><span class="nb">rewrite</span> nno_free_svar_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk452" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk452"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk453" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk453"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_negative_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_negative_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk454" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk454">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span>
→ well_formed_positive ψ = true
  → well_formed_positive ϕ = true
    → svar_has_positive_occurrence X ϕ = false
      → well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk455" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk455"><span class="nb">intros</span> Hwfcψ Hwfpψ Hwfpϕ Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk456" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk456"><span class="nb">induction</span> ϕ; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X
  (patt_free_svar x) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk457" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X
  (patt_app ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk457"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk458" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X
  (patt_imp ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk458"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk459" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X (patt_mu ϕ) =
false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk459"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk45a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk45a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X
  (patt_free_svar x) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive
  (<span class="kr">if</span> decide (X = x) <span class="kr">then</span> ψ <span class="kr">else</span> patt_free_svar x) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk45b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk45b">case_match; [|<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_free_svar x) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X
  (patt_free_svar x) = false</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X = x</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (X = x) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ψ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk45c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk45c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X
  (patt_app ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk45d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk45d"><span class="nb">cbn</span> <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_app ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1
|| svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk45e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk45e"><span class="nb">cbn</span> <span class="kr">in</span> Hwfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1
|| svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk45f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk45f"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false
∧ svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk460" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk460">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk461" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk461"><span class="nb">specialize</span> (IHϕ1 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk462" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk462"><span class="nb">specialize</span> (IHϕ2 <span class="kp">ltac</span>:(<span class="bp">assumption</span>) <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk463" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk463">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X
  (patt_imp ϕ1 ϕ2) = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk464" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk464"><span class="nb">cbn</span> <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_imp ϕ1 ϕ2) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1
|| svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk465" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk465"><span class="nb">cbn</span> <span class="kr">in</span> Hwfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1
|| svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk466" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk466"><span class="nb">apply</span> orb_false_iff <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 &amp;&amp;
well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;)
       <span class="kr">then</span> true
       <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false
∧ svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk467" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk467">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk468" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk468"><span class="nb">pose proof</span> (IH1 := wfp_free_svar_subst ϕ1 ψ X <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk469" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk469">feed <span class="nb">specialize</span> IH1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ψ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk46a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk46a"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1 = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk46b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk46b"><hr></label><div class="goal-conclusion">svar_has_negative_occurrence X ϕ1 = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk46c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk46c"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk46d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk46d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ψ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk46e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk46e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk46f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk46f"><hr></label><div class="goal-conclusion">svar_has_negative_occurrence X ϕ1 = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk470" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk470"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk471" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk471">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk472" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk472">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar_has_negative_occurrence X ϕ1 = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk473" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk473"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk474" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk474">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true
→ well_formed_positive ϕ1 = true
  → svar_has_negative_occurrence X ϕ1 = false
    → well_formed_positive ϕ1^[[svar:X↦ψ]] =
      true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar_has_negative_occurrence X ϕ1 = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk475" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk475">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true
→ svar_has_positive_occurrence X ϕ2 = false
  → well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk476" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk476"><span class="nb">specialize</span> (IHϕ2 <span class="kp">ltac</span>:(<span class="bp">assumption</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> svar_has_positive_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_free_svar X&#39; =&gt;
       <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> true <span class="kr">else</span> false
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_positive_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_positive_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">with</span> svar_has_negative_occurrence
   (X : svar) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       svar_has_negative_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       svar_has_positive_occurrence X ϕ₁
       || svar_has_negative_occurrence X ϕ₂
   | patt_exists ϕ&#39; | patt_mu ϕ&#39; =&gt;
       svar_has_negative_occurrence X ϕ&#39;
   | _ =&gt; false
   <span class="kr">end</span>
 <span class="kr">for</span>
 svar_has_negative_occurrence) X ϕ1 = false</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true
→ svar_has_positive_occurrence X ϕ1 = false
  → well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ2 = false
→ well_formed_positive ϕ2^[[svar:X↦ψ]] = true</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">split_and!; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk477" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk477">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X (patt_mu ϕ) =
false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk478" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk478"><span class="nb">cbn</span> <span class="kr">in</span> Hnoneg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_mu ϕ) = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk479" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk479"><span class="nb">cbn</span> <span class="kr">in</span> Hwfpϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>Hwfpϕ</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk47a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk47a">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk47b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk47b"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk47c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk47c"><hr></label><div class="goal-conclusion">svar_has_positive_occurrence X ϕ = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk47d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk47d"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp; true =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk47e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk47e"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar_has_positive_occurrence X ϕ = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk47f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk47f"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp; true =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk480" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk480"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] &amp;&amp; true =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk481" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk481">split_and!; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[svar:X↦ψ]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk482" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk482"><span class="nb">rewrite</span> nno_free_svar_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ψ <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk483" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk483"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk484" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk484"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>wfp_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_negative_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>wfp_neg_free_svar_subst</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) (<span class="nv">X</span> : svar),
  well_formed_closed_mu_aux
    ψ <span class="mi">0</span>
  → well_formed_positive ψ =
    true
    → well_formed_positive ϕ =
      true
      → svar_has_positive_occurrence
          X ϕ = false
        → well_formed_positive
            ϕ^[[svar:X↦ψ]] =
          true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>Hwfcψ</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ψ <span class="mi">0</span></span></span></span><br><span><var>Hwfpψ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ψ = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnoneg</var><span class="hyp-type"><b>: </b><span>svar_has_positive_occurrence X ϕ = false</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true
→ svar_has_positive_occurrence X ϕ = false
  → well_formed_positive ϕ^[[svar:X↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk485" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk485"><span class="kn">Lemma</span> <span class="nf">count_evar_occurrences_bevar_subst</span> <span class="nv">pcEvar</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">k</span>:
    count_evar_occurrences pcEvar ψ = <span class="mi">0</span> -&gt;
    count_evar_occurrences pcEvar (ϕ^[<span class="nb">evar</span>: k ↦ ψ]) = count_evar_occurrences pcEvar ϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar ψ = <span class="mi">0</span>
→ count_evar_occurrences pcEvar ϕ^[<span class="nb">evar</span>:k↦ψ] =
  count_evar_occurrences pcEvar ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk486" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk486"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar ψ = <span class="mi">0</span>
→ count_evar_occurrences pcEvar ϕ^[<span class="nb">evar</span>:k↦ψ] =
  count_evar_occurrences pcEvar ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk487" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk487"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar ψ = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar ϕ^[<span class="nb">evar</span>:k↦ψ] =
count_evar_occurrences pcEvar ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk488" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk488"><span class="nb">move</span>: k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar ψ = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">k</span> : db_index,
  count_evar_occurrences pcEvar ϕ^[<span class="nb">evar</span>:k↦ψ] =
  count_evar_occurrences pcEvar ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk489" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk489"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> k; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar ψ = <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar
  <span class="kr">match</span> compare_nat n k <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ψ
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk48a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk48a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences pcEvar ψ = <span class="mi">0</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar
  <span class="kr">match</span> compare_nat n k <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; ψ
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk48b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk48b"><span class="kn">Lemma</span> <span class="nf">count_evar_occurrences_evar_open</span> <span class="nv">pcEvar</span> <span class="nv">ϕ</span> <span class="nv">x</span>:
    pcEvar &lt;&gt; x -&gt;
    count_evar_occurrences pcEvar (ϕ^{<span class="nb">evar</span>: <span class="mi">0</span> ↦ x}) = count_evar_occurrences pcEvar ϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pcEvar ≠ x
→ count_evar_occurrences pcEvar ϕ^{<span class="nb">evar</span>:<span class="mi">0</span>↦x} =
  count_evar_occurrences pcEvar ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk48c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk48c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pcEvar ≠ x
→ count_evar_occurrences pcEvar ϕ^{<span class="nb">evar</span>:<span class="mi">0</span>↦x} =
  count_evar_occurrences pcEvar ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk48d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk48d"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>pcEvar ≠ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar ϕ^{<span class="nb">evar</span>:<span class="mi">0</span>↦x} =
count_evar_occurrences pcEvar ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk48e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk48e"><span class="nb">apply</span> count_evar_occurrences_bevar_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>pcEvar ≠ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences pcEvar (patt_free_evar x) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk48f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk48f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>pcEvar</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>pcEvar ≠ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x = pcEvar) <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk490" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk490"><span class="kn">Lemma</span> <span class="nf">count_evar_occurrences_svar_open</span> <span class="nv">x</span> <span class="nv">dbi</span> <span class="nv">ϕ</span> <span class="nv">ψ</span>:
    count_evar_occurrences x ψ = <span class="mi">0</span> -&gt;
    count_evar_occurrences x (ϕ^[svar: dbi ↦ ψ]) = count_evar_occurrences x ϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences x ψ = <span class="mi">0</span>
→ count_evar_occurrences x ϕ^[svar:dbi↦ψ] =
  count_evar_occurrences x ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk491" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk491"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences x ψ = <span class="mi">0</span>
→ count_evar_occurrences x ϕ^[svar:dbi↦ψ] =
  count_evar_occurrences x ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk492" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk492"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  count_evar_occurrences x ψ = <span class="mi">0</span>
  → count_evar_occurrences x ϕ^[svar:dbi↦ψ] =
    count_evar_occurrences x ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk493" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk493"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi H; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_evar_occurrences x ψ = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences x
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; ψ
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk494" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk494"><span class="kn">Lemma</span> <span class="nf">free_evar_subst_bsvar_subst</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">ξ</span> <span class="nv">x</span> <span class="nv">dbi</span>:
    well_formed_closed_mu_aux ξ <span class="mi">0</span> -&gt;
    evar_is_fresh_in x ψ -&gt;
    (ϕ^[svar: dbi ↦ ψ])^[[<span class="nb">evar</span>:x ↦ ξ]]
    = (ϕ^[[<span class="nb">evar</span>:x ↦ ξ]])^[svar: dbi ↦ ψ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ξ <span class="mi">0</span>
→ evar_is_fresh_in x ψ
  → ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
    ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk495" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk495"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ξ <span class="mi">0</span>
→ evar_is_fresh_in x ψ
  → ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
    ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk496" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk496"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk497" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk497"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi H1 H2; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x = x0) <span class="kr">then</span> ξ <span class="kr">else</span> patt_free_evar x0) =
(<span class="kr">if</span> decide (x = x0) <span class="kr">then</span> ξ <span class="kr">else</span> patt_free_evar x0)^[svar:dbi↦ψ]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk498" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk498"><hr></label><div class="goal-conclusion"><span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; ψ
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span>^[[<span class="nb">evar</span>:x↦ξ]] =
<span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; ψ
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk499" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk499"><hr></label><div class="goal-conclusion">patt_app ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]]
  ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_app ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk49a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk49a"><hr></label><div class="goal-conclusion">patt_imp ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]]
  ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_imp ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk49b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk49b"><hr></label><div class="goal-conclusion">patt_exists ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_exists ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk49c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk49c"><hr></label><div class="goal-conclusion">patt_mu ϕ^[svar:S dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_mu ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:S dbi↦ψ]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk49d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk49d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x = x0) <span class="kr">then</span> ξ <span class="kr">else</span> patt_free_evar x0) =
(<span class="kr">if</span> decide (x = x0) <span class="kr">then</span> ξ <span class="kr">else</span> patt_free_evar x0)^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk49e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk49e"><span class="kp">repeat</span> case_match; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ξ = ξ^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk49f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk49f"><span class="nb">erewrite</span> well_formed_bsvar_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ξ = ξ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4a0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4a0"><hr></label><div class="goal-conclusion">dbi ≥ <span class="nl">?k</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4a1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4a1"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ξ <span class="nl">?k</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a2"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi ≥ <span class="nl">?k</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4a3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4a3"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ξ <span class="nl">?k</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a4"><span class="mi">2</span>: <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = x0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (x = x0) = <span class="nb">left</span> e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dbi ≥ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; ψ
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span>^[[<span class="nb">evar</span>:x↦ξ]] =
<span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; ψ
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a6"><span class="kp">repeat</span> case_match; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_equal n dbi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ψ^[[<span class="nb">evar</span>:x↦ξ]] = ψ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a7"><span class="nb">apply</span> free_evar_subst_no_occurrence.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_equal n dbi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_evar_occurrences x ψ = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a8"><span class="nb">apply</span> count_evar_occurrences_0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n = dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_equal n dbi e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ free_evars ψ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4a9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4a9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]]
  ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_app ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4aa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4aa"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_app ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ab" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ab">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]]
  ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_imp ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ac" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ac"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ1^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ξ <span class="mi">0</span>
  → evar_is_fresh_in x ψ
    → ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
      ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_imp ϕ1^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]
  ϕ2^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ad" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ξ <span class="mi">0</span>
→ evar_is_fresh_in x ψ
→ ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] = ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_exists ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ae" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ, ξ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ξ <span class="mi">0</span>
→ evar_is_fresh_in x ψ
→ ϕ^[svar:dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] = ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:dbi↦ψ]</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ξ <span class="mi">0</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>evar_is_fresh_in x ψ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu ϕ^[svar:S dbi↦ψ]^[[<span class="nb">evar</span>:x↦ξ]] =
patt_mu ϕ^[[<span class="nb">evar</span>:x↦ξ]]^[svar:S dbi↦ψ]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4af" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4af"><span class="kn">Lemma</span> <span class="nf">wf_svar_open_from_wf_mu</span> <span class="nv">X</span> <span class="nv">ϕ</span>:
    well_formed (patt_mu ϕ) -&gt;
    well_formed (ϕ^{svar: <span class="mi">0</span> ↦ X}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (patt_mu ϕ) → well_formed ϕ^{svar:<span class="mi">0</span>↦X}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (patt_mu ϕ) → well_formed ϕ^{svar:<span class="mi">0</span>↦X}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b1"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (patt_mu ϕ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed ϕ^{svar:<span class="mi">0</span>↦X}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">wf_auto;
    destruct_and!;
        [ (<span class="nb">apply</span> wfp_svar_open; <span class="nb">auto</span>)
        | (<span class="nb">apply</span> wfc_mu_aux_body_mu_imp1; <span class="bp">assumption</span>)
        | (<span class="nb">apply</span> wfc_ex_aux_body_mu_imp1; <span class="bp">assumption</span>)
        ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b2"><span class="kn">Lemma</span> <span class="nf">wfcex_after_subst_impl_wfcex_before</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">x</span> <span class="nv">dbi</span>:
    well_formed_closed_ex_aux (ϕ^[[<span class="nb">evar</span>:x ↦ ψ]]) dbi = true -&gt;
    well_formed_closed_ex_aux ϕ dbi = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi = true
→ well_formed_closed_ex_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi = true
→ well_formed_closed_ex_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b4"><span class="nb">intros</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b5"><span class="nb">move</span>: dbi Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi = true
  → well_formed_closed_ex_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b6"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hsubst; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4b7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4b7"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4b9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4b9"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true
∧ well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
    dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ba" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ba"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4bb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4bb"><span class="nb">specialize</span> (IHϕ1 dbi Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4bc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4bc"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4bd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4bd"><span class="nb">rewrite</span> IHϕ1 IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4be" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4be">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4bf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4bf"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true
∧ well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
    dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c0"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c1"><span class="nb">specialize</span> (IHϕ1 dbi Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c2"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c3"><span class="nb">rewrite</span> IHϕ1 IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c4"><span class="kn">Lemma</span> <span class="nf">wfcmu_after_subst_impl_wfcmu_before</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">x</span> <span class="nv">dbi</span>:
    well_formed_closed_mu_aux (ϕ^[[<span class="nb">evar</span>:x ↦ ψ]]) dbi = true -&gt;
    well_formed_closed_mu_aux ϕ dbi = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi = true
→ well_formed_closed_mu_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi = true
→ well_formed_closed_mu_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c6"><span class="nb">intros</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c7"><span class="nb">move</span>: dbi Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] dbi = true
  → well_formed_closed_mu_aux ϕ dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4c8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4c8"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hsubst; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4c9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4c9"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ca" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ca">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4cb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4cb"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true
∧ well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
    dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4cc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4cc"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4cd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4cd"><span class="nb">specialize</span> (IHϕ1 dbi Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ce" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ce"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4cf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4cf"><span class="nb">rewrite</span> IHϕ1 IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d1"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
true
∧ well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
    dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d2"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d3"><span class="nb">specialize</span> (IHϕ1 dbi Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]] dbi =
  true
  → well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d4"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d5"><span class="nb">rewrite</span> IHϕ1 IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^[[<span class="nb">evar</span>:x↦ψ]]
  dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d6"><span class="kn">Lemma</span> <span class="nf">nno_after_subst_impl_nno_before</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">x</span> <span class="nv">dbi</span>:
    no_negative_occurrence_db_b dbi (ϕ^[[<span class="nb">evar</span>:x ↦ ψ]]) = true -&gt;
    no_negative_occurrence_db_b dbi ϕ = true
  <span class="kr">with</span> npo_after_subst_impl_npo_before ϕ ψ x dbi:
    no_positive_occurrence_db_b dbi (ϕ^[[<span class="nb">evar</span>:x ↦ ψ]]) = true -&gt;
    no_positive_occurrence_db_b dbi ϕ = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ no_negative_occurrence_db_b dbi ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4d7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4d7"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ no_positive_occurrence_db_b dbi ϕ = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4d8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4d8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ no_negative_occurrence_db_b dbi ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4d9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4d9"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ no_positive_occurrence_db_b dbi ϕ = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4da" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ no_negative_occurrence_db_b dbi ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4db" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4db"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true → no_negative_occurrence_db_b dbi ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4dc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4dc"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hsubst; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4dd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4dd"><hr></label><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4de" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4de">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4df" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4df"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
∧ no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e0"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e1"><span class="nb">specialize</span> (IHϕ1 dbi Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e2"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e3"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e4"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e6"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
∧ no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e7"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b 
         (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b 
         (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e8"><span class="nb">fold</span> no_positive_occurrence_db_b <span class="kr">in</span> Hsubst1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4e9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4e9"><span class="nb">fold</span> no_positive_occurrence_db_b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ea" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ea"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_negative_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4eb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4eb"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ec" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ec"><span class="nb">erewrite</span> npo_after_subst_impl_npo_before.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4ed" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4ed"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ee" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ee"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_negative_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_negative_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ef" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ no_positive_occurrence_db_b dbi ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f0"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true → no_positive_occurrence_db_b dbi ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f1"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hsubst; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk4f2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk4f2"><hr></label><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f4"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
∧ no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f5"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f6"><span class="nb">specialize</span> (IHϕ1 dbi Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f7"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f8"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4f9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4f9"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4fa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4fa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4fb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4fb"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
∧ no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4fc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4fc"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b 
         (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi)
       <span class="kr">then</span> false
       <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b 
         (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4fd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4fd"><span class="nb">fold</span> no_negative_occurrence_db_b <span class="kr">in</span> Hsubst1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4fe" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4fe"><span class="nb">fold</span> no_negative_occurrence_db_b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk4ff" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk4ff"><span class="nb">specialize</span> (IHϕ2 dbi Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp;
no_positive_occurrence_db_b dbi ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk500" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk500"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1 &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk501" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk501"><span class="nb">erewrite</span> nno_after_subst_impl_nno_before.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk502" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk502"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk503" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk503"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>nno_after_subst_impl_nno_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_negative_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_negative_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>npo_after_subst_impl_npo_before</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">ϕ</span> <span class="nv">ψ</span> : Pattern) 
  (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">dbi</span> : db_index),
  no_positive_occurrence_db_b
    dbi
    ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
  true
  → no_positive_occurrence_db_b
      dbi ϕ = true</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  no_positive_occurrence_db_b dbi
    ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
  → no_positive_occurrence_db_b dbi ϕ1 = true</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b dbi
  ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b dbi
  ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b dbi ϕ1^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk504" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk504"><span class="kn">Lemma</span> <span class="nf">wfp_after_subst_impl_wfp_before</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">x</span>:
    well_formed_positive (ϕ^[[<span class="nb">evar</span>:x ↦ ψ]]) = true -&gt;
    well_formed_positive ϕ = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk505" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk505"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk506" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk506"><span class="nb">intros</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk507" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk507"><span class="nb">move</span>: Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk508" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk508"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> Hsubst; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk509" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk509"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk50a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk50a"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk50b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk50b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk50c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk50c"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
∧ well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk50d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk50d"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk50e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk50e"><span class="nb">specialize</span> (IHϕ1 Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk50f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk50f"><span class="nb">specialize</span> (IHϕ2 Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk510" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk510"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk511" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk511"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk512" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk512">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk513" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk513"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
∧ well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk514" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk514"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hsubst1 Hsubst2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk515" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk515"><span class="nb">specialize</span> (IHϕ1 Hsubst1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk516" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk516"><span class="nb">specialize</span> (IHϕ2 Hsubst2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk517" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk517"><span class="nb">rewrite</span> IHϕ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk518" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk518"><span class="nb">rewrite</span> IHϕ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2 = true</span></span></span><br><span><var>Hsubst1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>Hsubst2</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk519" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk519">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true → well_formed_positive ϕ = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] &amp;&amp;
well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk51a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk51a"><span class="nb">apply</span> andb_prop <span class="kr">in</span> Hsubst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true → well_formed_positive ϕ = true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
true
∧ well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk51b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk51b"><span class="nb">destruct</span> Hsubst <span class="kr">as</span> [Hnno Hsubst].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true → well_formed_positive ϕ = true</span></span></span><br><span><var>Hnno</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk51c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk51c"><span class="nb">specialize</span> (IHϕ Hsubst).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnno</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk51d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk51d"><span class="nb">rewrite</span> IHϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnno</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk51e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk51e"><span class="nb">erewrite</span> nno_after_subst_impl_nno_before.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnno</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk51f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnno</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk51f"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk520" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk520"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ = true</span></span></span><br><span><var>Hnno</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:x↦ψ]] =
true</span></span></span><br><span><var>Hsubst</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk521" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk521"><span class="kn">Lemma</span> <span class="nf">wf_after_subst_impl_wf_before</span> <span class="nv">ϕ</span> <span class="nv">ψ</span> <span class="nv">x</span>:
    well_formed (ϕ^[[<span class="nb">evar</span>:x ↦ ψ]]) = true -&gt;
    well_formed ϕ = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk522" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk522"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true
→ well_formed ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk523" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk523"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk524" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk524"><span class="nb">unfold</span> well_formed,well_formed_closed <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>[&amp;&amp; well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]],
    well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span>
  &amp; well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span>] =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive ϕ,
    well_formed_closed_mu_aux ϕ <span class="mi">0</span>
  &amp; well_formed_closed_ex_aux ϕ <span class="mi">0</span>] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk525" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk525">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive ϕ,
    well_formed_closed_mu_aux ϕ <span class="mi">0</span>
  &amp; well_formed_closed_ex_aux ϕ <span class="mi">0</span>] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk526" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk526">split_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk527" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk527"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ <span class="mi">0</span> = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk528" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk528"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ <span class="mi">0</span> = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk529" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk529">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk52a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk52a"><span class="nb">eapply</span> wfp_after_subst_impl_wfp_before.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk52b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk52b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk52c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk52c"><span class="nb">eapply</span> wfcmu_after_subst_impl_wfcmu_before.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk52d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk52d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk52e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk52e"><span class="nb">eapply</span> wfcex_after_subst_impl_wfcex_before.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^[[<span class="nb">evar</span>:x↦ψ]] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:x↦ψ]] <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk52f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk52f"><span class="kn">Lemma</span> <span class="nf">wf_emplaced_impl_wf_context</span> (<span class="nv">C</span> : PatternCtx) (<span class="nv">ψ</span> : Pattern) :
    well_formed (emplace C ψ) = true -&gt;
    PC_wf C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (emplace C ψ) = true → PC_wf C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk530" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk530"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (emplace C ψ) = true → PC_wf C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk531" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk531"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (emplace C ψ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC_wf C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk532" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk532"><span class="nb">unfold</span> emplace <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (pcPattern C)^[[<span class="nb">evar</span>:pcEvar C↦ψ]] =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC_wf C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk533" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk533"><span class="nb">unfold</span> PC_wf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (pcPattern C)^[[<span class="nb">evar</span>:pcEvar C↦ψ]] =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (pcPattern C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk534" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk534"><span class="nb">eapply</span> wf_after_subst_impl_wf_before.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>PatternCtx</span></span></span><br><span><var>ψ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (pcPattern C)^[[<span class="nb">evar</span>:pcEvar C↦ψ]] =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (pcPattern C)^[[<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?ψ</span>]] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk535" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk535"><span class="kn">Global Instance</span> <span class="nf">evar_is_fresh_in_dec</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">p</span> : Pattern) :
    Decision (evar_is_fresh_in x p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (evar_is_fresh_in x p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk536" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk536"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (evar_is_fresh_in x p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk537" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk537"><span class="nb">unfold</span> evar_is_fresh_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (x ∉ free_evars p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk538" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk538"><span class="nb">apply</span> not_dec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (x ∈ free_evars p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> gset_elem_of_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">evar_is_fresh_in_list</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">l</span> : list Pattern) :=
    Forall (evar_is_fresh_in x) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk539" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk539"><span class="kn">Global Instance</span> <span class="nf">evar_is_fresh_in_list_dec</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">l</span> : list Pattern) :
    Decision (evar_is_fresh_in_list x l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (evar_is_fresh_in_list x l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk53a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk53a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (evar_is_fresh_in_list x l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk53b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk53b"><span class="nb">unfold</span> Decision.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{evar_is_fresh_in_list x l} +
{¬ evar_is_fresh_in_list x l}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk53c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk53c"><span class="nb">unfold</span> evar_is_fresh_in_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Forall (evar_is_fresh_in x) l} +
{¬ Forall (evar_is_fresh_in x) l}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk53d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk53d"><span class="nb">apply</span> Forall_dec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">x0</span> : Pattern, Decision (evar_is_fresh_in x x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk53e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk53e"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (evar_is_fresh_in x p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> evar_is_fresh_in_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk53f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk53f"><span class="kn">Global Instance</span> <span class="nf">svar_is_fresh_in_dec</span> (<span class="nv">X</span> : svar) (<span class="nv">p</span> : Pattern) :
    Decision (svar_is_fresh_in X p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (svar_is_fresh_in X p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk540" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk540"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (svar_is_fresh_in X p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk541" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk541"><span class="nb">unfold</span> svar_is_fresh_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (X ∉ free_svars p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk542" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk542"><span class="nb">apply</span> not_dec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (X ∈ free_svars p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> gset_elem_of_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">svar_is_fresh_in_list</span> (<span class="nv">X</span> : svar) (<span class="nv">l</span> : list Pattern) :=
    Forall (svar_is_fresh_in X) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk543" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk543"><span class="kn">Global Instance</span> <span class="nf">svar_is_fresh_in_list_dec</span> (<span class="nv">X</span> : svar) (<span class="nv">l</span> : list Pattern) :
    Decision (svar_is_fresh_in_list X l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (svar_is_fresh_in_list X l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk544" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk544"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (svar_is_fresh_in_list X l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk545" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk545"><span class="nb">unfold</span> Decision.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{svar_is_fresh_in_list X l} +
{¬ svar_is_fresh_in_list X l}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk546" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk546"><span class="nb">unfold</span> svar_is_fresh_in_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Forall (svar_is_fresh_in X) l} +
{¬ Forall (svar_is_fresh_in X) l}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk547" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk547"><span class="nb">apply</span> Forall_dec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">x</span> : Pattern, Decision (svar_is_fresh_in X x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk548" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk548"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Pattern</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (svar_is_fresh_in X p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> svar_is_fresh_in_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk549" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk549"><span class="kn">Lemma</span> <span class="nf">no_neg_occ_quan_impl_no_neg_occ</span> <span class="nv">x</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">ϕ</span>:
   no_negative_occurrence_db_b n1 (ϕ^{{<span class="nb">evar</span>: x ↦ n2}}) = true -&gt;
   no_negative_occurrence_db_b n1 ϕ = true
  <span class="kr">with</span> no_pos_occ_quan_impl_no_pos_occ x n1 n2 ϕ:
   no_positive_occurrence_db_b n1 (ϕ^{{<span class="nb">evar</span>: x ↦ n2}}) = true -&gt;
   no_positive_occurrence_db_b n1 ϕ = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
→ no_negative_occurrence_db_b n1 ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk54a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk54a"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
→ no_positive_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk54b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk54b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
→ no_negative_occurrence_db_b n1 ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk54c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk54c"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
→ no_positive_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk54d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk54d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
→ no_negative_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk54e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk54e"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk54f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk54f"><span class="nb">move</span>: n1 n2 H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk550" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk550"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> n1 n2 H; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_app ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_app ϕ1 ϕ2) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk551" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_imp ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk551"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_imp ϕ1 ϕ2) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk552" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_exists ϕ^{{<span class="nb">evar</span>:x↦S n2}}) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk552"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_exists ϕ) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk553" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_mu ϕ^{{<span class="nb">evar</span>:x↦n2}}) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk553"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_mu ϕ) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk554" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk554">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_app ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_app ϕ1 ϕ2) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk555" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk555"><span class="nb">unfold</span> no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk556" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk556"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk557" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk557"><span class="nb">fold</span> no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk558" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk558">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk559" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk559"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; no_negative_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk55a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk55a"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk55b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk55b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_imp ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_imp ϕ1 ϕ2) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk55c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk55c"><span class="nb">unfold</span> no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk55d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk55d"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk55e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk55e"><span class="nb">fold</span> no_negative_occurrence_db_b no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk55f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk55f">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ1 &amp;&amp;
no_negative_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk560" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk560"><span class="nb">erewrite</span> -&gt; no_pos_occ_quan_impl_no_pos_occ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; no_negative_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk561" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk561"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_negative_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk562" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk562">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_exists ϕ^{{<span class="nb">evar</span>:x↦S n2}}) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_exists ϕ) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk563" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk563"><span class="nb">unfold</span> no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ^{{<span class="nb">evar</span>:x↦
  S n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk564" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk564"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ^{{<span class="nb">evar</span>:x↦
  S n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk565" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk565"><span class="nb">fold</span> no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦S n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk566" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk566"><span class="nb">erewrite</span> -&gt; IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦S n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk567" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk567">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1
  (patt_mu ϕ^{{<span class="nb">evar</span>:x↦n2}}) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 (patt_mu ϕ) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk568" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk568"><span class="nb">unfold</span> no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) 
  (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) (S n1) ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk569" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk569"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_negative_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_negative_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) 
  (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) (S n1) ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk56a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk56a"><span class="nb">fold</span> no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b (S n1) ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk56b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk56b"><span class="nb">erewrite</span> -&gt; IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_negative_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_negative_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk56c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk56c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
→ no_positive_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk56d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk56d"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk56e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk56e"><span class="nb">move</span>: n1 n2 H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk56f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk56f"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> n1 n2 H; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_app ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_app ϕ1 ϕ2) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk570" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_imp ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk570"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_imp ϕ1 ϕ2) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk571" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_exists ϕ^{{<span class="nb">evar</span>:x↦S n2}}) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk571"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_exists ϕ) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk572" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_mu ϕ^{{<span class="nb">evar</span>:x↦n2}}) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk572"><hr></label><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_mu ϕ) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk573" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk573">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_app ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_app ϕ1 ϕ2) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk574" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk574"><span class="nb">unfold</span> no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk575" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk575"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk576" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk576"><span class="nb">fold</span> no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk577" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk577">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk578" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk578"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; no_positive_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk579" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk579"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk57a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk57a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_imp ϕ1^{{<span class="nb">evar</span>:x↦n2}} ϕ2^{{<span class="nb">evar</span>:x↦n2}}) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_imp ϕ1 ϕ2) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk57b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk57b"><span class="nb">unfold</span> no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk57c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk57c"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) 
       (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b 
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_negative_occurrence_db_b) n1 ϕ1 &amp;&amp;
(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk57d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk57d"><span class="nb">fold</span> no_positive_occurrence_db_b no_negative_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} &amp;&amp;
no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk57e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk57e">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b n1 ϕ1 &amp;&amp;
no_positive_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk57f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk57f"><span class="nb">erewrite</span> -&gt; no_neg_occ_quan_impl_no_neg_occ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; no_positive_occurrence_db_b n1 ϕ2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk580" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk580"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ1^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ1 = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1
    ϕ2^{{<span class="nb">evar</span>:x↦n2}} = true
  → no_positive_occurrence_db_b n1 ϕ2 = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b n1 ϕ1^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ2^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk581" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk581">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_exists ϕ^{{<span class="nb">evar</span>:x↦S n2}}) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_exists ϕ) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk582" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk582"><span class="nb">unfold</span> no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ^{{<span class="nb">evar</span>:x↦
  S n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk583" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk583"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ^{{<span class="nb">evar</span>:x↦
  S n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk584" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk584"><span class="nb">fold</span> no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦S n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk585" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk585"><span class="nb">erewrite</span> -&gt; IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦S n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk586" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk586">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b n1
  (patt_mu ϕ^{{<span class="nb">evar</span>:x↦n2}}) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b n1 (patt_mu ϕ) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk587" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk587"><span class="nb">unfold</span> no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) 
  (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) (S n1) ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk588" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk588"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  (<span class="kr">fix</span>
     no_negative_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span>
     no_positive_occurrence_db_b
     (dbi : db_index)
     (ϕ0 : Pattern)
     {<span class="kr">struct</span> ϕ0} :
       bool :=
     <span class="kr">match</span> ϕ0 <span class="kr">with</span>
     | patt_bound_svar
       n =&gt;
         <span class="kr">if</span>
          decide
          (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁
       ϕ₂ =&gt;
         no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_imp ϕ₁
       ϕ₂ =&gt;
         no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b
          dbi ϕ₂
     | patt_exists
       ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b)
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → (<span class="kr">fix</span>
       no_negative_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span>
       no_positive_occurrence_db_b
       (dbi : db_index)
       (ϕ0 : Pattern)
       {<span class="kr">struct</span> ϕ0} :
         bool :=
       <span class="kr">match</span> ϕ0 <span class="kr">with</span>
       | patt_bound_svar
         n =&gt;
          <span class="kr">if</span>
          decide
          (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁
         ϕ₂ =&gt;
          no_positive_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_imp ϕ₁
         ϕ₂ =&gt;
          no_negative_occurrence_db_b
          dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b
          dbi ϕ₂
       | patt_exists
         ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b
          (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b)
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  (<span class="kr">fix</span> no_negative_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_negative_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_negative_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_negative_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">with</span> no_positive_occurrence_db_b
     (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
       bool :=
     <span class="kr">match</span> ϕ <span class="kr">with</span>
     | patt_bound_svar n =&gt;
         <span class="kr">if</span> decide (n = dbi)
         <span class="kr">then</span> false
         <span class="kr">else</span> true
     | patt_app ϕ₁ ϕ₂ =&gt;
         no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_imp ϕ₁ ϕ₂ =&gt;
         no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
         no_positive_occurrence_db_b dbi ϕ₂
     | patt_exists ϕ&#39; =&gt;
         no_positive_occurrence_db_b dbi ϕ&#39;
     | patt_mu ϕ&#39; =&gt;
         no_positive_occurrence_db_b (S dbi) ϕ&#39;
     | _ =&gt; true
     <span class="kr">end</span>
   <span class="kr">for</span>
   no_positive_occurrence_db_b) n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} = true
  → (<span class="kr">fix</span> no_negative_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_negative_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_negative_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_negative_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">with</span> no_positive_occurrence_db_b
       (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
         bool :=
       <span class="kr">match</span> ϕ <span class="kr">with</span>
       | patt_bound_svar n =&gt;
          <span class="kr">if</span> decide (n = dbi)
          <span class="kr">then</span> false
          <span class="kr">else</span> true
       | patt_app ϕ₁ ϕ₂ =&gt;
          no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_imp ϕ₁ ϕ₂ =&gt;
          no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
          no_positive_occurrence_db_b dbi ϕ₂
       | patt_exists ϕ&#39; =&gt;
          no_positive_occurrence_db_b dbi ϕ&#39;
       | patt_mu ϕ&#39; =&gt;
          no_positive_occurrence_db_b (S dbi) ϕ&#39;
       | _ =&gt; true
       <span class="kr">end</span>
     <span class="kr">for</span>
     no_positive_occurrence_db_b) n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} :
     bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) 
  (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fix</span> no_negative_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_negative_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_negative_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_negative_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">with</span> no_positive_occurrence_db_b
   (dbi : db_index) (ϕ : Pattern) {<span class="kr">struct</span> ϕ} : bool :=
   <span class="kr">match</span> ϕ <span class="kr">with</span>
   | patt_bound_svar n =&gt;
       <span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> false <span class="kr">else</span> true
   | patt_app ϕ₁ ϕ₂ =&gt;
       no_positive_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_imp ϕ₁ ϕ₂ =&gt;
       no_negative_occurrence_db_b dbi ϕ₁ &amp;&amp;
       no_positive_occurrence_db_b dbi ϕ₂
   | patt_exists ϕ&#39; =&gt;
       no_positive_occurrence_db_b dbi ϕ&#39;
   | patt_mu ϕ&#39; =&gt;
       no_positive_occurrence_db_b (S dbi) ϕ&#39;
   | _ =&gt; true
   <span class="kr">end</span>
 <span class="kr">for</span>
 no_positive_occurrence_db_b) (S n1) ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk589" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk589"><span class="nb">fold</span> no_positive_occurrence_db_b <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_positive_occurrence_db_b (S n1) ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk58a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk58a"><span class="nb">erewrite</span> -&gt; IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>no_neg_occ_quan_impl_no_neg_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_negative_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_negative_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>no_pos_occ_quan_impl_no_pos_occ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">x</span> : <span class="nb">evar</span>) 
  (<span class="nv">n1</span> <span class="nv">n2</span> : db_index) 
  (<span class="nv">ϕ</span> : Pattern),
  no_positive_occurrence_db_b
    n1
    ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true
  → no_positive_occurrence_db_b
      n1 ϕ = true</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n1</span> <span class="nv">n2</span> : db_index,
  no_positive_occurrence_db_b n1 ϕ^{{<span class="nb">evar</span>:x↦n2}} =
  true → no_positive_occurrence_db_b n1 ϕ = true</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_positive_occurrence_db_b (S n1) ϕ^{{<span class="nb">evar</span>:x↦n2}} =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk58b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk58b"><span class="kn">Lemma</span> <span class="nf">wfp_evar_quan_impl_wfp</span> <span class="nv">x</span> <span class="nv">n</span> <span class="nv">ϕ</span>:
    well_formed_positive (ϕ^{{<span class="nb">evar</span>: x ↦ n}}) = true -&gt;
    well_formed_positive ϕ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true
→ well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk58c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk58c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true
→ well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk58d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk58d"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk58e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk58e"><span class="nb">move</span>: n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk58f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk58f"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> n&#39; H; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} &amp;&amp;
well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk590" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} &amp;&amp;
well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk590"><hr></label><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk591" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}} = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk591"><hr></label><div class="goal-conclusion">well_formed_positive ϕ</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk592" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} &amp;&amp;
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk592"><hr></label><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk593" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk593">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} &amp;&amp;
well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk594" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk594">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk595" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk595"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk596" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk596"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk597" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk597">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} &amp;&amp;
well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk598" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk598">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ1 &amp;&amp; well_formed_positive ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk599" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk599"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_positive ϕ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk59a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk59a"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ1</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n}} = true
  → well_formed_positive ϕ2</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk59b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk59b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk59c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk59c"><span class="nb">erewrite</span> IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk59d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk59d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} &amp;&amp;
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk59e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk59e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} &amp;&amp;
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk59f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk59f">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp;
well_formed_positive ϕ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5a0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5a0"><span class="nb">erewrite</span> -&gt; IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">no_negative_occurrence_db_b <span class="mi">0</span> ϕ &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5a1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5a1"><span class="nb">erewrite</span> -&gt; no_neg_occ_quan_impl_no_neg_occ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n}} = true → well_formed_positive ϕ</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>no_negative_occurrence_db_b <span class="mi">0</span> ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5a2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5a2"><span class="kn">Lemma</span> <span class="nf">wfcex_evar_quan_impl_wfcex</span> <span class="nv">x</span> <span class="nv">n</span> <span class="nv">dbi</span> <span class="nv">ϕ</span>:
    well_formed_closed_ex_aux (ϕ^{{<span class="nb">evar</span>: x ↦ n}}) dbi = true -&gt;
    well_formed_closed_ex_aux ϕ dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_ex_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5a3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5a3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_ex_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5a4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5a4"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5a5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5a5"><span class="nb">move</span>: n dbi H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
  → well_formed_closed_ex_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5a6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5a6"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> n&#39; dbi H; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5a7"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5a8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦
  S n&#39;}} (S dbi) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5a8"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ (S dbi)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5a9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5a9"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ dbi</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5aa" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5aa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ab" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ab">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ac" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ac"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_ex_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ad" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ad"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ae" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5af" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5af">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b0"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_ex_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b1"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_ex_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}}
  (S dbi) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ (S dbi)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b3"><span class="nb">erewrite</span> IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_ex_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}}
  (S dbi) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_ex_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_ex_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b6"><span class="nb">erewrite</span> -&gt; IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_ex_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b7"><span class="kn">Lemma</span> <span class="nf">wfcmu_evar_quan_impl_wfcmu</span> <span class="nv">x</span> <span class="nv">n</span> <span class="nv">dbi</span> <span class="nv">ϕ</span>:
    well_formed_closed_mu_aux (ϕ^{{<span class="nb">evar</span>: x ↦ n}}) dbi = true -&gt;
    well_formed_closed_mu_aux ϕ dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_mu_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_mu_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5b9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5b9"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ba" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ba"><span class="nb">move</span>: n dbi H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
  → well_formed_closed_mu_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5bb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5bb"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> n&#39; dbi H; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5bc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5bc"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5bd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}} dbi =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5bd"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ dbi</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} (S dbi) =
true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5be"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ (S dbi)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5bf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5bf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c0">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c1"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_mu_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c2"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c4">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c5"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_mu_aux ϕ2 dbi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c6"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ1 dbi</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n}} dbi =
  true → well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2^{{<span class="nb">evar</span>:x↦n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_mu_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ dbi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c8"><span class="nb">erewrite</span> IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_mu_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦S n&#39;}} dbi =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5c9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5c9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_mu_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} (S dbi) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ (S dbi)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ca" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ca"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_mu_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} (S dbi) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ (S dbi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5cb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5cb"><span class="nb">erewrite</span> -&gt; IHϕ <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n}} dbi = true
→ well_formed_closed_mu_aux ϕ dbi</span></span></span><br><span><var>n', dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦n&#39;}} (S dbi) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5cc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5cc"><span class="kn">Lemma</span> <span class="nf">wfc_ex_lower</span> <span class="nv">ϕ</span> <span class="nv">n</span>:
    bevar_occur ϕ n = false -&gt;
    well_formed_closed_ex_aux ϕ (S n) = true -&gt;
    well_formed_closed_ex_aux ϕ n = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ n = false
→ well_formed_closed_ex_aux ϕ (S n) = true
  → well_formed_closed_ex_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5cd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5cd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ n = false
→ well_formed_closed_ex_aux ϕ (S n) = true
  → well_formed_closed_ex_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ce" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ce"><span class="nb">intros</span> H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ n = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5cf" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5cf"><span class="nb">move</span>: n H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ n = false
  → well_formed_closed_ex_aux ϕ (S n) = true
    → well_formed_closed_ex_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d0"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> n&#39; H1 H2; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n &lt; S n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n &lt; n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5d1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; || bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5d1"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5d2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; || bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5d2"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n &lt; S n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n &lt; n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d4"><span class="kp">repeat</span> case_match; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ n&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (n = n&#39;) = <span class="nb">right</span> n0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; S n&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (n &lt; S n&#39;) = <span class="nb">left</span> l</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ n &lt; n&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>decide (n &lt; n&#39;) = <span class="nb">right</span> n1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; || bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d6"><span class="nb">apply</span> orb_false_elim <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false
∧ bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d7">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d8"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5d9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5d9"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5da" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; || bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5db" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5db"><span class="nb">apply</span> orb_false_elim <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false
∧ bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5dc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5dc">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5dd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5dd"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_ex_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5de" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5de"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ1 n = false
  → well_formed_closed_ex_aux ϕ1 (S n) = true
    → well_formed_closed_ex_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bevar_occur ϕ2 n = false
  → well_formed_closed_ex_aux ϕ2 (S n) = true
    → well_formed_closed_ex_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5df" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5df"><span class="kn">Lemma</span> <span class="nf">wfc_mu_lower</span> <span class="nv">ϕ</span> <span class="nv">n</span>:
    bsvar_occur ϕ n = false -&gt;
    well_formed_closed_mu_aux ϕ (S n) = true -&gt;
    well_formed_closed_mu_aux ϕ n = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ n = false
→ well_formed_closed_mu_aux ϕ (S n) = true
  → well_formed_closed_mu_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ n = false
→ well_formed_closed_mu_aux ϕ (S n) = true
  → well_formed_closed_mu_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e1"><span class="nb">intros</span> H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ n = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ (S n) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e2"><span class="nb">move</span>: n H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ n = false
  → well_formed_closed_mu_aux ϕ (S n) = true
    → well_formed_closed_mu_aux ϕ n = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e3"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> n&#39; H1 H2; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n &lt; S n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n &lt; n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; || bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5e4"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5e5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; || bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5e5"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n = n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (n &lt; S n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n &lt; n&#39;) <span class="kr">then</span> true <span class="kr">else</span> false) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e7"><span class="kp">repeat</span> case_match; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n ≠ n&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>decide (n = n&#39;) = <span class="nb">right</span> n0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>false = false</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; S n&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decide (n &lt; S n&#39;) = <span class="nb">left</span> l</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>true = true</span></span></span><br><span><var>n1</var><span class="hyp-type"><b>: </b><span>¬ n &lt; n&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>decide (n &lt; n&#39;) = <span class="nb">right</span> n1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; || bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5e9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5e9"><span class="nb">apply</span> orb_false_elim <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false
∧ bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ea" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ea">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5eb" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5eb"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ec" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ec"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ed" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ed">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; || bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ee" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ee"><span class="nb">apply</span> orb_false_elim <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false
∧ bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) &amp;&amp;
well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ef" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ef">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ1 n&#39; &amp;&amp;
well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f0" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f0"><span class="nb">erewrite</span> -&gt; IHϕ1 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; well_formed_closed_mu_aux ϕ2 n&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f1" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f1"><span class="nb">erewrite</span> -&gt; IHϕ2 <span class="bp">by</span> <span class="bp">eassumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ1 n = false
  → well_formed_closed_mu_aux ϕ1 (S n) = true
    → well_formed_closed_mu_aux ϕ1 n = true</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : db_index,
  bsvar_occur ϕ2 n = false
  → well_formed_closed_mu_aux ϕ2 (S n) = true
    → well_formed_closed_mu_aux ϕ2 n = true</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ1 n&#39; = false</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>bsvar_occur ϕ2 n&#39; = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 (S n&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 (S n&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true &amp;&amp; true = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f2" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f2"><span class="kn">Lemma</span> <span class="nf">wf_ex_quan_impl_wf</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">ϕ</span> : Pattern):
    bevar_occur ϕ <span class="mi">0</span> = false -&gt;
    well_formed (exists_quantify x ϕ) = true -&gt;
    well_formed ϕ = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ <span class="mi">0</span> = false
→ well_formed (exists_quantify x ϕ) = true
  → well_formed ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f3" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ <span class="mi">0</span> = false
→ well_formed (exists_quantify x ϕ) = true
  → well_formed ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f4" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f4"><span class="nb">intros</span> H0 H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (exists_quantify x ϕ) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f5" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f5"><span class="nb">unfold</span> exists_quantify <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed (patt_exists ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}}) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f6" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f6"><span class="nb">unfold</span> well_formed, well_formed_closed <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>[&amp;&amp; well_formed_positive
      (patt_exists ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}}),
    well_formed_closed_mu_aux
      (patt_exists ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}}) <span class="mi">0</span>
  &amp; well_formed_closed_ex_aux
      (patt_exists ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}}) <span class="mi">0</span>] = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive ϕ,
    well_formed_closed_mu_aux ϕ <span class="mi">0</span>
  &amp; well_formed_closed_ex_aux ϕ <span class="mi">0</span>] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f7" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f7">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive (patt_exists ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}}) =
true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux
  (patt_exists ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}}) <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux
  (patt_exists ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}}) <span class="mi">0</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive ϕ,
    well_formed_closed_mu_aux ϕ <span class="mi">0</span>
  &amp; well_formed_closed_ex_aux ϕ <span class="mi">0</span>] = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f8" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f8"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; well_formed_positive ϕ,
    well_formed_closed_mu_aux ϕ <span class="mi">0</span>
  &amp; well_formed_closed_ex_aux ϕ <span class="mi">0</span>] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5f9" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5f9">split_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5fa"><hr></label><div class="goal-conclusion">well_formed_closed_mu_aux ϕ <span class="mi">0</span> = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk5fb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk5fb"><hr></label><div class="goal-conclusion">well_formed_closed_ex_aux ϕ <span class="mi">0</span> = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5fc" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5fc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5fd" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5fd"><span class="nb">eapply</span> wfp_evar_quan_impl_wfp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_positive ϕ^{{<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?n</span>}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5fe" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5fe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk5ff" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk5ff"><span class="nb">eapply</span> wfcmu_evar_quan_impl_wfcmu.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:<span class="nl">?x</span>↦<span class="nl">?n</span>}} <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk600" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk600">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">1</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk601" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk601"><span class="nb">apply</span> wfcex_evar_quan_impl_wfcex <span class="kr">in</span> H3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>bevar_occur ϕ <span class="mi">0</span> = false</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>well_formed_positive ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ^{{<span class="nb">evar</span>:x↦<span class="mi">0</span>}} <span class="mi">0</span> = true</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ <span class="mi">0</span> = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> wfc_ex_lower; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk602" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk602"><span class="kn">Lemma</span> <span class="nf">bevar_occur_evar_open_2</span> <span class="nv">dbi</span> <span class="nv">x</span> <span class="nv">ϕ</span>:
    well_formed_closed_ex_aux ϕ dbi -&gt;
    bevar_occur (ϕ^{<span class="nb">evar</span>: dbi ↦ x}) dbi = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ dbi
→ bevar_occur ϕ^{<span class="nb">evar</span>:dbi↦x} dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk603" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk603"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux ϕ dbi
→ bevar_occur ϕ^{<span class="nb">evar</span>:dbi↦x} dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk604" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk604"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ dbi
  → bevar_occur ϕ^{<span class="nb">evar</span>:dbi↦x} dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk605" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk605"><span class="nb">unfold</span> evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ dbi
  → bevar_occur ϕ^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
    false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk606" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk606"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hwf; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_bound_evar n) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; patt_free_evar x
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> dbi = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk607" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_app ϕ1 ϕ2) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk607"><hr></label><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk608" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_imp ϕ1 ϕ2) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk608"><hr></label><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk609" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ dbi
  → bevar_occur ϕ^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_exists ϕ) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk609"><hr></label><div class="goal-conclusion">bevar_occur ϕ^[<span class="nb">evar</span>:S dbi↦patt_free_evar x] (S dbi) =
false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk60a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ dbi
  → bevar_occur ϕ^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_mu ϕ) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk60a"><hr></label><div class="goal-conclusion">bevar_occur ϕ^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi = false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk60b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk60b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_bound_evar n) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_evar n
  | Nat_equal _ _ _ =&gt; patt_free_evar x
  | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
  <span class="kr">end</span> dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk60c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk60c">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_bound_evar n) dbi</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_less n dbi l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk60d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_bound_evar n) dbi</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_greater n dbi g</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk60d"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> decide (Nat.pred n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk60e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk60e">case_match; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_bound_evar n) dbi</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_greater n dbi g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (Nat.pred n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk60f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk60f"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n &lt; dbi) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_greater n dbi g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (Nat.pred n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; [<span class="bp">lia</span> | <span class="bp">congruence</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk610" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk610">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_app ϕ1 ϕ2) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk611" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk611"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk612" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk612">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk613" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk613"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk614" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk614">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_imp ϕ1 ϕ2) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk615" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk615"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi &amp;&amp;
well_formed_closed_ex_aux ϕ2 dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk616" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk616">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk617" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk617"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ1 dbi
  → bevar_occur ϕ1^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_ex_aux ϕ2 dbi
  → bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦
      patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false
|| bevar_occur ϕ2^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk618" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk618">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_ex_aux ϕ dbi
→ bevar_occur ϕ^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_exists ϕ) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ^[<span class="nb">evar</span>:S dbi↦patt_free_evar x] (S dbi) =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk619" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk619">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_ex_aux ϕ dbi
→ bevar_occur ϕ^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_ex_aux (patt_mu ϕ) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bevar_occur ϕ^[<span class="nb">evar</span>:dbi↦patt_free_evar x] dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk61a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk61a"><span class="kn">Lemma</span> <span class="nf">bsvar_occur_svar_open_2</span> <span class="nv">dbi</span> <span class="nv">X</span> <span class="nv">ϕ</span>:
    well_formed_closed_mu_aux ϕ dbi -&gt;
    bsvar_occur (ϕ^{svar: dbi ↦ X}) dbi = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ dbi
→ bsvar_occur ϕ^{svar:dbi↦X} dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk61b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk61b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_mu_aux ϕ dbi
→ bsvar_occur ϕ^{svar:dbi↦X} dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk61c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk61c"><span class="nb">move</span>: dbi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ dbi
  → bsvar_occur ϕ^{svar:dbi↦X} dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk61d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk61d"><span class="nb">unfold</span> svar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ dbi
  → bsvar_occur ϕ^[svar:dbi↦patt_free_svar X] dbi =
    false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk61e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk61e"><span class="nb">induction</span> ϕ; <span class="nb">intros</span> dbi Hwf; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; patt_free_svar X
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span> dbi = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk61f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app ϕ1 ϕ2) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk61f"><hr></label><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk620" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp ϕ1 ϕ2) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk620"><hr></label><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk621" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ dbi
  → bsvar_occur ϕ^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_exists ϕ) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk621"><hr></label><div class="goal-conclusion">bsvar_occur ϕ^[svar:dbi↦patt_free_svar X] dbi = false</div></blockquote><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk622" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ dbi
  → bsvar_occur ϕ^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_mu ϕ) dbi</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk622"><hr></label><div class="goal-conclusion">bsvar_occur ϕ^[svar:S dbi↦patt_free_svar X] (S dbi) =
false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk623" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk623">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur
  <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
  | Nat_less _ _ _ =&gt; patt_bound_svar n
  | Nat_equal _ _ _ =&gt; patt_free_svar X
  | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
  <span class="kr">end</span> dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk624" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk624">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) dbi</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_less n dbi l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) = false</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Syntax-v-chk625" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) dbi</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_greater n dbi g</span></span></span><br></div><label class="goal-separator" for="Syntax-v-chk625"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> decide (Nat.pred n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk626" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk626">case_match; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_bound_svar n) dbi</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_greater n dbi g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (Nat.pred n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk627" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk627"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>n, dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span><span class="kr">if</span> decide (n &lt; dbi) <span class="kr">then</span> true <span class="kr">else</span> false</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>n &gt; dbi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compare_nat n dbi = Nat_greater n dbi g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (Nat.pred n = dbi) <span class="kr">then</span> true <span class="kr">else</span> false) =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; [<span class="bp">lia</span> | <span class="bp">congruence</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk628" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk628">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_app ϕ1 ϕ2) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk629" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk629"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk62a" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk62a">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk62b" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk62b"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk62c" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk62c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_imp ϕ1 ϕ2) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk62d" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk62d"><span class="nb">simpl</span> <span class="kr">in</span> Hwf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi &amp;&amp;
well_formed_closed_mu_aux ϕ2 dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk62e" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk62e">destruct_and!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ1^[svar:dbi↦patt_free_svar X] dbi
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk62f" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk62f"><span class="nb">rewrite</span> IHϕ1; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ1, ϕ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ1 dbi
  → bsvar_occur ϕ1^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>IHϕ2</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
  well_formed_closed_mu_aux ϕ2 dbi
  → bsvar_occur ϕ2^[svar:dbi↦
      patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ1 dbi = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux ϕ2 dbi = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">false
|| bsvar_occur ϕ2^[svar:dbi↦patt_free_svar X] dbi =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ2; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk630" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk630">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ϕ dbi
→ bsvar_occur ϕ^[svar:dbi↦patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_exists ϕ) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ^[svar:dbi↦patt_free_svar X] dbi = false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Syntax-v-chk631" style="display: none" type="checkbox"><label class="alectryon-input" for="Syntax-v-chk631">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Σ</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHϕ</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">dbi</span> : db_index,
well_formed_closed_mu_aux ϕ dbi
→ bsvar_occur ϕ^[svar:dbi↦patt_free_svar X] dbi = false</span></span></span><br><span><var>dbi</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux (patt_mu ϕ) dbi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bsvar_occur ϕ^[svar:S dbi↦patt_free_svar X] (S dbi) =
false</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHϕ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_signature</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* TODO remove these hints *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> well_formed_positive_svar_quantify : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> no_positive_occurrence_svar_quantify : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> no_negative_occurrence_svar_quantify : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfc_impl_no_neg_occ : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfp_free_svar_subst : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfp_neg_free_svar_subst : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> svar_quantify_closed_ex : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> svar_quantify_closed_mu : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> evar_quantify_positive : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> evar_quantify_closed_mu : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> evar_quantify_closed_ex : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfp_evar_open : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfc_mu_aux_body_ex_imp1 : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfc_ex_aux_body_ex_imp1 : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> bevar_subst_positive_2 : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> wfc_mu_aux_bevar_subst : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> wfc_ex_aux_bevar_subst : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> wfp_svar_open : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
 <span class="kn">Hint Resolve</span> wfc_mu_free_evar_subst : core.</span></span></pre></article></body></html>