<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>SyntacticConstruct.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect ssrfun ssrbool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk0"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> base.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> MatchingLogic.Utils
<span class="kn">Require Import</span>
    extralibrary
    stdpp_ext
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk1"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> fin_sets.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">New coercion path [Is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span> <span class="kr">is</span> ambiguous <span class="kr">with</span> existing 
[is_true] : bool &gt;-&gt; <span class="kt">Sortclass</span>.
[ambiguous-paths,typechecker]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> MatchingLogic
<span class="kn">Require Import</span>
    Pattern
    Substitution
    IndexManipulation
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> MatchingLogic.Substitution.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">with_signature</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Œ£</span> : Signature}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**</span>
<span class="sd">  * General substitutions</span>


<span class="sd">  First, we extract the information that identify the different substiutions:</span>
<span class="sd">  - How to &quot;step&quot; or &quot;increase&quot; (mostly de Bruijn indices) some properties</span>
<span class="sd">    in the recursive calls for binders</span>
<span class="sd">  - How the substitutions work for variables (both set and element, bound and free)</span>
<span class="sd">*)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">SpecificSubst</span> {<span class="nv">A</span> : <span class="kt">Type</span>} : <span class="kt">Type</span> := {
      increase_ex : A -&gt; A;
      increase_mu : A -&gt; A;
      on_fevar : A -&gt; <span class="nb">evar</span> -&gt; Pattern;
      on_fsvar : A -&gt; svar -&gt; Pattern;
      on_bevar : A -&gt; db_index -&gt; Pattern;
      on_bsvar : A -&gt; db_index -&gt; Pattern;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(**</span>
<span class="sd">    We define the general structure of substitutions, and use the specific</span>
<span class="sd">    information for the binders and the variables defined in `SpeificSubst`.</span>
<span class="sd">   *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">apply_subst</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">s</span> : SpecificSubst) (<span class="nv">st</span> : A) (<span class="nv">phi</span> : Pattern) :=
    <span class="kr">match</span> phi <span class="kr">with</span>
    | patt_free_evar x =&gt; on_fevar s st x
    | patt_free_svar X =&gt; on_fsvar s st X
    | patt_bound_evar n =&gt; on_bevar s st n
    | patt_bound_svar N =&gt; on_bsvar s st N
    | patt_sym sm =&gt; patt_sym sm
    | patt_app phi1 phi2 =&gt; patt_app (apply_subst s st phi1) (apply_subst s st phi2)
    | patt_bott =&gt; patt_bott
    | patt_imp phi1 phi2 =&gt; patt_imp (apply_subst s st phi1) (apply_subst s st phi2)
    | patt_exists phi&#39; =&gt; patt_exists (apply_subst s (increase_ex s st) phi&#39;)
    | patt_mu phi&#39; =&gt; patt_mu (apply_subst s (increase_mu s st) phi&#39;)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** For substitutions that can be described with the previous definition,</span>
<span class="sd">      we can instantiate the following type class: *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">PatternMorphism</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) := {
      pm_spec_data : SpecificSubst ;
      pm_ezero_increase : <span class="kr">forall</span> <span class="nv">a</span>,
        on_bevar pm_spec_data (increase_ex pm_spec_data a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span> ;
      pm_szero_increase : <span class="kr">forall</span> <span class="nv">a</span>,
        on_bsvar pm_spec_data (increase_mu pm_spec_data a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span> ;
      pm_correctness : <span class="kr">forall</span> <span class="nv">a</span> (<span class="nv">phi</span> : Pattern), f a phi = apply_subst pm_spec_data a phi
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Variable quantifications are such morphisms: *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Evar_quantify_morphism</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) :
     PatternMorphism (evar_quantify x&#39;) := {
    pm_spec_data := {|
      increase_ex := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">level</span> <span class="nv">x</span> =&gt; <span class="kr">if</span> decide (x&#39; = x)
                                 <span class="kr">then</span> patt_bound_evar level
                                 <span class="kr">else</span> patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk2"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_evar level
             <span class="kr">else</span> patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
‚Üí db_index ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_evar level
             <span class="kr">else</span> patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
‚Üí db_index ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{{<span class="nb">evar</span>:x&#39;‚Ü¶a}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7"><span class="nb">intros</span> x&#39; db œÜ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
        <span class="kr">if</span> is_left (decide (x&#39; = x))
        <span class="kr">then</span> patt_bound_evar level
        <span class="kr">else</span> patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9"><span class="nb">induction</span> œÜ; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chka"><hr></label><div class="goal-conclusion">patt_app (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkb"><hr></label><div class="goal-conclusion">patt_imp (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkc"><hr></label><div class="goal-conclusion">patt_exists (œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶S db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) œÜ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkd"><hr></label><div class="goal-conclusion">patt_mu (œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chke">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_evar db
 <span class="kr">else</span> patt_free_evar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkf">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk10">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
  (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_evar level
          <span class="kr">else</span> patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (œÜ1^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml (œÜ2^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk11">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
(œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar :=
<span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_evar level
<span class="kr">else</span> patt_free_evar x;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶S db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk12">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : <span class="nb">evar</span>) (<span class="nv">db</span> : db_index),
(œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar :=
<span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_evar level
<span class="kr">else</span> patt_free_evar x;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (œÜ^{{<span class="nb">evar</span>:x&#39;‚Ü¶db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_evar level
           <span class="kr">else</span> patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Svar_quantify_morphism</span> (<span class="nv">x&#39;</span> : svar) :
     PatternMorphism (svar_quantify x&#39;) := {
    pm_spec_data := {|
      increase_ex := id;
      increase_mu := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_evar X;
      on_fsvar := <span class="kr">fun</span> <span class="nv">level</span> <span class="nv">x</span> =&gt; <span class="kr">if</span> decide (x&#39; = x)
                                 <span class="kr">then</span> patt_bound_svar level
                                 <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk13"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
             patt_free_evar X;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_svar level
             <span class="kr">else</span> patt_free_svar x;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk14"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
‚Üí db_index ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk15"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
             patt_free_evar X;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
             <span class="kr">if</span> is_left (decide (x&#39; = x))
             <span class="kr">then</span> patt_bound_svar level
             <span class="kr">else</span> patt_free_svar x;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk16"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
‚Üí db_index ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk17"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{{svar:x&#39;‚Ü¶a}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk18"><span class="nb">intros</span> x&#39; db œÜ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
        <span class="kr">if</span> is_left (decide (x&#39; = x))
        <span class="kr">then</span> patt_bound_svar level
        <span class="kr">else</span> patt_free_svar x;
    on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk19"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk1a"><span class="nb">induction</span> œÜ; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1b"><hr></label><div class="goal-conclusion">patt_app (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1c"><hr></label><div class="goal-conclusion">patt_imp (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1d"><hr></label><div class="goal-conclusion">patt_exists (œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk1e"><hr></label><div class="goal-conclusion">patt_mu (œÜ^{{svar:x&#39;‚Ü¶S db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) œÜ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk1f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (x&#39; = x)
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (x&#39; = x))
 <span class="kr">then</span> patt_bound_svar db
 <span class="kr">else</span> patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk20">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk21">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
  (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>),
          patt_free_evar X;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
          <span class="kr">if</span> is_left (decide (x&#39; = x))
          <span class="kr">then</span> patt_bound_svar level
          <span class="kr">else</span> patt_free_svar x;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (œÜ1^{{svar:x&#39;‚Ü¶db}})%ml (œÜ2^{{svar:x&#39;‚Ü¶db}})%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk22">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
(œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
on_fsvar :=
<span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_svar level
<span class="kr">else</span> patt_free_svar x;
on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk23">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : svar) (<span class="nv">db</span> : db_index),
(œÜ^{{svar:x&#39;‚Ü¶db}})%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
on_fsvar :=
<span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
<span class="kr">if</span> is_left (decide (x&#39; = x))
<span class="kr">then</span> patt_bound_svar level
<span class="kr">else</span> patt_free_svar x;
on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (œÜ^{{svar:x&#39;‚Ü¶S db}})%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : <span class="nb">evar</span>), patt_free_evar X;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">level</span> : db_index) (<span class="nv">x</span> : svar),
           <span class="kr">if</span> is_left (decide (x&#39; = x))
           <span class="kr">then</span> patt_bound_svar level
           <span class="kr">else</span> patt_free_svar x;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Bevar_subst_morphism</span> (<span class="nv">œà</span> : Pattern) :
     PatternMorphism (bevar_subst œà) := {
    pm_spec_data := {|
      increase_ex := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">n</span> =&gt;
        <span class="kr">match</span> compare_nat n x <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_evar n
        | Nat_equal _ _ _ =&gt; œà
        | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
        <span class="kr">end</span>;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk24"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              œà <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n
                                            x
                                            wildcard&#39; =
                                          filtered_var),
                 œà <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater
                                            n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk25"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
‚Üí db_index ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk26"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              œà <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n
                                            x
                                            wildcard&#39; =
                                          filtered_var),
                 œà <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater
                                            n x
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk27"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
‚Üí db_index ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk28"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[<span class="nb">evar</span>:a‚Ü¶œà])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              œà <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk29"><span class="nb">intros</span> x&#39; db œÜ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
        <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
          <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_evar n <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
          <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                       wildcard&#39; =
                                     filtered_var), x&#39;
          <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
          <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_evar (Nat.pred n) <span class="kr">in</span>
        <span class="kr">match</span>
          filtered_var <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span> (anonymous&#39; = filtered_var ‚Üí Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            program_branch_0 wildcard&#39;
        | Nat_equal _ _ wildcard&#39; =&gt;
            program_branch_1 wildcard&#39;
        | Nat_greater _ _ wildcard&#39; =&gt;
            program_branch_2 wildcard&#39;
        <span class="kr">end</span> (erefl filtered_var);
    on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk2a"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x
                                         wildcard&#39; =
                                       filtered_var),
              x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk2b"><span class="nb">induction</span> œÜ; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_evar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_evar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_evar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2c"><hr></label><div class="goal-conclusion">patt_app (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2d"><hr></label><div class="goal-conclusion">patt_imp (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2e"><hr></label><div class="goal-conclusion">patt_exists (œÜ^[<span class="nb">evar</span>:S db‚Ü¶x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) œÜ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk2f"><hr></label><div class="goal-conclusion">patt_mu (œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk30">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_evar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_evar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_evar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk31">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk32">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat n x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) 
              (<span class="nv">_</span> : Nat_less n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) 
              (<span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) 
              (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                   filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (œÜ1^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml (œÜ2^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk33">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar :=
<span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x wildcard&#39; = filtered_var),
patt_bound_evar n <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
          filtered_var),
patt_bound_evar (Nat.pred n) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var);
on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (œÜ^[<span class="nb">evar</span>:S db‚Ü¶x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} (S db) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk34">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
apply_subst
{|
increase_ex := [eta S];
increase_mu := id;
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar :=
<span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n x <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; x) (<span class="nv">_</span> : Nat_less n x wildcard&#39; = filtered_var),
patt_bound_evar n <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = x) (<span class="nv">_</span> : Nat_equal n x wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; x) (<span class="nv">_</span> : Nat_greater n x wildcard&#39; =
          filtered_var),
patt_bound_evar (Nat.pred n) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var);
on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (œÜ^[<span class="nb">evar</span>:db‚Ü¶x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := [eta S];
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">n</span> : db_index,
           <span class="kr">match</span>
             compare_nat n x <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat n x ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar n
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n x wildcard&#39; =
                     compare_nat n x, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n x wildcard&#39; =
                     compare_nat n x,
                 patt_bound_evar (Nat.pred n)
           <span class="kr">end</span> (erefl (compare_nat n x));
       on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Bsvar_subst_morphism</span> (<span class="nv">œà</span> : Pattern) :
     PatternMorphism (bsvar_subst œà) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">X</span> <span class="nv">N</span> =&gt;
        <span class="kr">match</span> compare_nat N X <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_svar N
        | Nat_equal _ _ _ =&gt; œà
        | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred N)
        <span class="kr">end</span>;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk35"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              œà <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N
                                            X
                                            wildcard&#39; =
                                          filtered_var),
                 œà <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater
                                            N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk36"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
‚Üí db_index ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk37"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              œà <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N
                                            X
                                            wildcard&#39; =
                                          filtered_var),
                 œà <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater
                                            N X
                                            wildcard&#39; =
                                          filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk38"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern
‚Üí db_index ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk39"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[svar:a‚Ü¶œà])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              œà <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3a"><span class="nb">intros</span> x&#39; db œÜ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œÜ^[svar:db‚Ü¶x&#39;])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
        <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
          <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_svar N <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
          <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                       wildcard&#39; =
                                     filtered_var), x&#39;
          <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
          <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                       wildcard&#39; =
                                     filtered_var),
            patt_bound_svar (Nat.pred N) <span class="kr">in</span>
        <span class="kr">match</span>
          filtered_var <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span> (anonymous&#39; = filtered_var ‚Üí Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            program_branch_0 wildcard&#39;
        | Nat_equal _ _ wildcard&#39; =&gt;
            program_branch_1 wildcard&#39;
        | Nat_greater _ _ wildcard&#39; =&gt;
            program_branch_2 wildcard&#39;
        <span class="kr">end</span> (erefl filtered_var)
  |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3b"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X
                                         wildcard&#39; =
                                       filtered_var),
              x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X
                                         wildcard&#39; =
                                       filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk3c"><span class="nb">induction</span> œÜ; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_svar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_svar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk3d"><hr></label><div class="goal-conclusion">patt_app (œÜ1^[svar:db‚Ü¶x&#39;])%ml (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk3e"><hr></label><div class="goal-conclusion">patt_imp (œÜ1^[svar:db‚Ü¶x&#39;])%ml (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk3f"><hr></label><div class="goal-conclusion">patt_exists (œÜ^[svar:db‚Ü¶x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk40"><hr></label><div class="goal-conclusion">patt_mu (œÜ^[svar:S db‚Ü¶x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} (S db) œÜ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk41">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> compare_nat n db <span class="kr">with</span>
| Nat_less _ _ _ =&gt; patt_bound_svar n
| Nat_equal _ _ _ =&gt; x&#39;
| Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred n)
<span class="kr">end</span> =
<span class="kr">match</span>
  compare_nat n db <span class="kr">as</span> anonymous&#39;
  <span class="kr">return</span> (anonymous&#39; = compare_nat n db ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n db wildcard&#39; = compare_nat n db,
      patt_bound_svar n
| Nat_equal _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n db wildcard&#39; = compare_nat n db,
      x&#39;
| Nat_greater _ _ wildcard&#39; =&gt;
    <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n db wildcard&#39; =
          compare_nat n db,
      patt_bound_svar (Nat.pred n)
<span class="kr">end</span> (erefl (compare_nat n db))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk42">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (œÜ1^[svar:db‚Ü¶x&#39;])%ml (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk43">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ1^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
  (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := 
            compare_nat N X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) 
              (<span class="nv">_</span> : Nat_less N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) 
              (<span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                   filtered_var), x&#39; <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) 
              (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                   filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (œÜ1^[svar:db‚Ü¶x&#39;])%ml (œÜ2^[svar:db‚Ü¶x&#39;])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk44">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(œÜ^[svar:db‚Ü¶x&#39;])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar :=
<span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X wildcard&#39; = filtered_var),
patt_bound_svar N <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
          filtered_var),
patt_bound_svar (Nat.pred N) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var)
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (œÜ^[svar:db‚Ü¶x&#39;])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk45">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : db_index),
(œÜ^[svar:db‚Ü¶x&#39;])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := [eta S];
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
on_bsvar :=
<span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
<span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N X <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_0</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; X) (<span class="nv">_</span> : Nat_less N X wildcard&#39; = filtered_var),
patt_bound_svar N <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_1</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = X) (<span class="nv">_</span> : Nat_equal N X wildcard&#39; = filtered_var),
x&#39; <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">program_branch_2</span> :=
<span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; X) (<span class="nv">_</span> : Nat_greater N X wildcard&#39; =
          filtered_var),
patt_bound_svar (Nat.pred N) <span class="kr">in</span>
<span class="kr">match</span>
filtered_var <span class="kr">as</span> anonymous&#39;
<span class="kr">return</span> (anonymous&#39; = filtered_var ‚Üí Pattern)
<span class="kr">with</span>
| Nat_less _ _ wildcard&#39; =&gt; program_branch_0 wildcard&#39;
| Nat_equal _ _ wildcard&#39; =&gt; program_branch_1 wildcard&#39;
| Nat_greater _ _ wildcard&#39; =&gt; program_branch_2 wildcard&#39;
<span class="kr">end</span> (erefl filtered_var)
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (œÜ^[svar:S db‚Ü¶x&#39;])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := [eta S];
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">N</span> : db_index,
           <span class="kr">match</span>
             compare_nat N X <span class="kr">as</span> anonymous&#39;
             <span class="kr">return</span>
               (anonymous&#39; = compare_nat N X ‚Üí Pattern)
           <span class="kr">with</span>
           | Nat_less _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar N
           | Nat_equal _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N X wildcard&#39; =
                     compare_nat N X, x&#39;
           | Nat_greater _ _ wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N X wildcard&#39; =
                     compare_nat N X,
                 patt_bound_svar (Nat.pred N)
           <span class="kr">end</span> (erefl (compare_nat N X))
     |} (S db) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Evar_open_morphism</span> (<span class="nv">x</span> : <span class="nb">evar</span>) :
     PatternMorphism (evar_open x) := {
    pm_spec_data := {|
      increase_ex := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">dbi</span> <span class="nv">n</span> =&gt;
        <span class="kr">match</span> compare_nat n dbi <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_evar n
        | Nat_equal _ _ _ =&gt; patt_free_evar x
        | Nat_greater _ _ _ =&gt; patt_bound_evar (Nat.pred n)
        <span class="kr">end</span>;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk46"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_evar x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
             patt_free_evar x0;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                              dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_evar x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk47"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
‚Üí db_index ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk48"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_evar x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := [eta S];
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
             patt_free_evar x0;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar),
             patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                              dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar n <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_evar x <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater
                                              n dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_evar (Nat.pred n) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var);
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk49"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">evar</span>
‚Üí db_index ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{<span class="nb">evar</span>:a‚Ü¶x})%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat n dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &lt; dbi) (<span class="nv">_</span> : Nat_less n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar n <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n = dbi) (<span class="nv">_</span> : Nat_equal n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_evar x <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : n &gt; dbi) (<span class="nv">_</span> : Nat_greater n
                                           dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_evar (Nat.pred n) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var);
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4b"><span class="nb">unfold</span> evar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[<span class="nb">evar</span>:a‚Ü¶patt_free_evar x])%ml =
  apply_subst
    {|
      increase_ex := [eta S];
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x0</span> : <span class="nb">evar</span>),
          patt_free_evar x0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
          <span class="kr">match</span>
            compare_nat n dbi <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = compare_nat n dbi
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n dbi wildcard&#39; =
                    compare_nat n dbi,
                patt_bound_evar n
          | Nat_equal _ _ wildcard&#39; =&gt;
              <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n dbi wildcard&#39; =
                    compare_nat n dbi,
                patt_free_evar x
          | Nat_greater _ _ wildcard&#39; =&gt;
              <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n dbi wildcard&#39; =
                    compare_nat n dbi,
                patt_bound_evar (Nat.pred n)
          <span class="kr">end</span> (erefl (compare_nat n dbi));
      on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(phi^[<span class="nb">evar</span>:a‚Ü¶patt_free_evar x])%ml =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
        <span class="kr">match</span>
          compare_nat n dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat n dbi ‚Üí Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n dbi wildcard&#39; =
                  compare_nat n dbi, patt_bound_evar n
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n dbi wildcard&#39; =
                  compare_nat n dbi, patt_free_evar x
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n dbi wildcard&#39; =
                  compare_nat n dbi,
              patt_bound_evar (Nat.pred n)
        <span class="kr">end</span> (erefl (compare_nat n dbi));
    on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4d"><span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a phi =
apply_subst
  {|
    increase_ex := [eta S];
    increase_mu := id;
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Œª</span> <span class="nv">dbi</span> <span class="nv">n</span> : db_index,
        <span class="kr">match</span>
          compare_nat n dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat n dbi ‚Üí Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less n dbi wildcard&#39; =
                  compare_nat n dbi, patt_bound_evar n
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal n dbi wildcard&#39; =
                  compare_nat n dbi, patt_free_evar x
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater n dbi wildcard&#39; =
                  compare_nat n dbi,
              patt_bound_evar (Nat.pred n)
        <span class="kr">end</span> (erefl (compare_nat n dbi));
    on_bsvar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">N</span> : db_index, patt_bound_svar N
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Svar_open_morphism</span> (<span class="nv">X</span> : svar) :
     PatternMorphism (svar_open X) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := <span class="kr">fun</span> <span class="nv">x</span> =&gt; S x ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">Dbi</span> <span class="nv">N</span> =&gt;
        <span class="kr">match</span> compare_nat N Dbi <span class="kr">with</span>
        | Nat_less _ _ _ =&gt; patt_bound_svar N
        | Nat_equal _ _ _ =&gt; patt_free_svar X
        | Nat_greater _ _ _ =&gt; patt_bound_svar (Nat.pred N)
        <span class="kr">end</span>;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4e"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_svar X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
             patt_free_svar X0;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                              Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_svar X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk4f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
‚Üí db_index ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk50"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_svar X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := [eta S];
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>),
             patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
             patt_free_svar X0;
         on_bevar :=
           <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
             <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                              Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar N <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_free_svar X <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
               <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater
                                              N Dbi
                                              wildcard&#39; =
                                            filtered_var),
                 patt_bound_svar (Nat.pred N) <span class="kr">in</span>
             <span class="kr">match</span>
               filtered_var <span class="kr">as</span> anonymous&#39;
               <span class="kr">return</span>
                 (anonymous&#39; = filtered_var ‚Üí Pattern)
             <span class="kr">with</span>
             | Nat_less _ _ wildcard&#39; =&gt;
                 program_branch_0 wildcard&#39;
             | Nat_equal _ _ wildcard&#39; =&gt;
                 program_branch_1 wildcard&#39;
             | Nat_greater _ _ wildcard&#39; =&gt;
                 program_branch_2 wildcard&#39;
             <span class="kr">end</span> (erefl filtered_var)
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk51"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">svar
‚Üí db_index ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk52"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^{svar:a‚Ü¶X})%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">let</span> <span class="nv">filtered_var</span> := compare_nat N Dbi <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_0</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &lt; Dbi) (<span class="nv">_</span> : Nat_less N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar N <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_1</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N = Dbi) (<span class="nv">_</span> : Nat_equal N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_free_svar X <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">program_branch_2</span> :=
            <span class="kr">Œª</span> (<span class="nv">wildcard&#39;</span> : N &gt; Dbi) (<span class="nv">_</span> : Nat_greater N
                                           Dbi
                                           wildcard&#39; =
                                         filtered_var),
              patt_bound_svar (Nat.pred N) <span class="kr">in</span>
          <span class="kr">match</span>
            filtered_var <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = filtered_var ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              program_branch_0 wildcard&#39;
          | Nat_equal _ _ wildcard&#39; =&gt;
              program_branch_1 wildcard&#39;
          | Nat_greater _ _ wildcard&#39; =&gt;
              program_branch_2 wildcard&#39;
          <span class="kr">end</span> (erefl filtered_var)
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk53"><span class="nb">unfold</span> svar_open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">X</span> : svar) (<span class="nv">a</span> : db_index) (<span class="nv">phi</span> : Pattern),
  (phi^[svar:a‚Ü¶patt_free_svar X])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := [eta S];
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X0</span> : svar),
          patt_free_svar X0;
      on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
          <span class="kr">match</span>
            compare_nat N Dbi <span class="kr">as</span> anonymous&#39;
            <span class="kr">return</span>
              (anonymous&#39; = compare_nat N Dbi
               ‚Üí Pattern)
          <span class="kr">with</span>
          | Nat_less _ _ wildcard&#39; =&gt;
              <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N Dbi wildcard&#39; =
                    compare_nat N Dbi,
                patt_bound_svar N
          | Nat_equal _ _ wildcard&#39; =&gt;
              <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N Dbi wildcard&#39; =
                    compare_nat N Dbi,
                patt_free_svar X
          | Nat_greater _ _ wildcard&#39; =&gt;
              <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N Dbi wildcard&#39; =
                    compare_nat N Dbi,
                patt_bound_svar (Nat.pred N)
          <span class="kr">end</span> (erefl (compare_nat N Dbi))
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk54"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(phi^[svar:a‚Ü¶patt_free_svar X])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
        <span class="kr">match</span>
          compare_nat N Dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat N Dbi ‚Üí Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_bound_svar N
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_free_svar X
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N Dbi wildcard&#39; =
                  compare_nat N Dbi,
              patt_bound_svar (Nat.pred N)
        <span class="kr">end</span> (erefl (compare_nat N Dbi))
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk55"><span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a phi =
apply_subst
  {|
    increase_ex := id;
    increase_mu := [eta S];
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : db_index) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar := <span class="kr">Œª</span> <span class="nv">_</span> <span class="nv">n</span> : db_index, patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Œª</span> <span class="nv">Dbi</span> <span class="nv">N</span> : db_index,
        <span class="kr">match</span>
          compare_nat N Dbi <span class="kr">as</span> anonymous&#39;
          <span class="kr">return</span>
            (anonymous&#39; = compare_nat N Dbi ‚Üí Pattern)
        <span class="kr">with</span>
        | Nat_less _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_less N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_bound_svar N
        | Nat_equal _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_equal N Dbi wildcard&#39; =
                  compare_nat N Dbi, patt_free_svar X
        | Nat_greater _ _ wildcard&#39; =&gt;
            <span class="kr">Œª</span> <span class="nv">_</span> : Nat_greater N Dbi wildcard&#39; =
                  compare_nat N Dbi,
              patt_bound_svar (Nat.pred N)
        <span class="kr">end</span> (erefl (compare_nat N Dbi))
  |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Free_evar_subst_morphism</span> (<span class="nv">œà</span> : Pattern) :
     PatternMorphism (free_evar_subst œà) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> =&gt; <span class="kr">if</span> decide (x = x&#39;) <span class="kr">then</span> œà <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">X</span> =&gt; patt_free_svar X;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk56"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;))
          <span class="kr">then</span> œà
          <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
             <span class="kr">if</span> is_left (decide (x = x&#39;))
             <span class="kr">then</span> œà
             <span class="kr">else</span> patt_free_evar x&#39;;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk57"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern ‚Üí <span class="nb">evar</span> ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk58"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;))
          <span class="kr">then</span> œà
          <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
             <span class="kr">if</span> is_left (decide (x = x&#39;))
             <span class="kr">then</span> œà
             <span class="kr">else</span> patt_free_evar x&#39;;
         on_fsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
         on_bevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk59"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern ‚Üí <span class="nb">evar</span> ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>) (<span class="nv">phi</span> : Pattern),
  (phi^[[<span class="nb">evar</span>:a‚Ü¶œà]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;))
          <span class="kr">then</span> œà
          <span class="kr">else</span> patt_free_evar x&#39;;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5b"><span class="nb">intros</span> x&#39; db œÜ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := id;
    on_fevar :=
      <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
        <span class="kr">if</span> is_left (decide (x = x&#39;0))
        <span class="kr">then</span> x&#39;
        <span class="kr">else</span> patt_free_evar x&#39;0;
    on_fsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
    on_bevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
  |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5c"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk5d"><span class="nb">induction</span> œÜ; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_evar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk5e"><hr></label><div class="goal-conclusion">patt_app (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk5f"><hr></label><div class="goal-conclusion">patt_imp (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk60"><hr></label><div class="goal-conclusion">patt_exists (œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk61"><hr></label><div class="goal-conclusion">patt_mu (œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk62">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_evar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk63">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk64">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
  (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
          <span class="kr">if</span> is_left (decide (x = x&#39;0))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_evar x&#39;0;
      on_fsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar),
          patt_free_svar X;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (œÜ1^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml (œÜ2^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk65">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
(œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar :=
<span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
<span class="kr">if</span> is_left (decide (x = x&#39;0)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x&#39;0;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk66">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : <span class="nb">evar</span>),
(œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar :=
<span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
<span class="kr">if</span> is_left (decide (x = x&#39;0)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_evar x&#39;0;
on_fsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
on_bevar := <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (œÜ^[[<span class="nb">evar</span>:db‚Ü¶x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> <span class="nv">x</span> <span class="nv">x&#39;0</span> : <span class="nb">evar</span>,
           <span class="kr">if</span> is_left (decide (x = x&#39;0))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_evar x&#39;0;
       on_fsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">X</span> : svar), patt_free_svar X;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : <span class="nb">evar</span>) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
  <span class="kn">Program Instance</span> <span class="nf">Free_svar_subst_morphism</span> (<span class="nv">œà</span> : Pattern) :
     PatternMorphism (free_svar_subst œà) := {
    pm_spec_data := {|
      increase_ex := id ;
      increase_mu := id ;
      on_fevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">x</span> =&gt; patt_free_evar x ;
      on_fsvar := <span class="kr">fun</span> <span class="nv">X</span> <span class="nv">X&#39;</span> =&gt; <span class="kr">if</span> decide (X = X&#39;) <span class="kr">then</span> œà <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">n</span> =&gt; patt_bound_evar n;
      on_bsvar := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">N</span> =&gt; patt_bound_svar N;
    |}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk67"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : svar),
  on_bevar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> œà
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_ex
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
             <span class="kr">if</span> is_left (decide (X = X&#39;))
             <span class="kr">then</span> œà
             <span class="kr">else</span> patt_free_svar X&#39;;
         on_bevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk68"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern ‚Üí svar ‚Üí patt_bound_evar <span class="mi">0</span> = patt_bound_evar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk69"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : svar),
  on_bsvar
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> œà
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |}
    (increase_mu
       {|
         increase_ex := id;
         increase_mu := id;
         on_fevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
         on_fsvar :=
           <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
             <span class="kr">if</span> is_left (decide (X = X&#39;))
             <span class="kr">then</span> œà
             <span class="kr">else</span> patt_free_svar X&#39;;
         on_bevar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
             patt_bound_evar n;
         on_bsvar :=
           <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
             patt_bound_svar N
       |} a) <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pattern ‚Üí svar ‚Üí patt_bound_svar <span class="mi">0</span> = patt_bound_svar <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6b"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">a</span> : svar) (<span class="nv">phi</span> : Pattern),
  (phi^[[svar:a‚Ü¶œà]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> œà
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} a phi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6c"><span class="nb">intros</span> x&#39; db œÜ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
apply_subst
  {|
    increase_ex := id;
    increase_mu := id;
    on_fevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
    on_fsvar :=
      <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
        <span class="kr">if</span> is_left (decide (X = X&#39;))
        <span class="kr">then</span> x&#39;
        <span class="kr">else</span> patt_free_svar X&#39;;
    on_bevar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
    on_bsvar :=
      <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
  |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6d"><span class="nb">revert</span> x&#39; db.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
    |} db œÜ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk6e"><span class="nb">induction</span> œÜ; <span class="nb">intros</span> x&#39; db; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_svar x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk6f"><hr></label><div class="goal-conclusion">patt_app (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk70"><hr></label><div class="goal-conclusion">patt_imp (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk71"><hr></label><div class="goal-conclusion">patt_exists (œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk72"><hr></label><div class="goal-conclusion">patt_mu (œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk73">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (db = x) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar x) =
(<span class="kr">if</span> is_left (decide (db = x))
 <span class="kr">then</span> x&#39;
 <span class="kr">else</span> patt_free_svar x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">case_match; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk74">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
patt_app
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk75">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ1</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ1</span></span></span><br><span><var>IHœÜ2</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
  (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
  apply_subst
    {|
      increase_ex := id;
      increase_mu := id;
      on_fevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>),
          patt_free_evar x;
      on_fsvar :=
        <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
          <span class="kr">if</span> is_left (decide (X = X&#39;))
          <span class="kr">then</span> x&#39;
          <span class="kr">else</span> patt_free_svar X&#39;;
      on_bevar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
          patt_bound_evar n;
      on_bsvar :=
        <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
          patt_bound_svar N
    |} db œÜ2</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (œÜ1^[[svar:db‚Ü¶x&#39;]])%ml (œÜ2^[[svar:db‚Ü¶x&#39;]])%ml =
patt_imp
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ1)
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> -&gt; IHœÜ1, IHœÜ2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk76">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
(œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar :=
<span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
<span class="kr">if</span> is_left (decide (X = X&#39;)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar X&#39;;
on_bevar := <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists (œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
patt_exists
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk77">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>IHœÜ</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> (<span class="nv">x&#39;</span> : Pattern) (<span class="nv">db</span> : svar),
(œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
apply_subst
{|
increase_ex := id;
increase_mu := id;
on_fevar := <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
on_fsvar :=
<span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
<span class="kr">if</span> is_left (decide (X = X&#39;)) <span class="kr">then</span> x&#39; <span class="kr">else</span> patt_free_svar X&#39;;
on_bevar := <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index), patt_bound_evar n;
on_bsvar := <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index), patt_bound_svar N
|} db œÜ</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>db</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu (œÜ^[[svar:db‚Ü¶x&#39;]])%ml =
patt_mu
  (apply_subst
     {|
       increase_ex := id;
       increase_mu := id;
       on_fevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">x</span> : <span class="nb">evar</span>), patt_free_evar x;
       on_fsvar :=
         <span class="kr">Œª</span> <span class="nv">X</span> <span class="nv">X&#39;</span> : svar,
           <span class="kr">if</span> is_left (decide (X = X&#39;))
           <span class="kr">then</span> x&#39;
           <span class="kr">else</span> patt_free_svar X&#39;;
       on_bevar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">n</span> : db_index),
           patt_bound_evar n;
       on_bsvar :=
         <span class="kr">Œª</span> (<span class="nv">_</span> : svar) (<span class="nv">N</span> : db_index),
           patt_bound_svar N
     |} db œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHœÜ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**</span>
<span class="sd">   * Substitution type classes for the different syntacical cateories</span>

<span class="sd">   Every syntactic construct has a category (unary operator, binder etc),</span>
<span class="sd">   and has to have certain properties about well-formedness</span>
<span class="sd">   and substitution.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Binary</span> (<span class="nv">binary</span> : Pattern -&gt; Pattern -&gt; Pattern) := {
    binary_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi1</span> <span class="nv">phi2</span> : Pattern) <span class="nv">a</span>,
        f a (binary phi1 phi2) = binary (f a phi1) (f a phi2) ;
     binary_wf : <span class="kr">forall</span> <span class="nv">œà1</span> <span class="nv">œà2</span>, well_formed œà1 -&gt; well_formed œà2 -&gt; 
        well_formed (binary œà1 œà2) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Unary</span> (<span class="nv">unary</span> : Pattern -&gt; Pattern) := {
    unary_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
        f a (unary phi) = unary (f a phi) ;
    unary_wf : <span class="kr">forall</span> <span class="nv">œà</span>, well_formed œà -&gt; well_formed (unary œà) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Nullary</span> (<span class="nv">nullary</span> : Pattern) := {
    nullary_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) <span class="nv">a</span>,
        f a nullary = nullary ;
    nullary_wf : well_formed nullary ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">EBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern) := {
    ebinder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
        f a (<span class="kn">binder</span> phi) = <span class="kn">binder</span> (f (increase_ex pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">SBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern) := {
    sbinder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">f_morph</span> : PatternMorphism f) (<span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
        f a (<span class="kn">binder</span> phi) = <span class="kn">binder</span> (f (increase_mu pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Next, we define instances for the primitives of matching logic: *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">EBinder_exists</span> : EBinder patt_exists := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk78"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A ‚Üí Pattern ‚Üí Pattern) (<span class="nv">f_morph</span> : 
                                          PatternMorphism
                                            f) (<span class="nv">phi</span> : Pattern) 
  (<span class="nv">a</span> : A),
  f a (patt_exists phi) =
  patt_exists (f (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk79"><span class="nb">intros</span> A f m œÜ a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_exists œÜ) =
patt_exists (f (increase_ex pm_spec_data a) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7a"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_exists œÜ) =
patt_exists
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) œÜ) =
patt_exists
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">SBinder_mu</span> : SBinder patt_mu := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7c"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A ‚Üí Pattern ‚Üí Pattern) (<span class="nv">f_morph</span> : 
                                          PatternMorphism
                                            f) (<span class="nv">phi</span> : Pattern) 
  (<span class="nv">a</span> : A),
  f a (patt_mu phi) =
  patt_mu (f (increase_mu pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7d"><span class="nb">intros</span> A f m œÜ a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_mu œÜ) =
patt_mu (f (increase_mu pm_spec_data a) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7e"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_mu œÜ) =
patt_mu
  (apply_subst pm_spec_data
     (increase_mu pm_spec_data a) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk7f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_mu
  (apply_subst pm_spec_data
     (increase_mu pm_spec_data a) œÜ) =
patt_mu
  (apply_subst pm_spec_data
     (increase_mu pm_spec_data a) œÜ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Binary_imp</span> : Binary patt_imp := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk80"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A ‚Üí Pattern ‚Üí Pattern),
  PatternMorphism f
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">phi1</span> <span class="nv">phi2</span> : Pattern) (<span class="nv">a</span> : A),
      f a (patt_imp phi1 phi2) =
      patt_imp (f a phi1) (f a phi2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk81"><span class="nb">intros</span> A f m œÜ1 œÜ2 a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_imp œÜ1 œÜ2) = patt_imp (f a œÜ1) (f a œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk82"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_imp œÜ1 œÜ2) =
patt_imp (apply_subst pm_spec_data a œÜ1)
  (apply_subst pm_spec_data a œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk83"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_imp (apply_subst pm_spec_data a œÜ1)
  (apply_subst pm_spec_data a œÜ2) =
patt_imp (apply_subst pm_spec_data a œÜ1)
  (apply_subst pm_spec_data a œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk84"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">œà1</span> <span class="nv">œà2</span> : Pattern,
  well_formed œà1
  ‚Üí well_formed œà2 ‚Üí well_formed (patt_imp œà1 œà2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk85"><span class="nb">intros</span> œÜ1 œÜ2 WF1 WF2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WF1</var><span class="hyp-type"><b>: </b><span>well_formed œÜ1</span></span></span><br><span><var>WF2</var><span class="hyp-type"><b>: </b><span>well_formed œÜ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (patt_imp œÜ1 œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> well_formed_imp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Binary_app</span> : Binary patt_app := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk86"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A ‚Üí Pattern ‚Üí Pattern),
  PatternMorphism f
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">phi1</span> <span class="nv">phi2</span> : Pattern) (<span class="nv">a</span> : A),
      f a (patt_app phi1 phi2) =
      patt_app (f a phi1) (f a phi2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk87"><span class="nb">intros</span> A f m œÜ1 œÜ2 a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_app œÜ1 œÜ2) = patt_app (f a œÜ1) (f a œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk88"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_app œÜ1 œÜ2) =
patt_app (apply_subst pm_spec_data a œÜ1)
  (apply_subst pm_spec_data a œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk89"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_app (apply_subst pm_spec_data a œÜ1)
  (apply_subst pm_spec_data a œÜ2) =
patt_app (apply_subst pm_spec_data a œÜ1)
  (apply_subst pm_spec_data a œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">œà1</span> <span class="nv">œà2</span> : Pattern,
  well_formed œà1
  ‚Üí well_formed œà2 ‚Üí well_formed (patt_app œà1 œà2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8b"><span class="nb">intros</span> œÜ1 œÜ2 WF1 WF2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œÜ1, œÜ2</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WF1</var><span class="hyp-type"><b>: </b><span>well_formed œÜ1</span></span></span><br><span><var>WF2</var><span class="hyp-type"><b>: </b><span>well_formed œÜ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed (patt_app œÜ1 œÜ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> well_formed_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Nullary_bott</span> : Nullary patt_bott := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8c"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A ‚Üí Pattern ‚Üí Pattern),
  PatternMorphism f
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">a</span> : A, f a patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8d"><span class="nb">intros</span> A f m a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8e"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk8f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_bott = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk90"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Nullary_sym</span> <span class="nv">s</span> : Nullary (patt_sym s) := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk91"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">s</span> : symbols) (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A ‚Üí Pattern ‚Üí Pattern),
  PatternMorphism f
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">a</span> : A, f a (patt_sym s) = patt_sym s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk92"><span class="nb">intros</span> A s f m a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>s ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_sym A) = patt_sym A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk93"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>s ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_sym A) = patt_sym A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk94"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>symbols</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>s ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_sym A = patt_sym A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk95"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s</span> : symbols, well_formed (patt_sym s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">SwappableEx</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern) (<span class="nv">g</span> : Pattern -&gt; Pattern)
  (<span class="nv">m</span> : PatternMorphism f) :=
{
  eswap : <span class="kr">forall</span> <span class="nv">phi</span> <span class="nv">a</span>,
    apply_subst pm_spec_data (increase_ex pm_spec_data a) (g phi) =
    g (apply_subst pm_spec_data a phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Bevar_subst_swaps_ex_nesting</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">p</span> : well_formed_closed œà) :
  SwappableEx _ nest_ex (Bevar_subst_morphism œà).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk96"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">œà</span> : Pattern,
  well_formed_closed œà
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk97"><span class="nb">intros</span> œà WFœà phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk98"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data a‚Ü¶œà])%ml =
nest_ex (phi^[<span class="nb">evar</span>:a‚Ü¶œà])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk99"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               a‚Ü¶œà])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[<span class="nb">evar</span>:a‚Ü¶œà])%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9a"><span class="nb">rewrite</span> &lt;- nest_ex_gt; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               a‚Ü¶œà])%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:a + <span class="mi">1</span>‚Ü¶œà])%ml</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chk9b"><hr></label><div class="goal-conclusion">a ‚â• <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9c"><span class="mi">2</span>: <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               a‚Ü¶œà])%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:a + <span class="mi">1</span>‚Ü¶œà])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9d"><span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:increase_ex pm_spec_data
                               a‚Ü¶œà])%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[<span class="nb">evar</span>:<span class="mi">1</span> + a‚Ü¶œà])%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Bsvar_subst_swaps_ex_nesting</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">p</span> : well_formed_closed œà) :
  SwappableEx _ nest_ex (Bsvar_subst_morphism œà).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9e"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">œà</span> : Pattern,
  well_formed_closed œà
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chk9f"><span class="nb">intros</span> œà WFœà phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka0"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[svar:increase_ex pm_spec_data a‚Ü¶œà])%ml =
nest_ex (phi^[svar:a‚Ü¶œà])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka1"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[svar:increase_ex pm_spec_data
                               a‚Ü¶œà])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[svar:a‚Ü¶œà])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka2"><span class="nb">rewrite</span> bsvar_subst_nest_ex_aux_comm; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux œà <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka3"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> WFœà.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux œà <span class="mi">0</span> = true ‚àß well_formed_closed_ex_aux œà <span class="mi">0</span> = true</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux œà <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> WFœà.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Fevar_subst_swaps_ex_nesting</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">p</span> : well_formed_closed œà) :
  SwappableEx _ nest_ex (Free_evar_subst_morphism œà).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka4"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">œà</span> : Pattern,
  well_formed_closed œà
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : <span class="nb">evar</span>),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka5"><span class="nb">intros</span> œà WFœà phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka6"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[[<span class="nb">evar</span>:increase_ex pm_spec_data a‚Ü¶œà]])%ml =
nest_ex (phi^[[<span class="nb">evar</span>:a‚Ü¶œà]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka7"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[[<span class="nb">evar</span>:increase_ex pm_spec_data
                                a‚Ü¶œà]])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[[<span class="nb">evar</span>:a‚Ü¶œà]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka8"><span class="nb">rewrite</span> nest_ex_free_evar_subst; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux œà <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chka9"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> WFœà.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux œà <span class="mi">0</span> = true ‚àß well_formed_closed_ex_aux œà <span class="mi">0</span> = true</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux œà <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> WFœà.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Fsvar_subst_swaps_ex_nesting</span> (<span class="nv">œà</span> : Pattern) (<span class="nv">p</span> : well_formed_closed œà) :
  SwappableEx _ nest_ex (Free_svar_subst_morphism œà).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkaa"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">œà</span> : Pattern,
  well_formed_closed œà
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : svar),
      apply_subst pm_spec_data
        (increase_ex pm_spec_data a) (nest_ex phi) =
      nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkab"><span class="nb">intros</span> œà WFœà phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkac"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^[[svar:increase_ex pm_spec_data a‚Ü¶œà]])%ml =
nest_ex (phi^[[svar:a‚Ü¶œà]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkad"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^[[svar:increase_ex pm_spec_data
                                a‚Ü¶œà]])%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^[[svar:a‚Ü¶œà]])%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkae"><span class="nb">rewrite</span> nest_ex_free_svar_subst; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed œà</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux œà <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkaf"><span class="nb">apply</span> andb_true_iff <span class="kr">in</span> WFœà.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>WFœà</var><span class="hyp-type"><b>: </b><span>well_formed_closed_mu_aux œà <span class="mi">0</span> = true ‚àß well_formed_closed_ex_aux œà <span class="mi">0</span> = true</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_closed_ex_aux œà <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> WFœà.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Evar_quantify_swaps_ex_nesting</span> (<span class="nv">x</span> : <span class="nb">evar</span>) :
  SwappableEx _ nest_ex (Evar_quantify_morphism x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb0"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb1"><span class="nb">intros</span> œà phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb2"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^{{<span class="nb">evar</span>:œà‚Ü¶increase_ex pm_spec_data a}})%ml =
nest_ex (phi^{{<span class="nb">evar</span>:œà‚Ü¶a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb3"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:œà‚Ü¶increase_ex
                                  pm_spec_data a}})%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^{{<span class="nb">evar</span>:œà‚Ü¶a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb4"><span class="nb">rewrite</span> &lt;- nest_ex_gt_evar_quantify; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:œà‚Ü¶increase_ex
                                  pm_spec_data a}})%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:œà‚Ü¶a + <span class="mi">1</span>}})%ml</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkb5"><hr></label><div class="goal-conclusion">a ‚â• <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb6"><span class="mi">2</span>: <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:œà‚Ü¶increase_ex
                                  pm_spec_data a}})%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:œà‚Ü¶a + <span class="mi">1</span>}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb7"><span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:œà‚Ü¶increase_ex
                                  pm_spec_data a}})%ml =
((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{<span class="nb">evar</span>:œà‚Ü¶<span class="mi">1</span> + a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Svar_quantify_swaps_ex_nesting</span> (<span class="nv">X</span> : svar) :
  SwappableEx _ nest_ex (Svar_quantify_morphism X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb8"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">X</span> : svar) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkb9"><span class="nb">intros</span> œà phi a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkba"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex phi)^{{svar:œà‚Ü¶increase_ex pm_spec_data a}})%ml =
nest_ex (phi^{{svar:œà‚Ü¶a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbb"><span class="nb">unfold</span> nest_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>œà</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> phi)^{{svar:œà‚Ü¶increase_ex
                                  pm_spec_data a}})%ml =
nest_ex_aux <span class="mi">0</span> <span class="mi">1</span> (phi^{{svar:œà‚Ü¶a}})%ml</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> nest_ex_svar_quantify.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Evar_open_swaps_ex_nesting</span> (<span class="nv">x</span> : <span class="nb">evar</span>) :
  SwappableEx _ nest_ex (Evar_open_morphism x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbc"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">x</span> : <span class="nb">evar</span>) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* TODO: here type class inference fails without the explicit parameters *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (@eswap _ _ _ _ (Bevar_subst_swaps_ex_nesting (patt_free_evar x) _)); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>]
<span class="kn">Program Instance</span> <span class="nf">Svar_open_swaps_ex_nesting</span> (<span class="nv">X</span> : svar) :
  SwappableEx _ nest_ex (Svar_open_morphism X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbe"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">X</span> : svar) (<span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : db_index),
  apply_subst pm_spec_data
    (increase_ex pm_spec_data a) (nest_ex phi) =
  nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* TODO: here type class inference fails without the explicit parameters *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkbf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>svar</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>db_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data (increase_ex pm_spec_data a)
  (nest_ex phi) =
nest_ex (apply_subst pm_spec_data a phi)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (@eswap _ _ _ _ (Bsvar_subst_swaps_ex_nesting (patt_free_svar X) _)); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* TODO: mu operations:</span>

<span class="c">Class SwappableMu {A : Type} (f : A -&gt; Pattern -&gt; Pattern) (g : Pattern -&gt; Pattern)</span>
<span class="c">  (m : PatternMorphism f) :=</span>
<span class="c">{</span>
<span class="c">  szero_increase : forall a,</span>
<span class="c">    apply_subst spec_data (increase_mu spec_data a) (patt_bound_svar 0) = patt_bound_svar 0 ;</span>
<span class="c">  sswap_f_g : forall phi a,</span>
<span class="c">    apply_subst spec_data (increase_mu spec_data a) (g phi) =</span>
<span class="c">    g (apply_subst spec_data a phi) ;</span>
<span class="c">}.</span>

<span class="c">#[global]</span>
<span class="c">Program Instance Bsvar_subst_swaps_nesting (œà : Pattern) (p : well_formed_closed œà) :</span>
<span class="c">  @SwappableMu _ (bsvar_subst œà) nest_mu (Bsvar_subst_morphism œà).</span>
<span class="c">Next Obligation.</span>
<span class="c">  intros. rewrite &lt;- correctness. reflexivity.</span>
<span class="c">Defined.</span>
<span class="c">Next Obligation.</span>
<span class="c">  intros œà WFœà phi a.</span>
<span class="c">  do 2 rewrite &lt;- correctness.</span>
<span class="c">  unfold nest_mu. rewrite &lt;- nest_mu_gt; auto. 2: lia.</span>
<span class="c">  rewrite Nat.add_comm. reflexivity.</span>
<span class="c">Defined. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ESortedBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern -&gt; Pattern) (<span class="nv">g</span> : Pattern -&gt; Pattern) := {
    esorted_binder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern)
         (<span class="nv">f_morph</span> : PatternMorphism f)
         (<span class="nv">f_swap</span> : SwappableEx f g f_morph) (<span class="nv">s</span> <span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
      f a (<span class="kn">binder</span> s phi) = <span class="kn">binder</span> (f a s) (f (increase_ex pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">SSortedBinder</span> (<span class="nv">binder</span> : Pattern -&gt; Pattern -&gt; Pattern) (<span class="nv">g</span> : Pattern -&gt; Pattern) := {
    ssorted_binder_morphism :
      <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; Pattern -&gt; Pattern)
         (<span class="nv">f_morph</span> : PatternMorphism f)
         (<span class="nv">f_swap</span> : SwappableEx f g f_morph) (<span class="nv">s</span> <span class="nv">phi</span> : Pattern) <span class="nv">a</span>,
      f a (<span class="kn">binder</span> s phi) = <span class="kn">binder</span> (f a s) (f (increase_mu pm_spec_data a) phi) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Next, we define the substitution simplification record: *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mlSimpl&#39;</span> :=
(
  @binary_morphism,
  @unary_morphism,
  @nullary_morphism,
  @ebinder_morphism,
  @sbinder_morphism
).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_signature</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">  Hints are needed to automatically infer the SwappableEx instances.</span>
<span class="c">  TODO: there is still a problem when the well_formed_closed assumption is</span>
<span class="c">        missing</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Bevar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Bsvar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Fevar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Fsvar_subst_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Evar_quantify_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Svar_quantify_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Evar_open_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Resolve</span> Svar_open_swaps_ex_nesting : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**</span>
<span class="sd">  This tactic identifies the sorted binder for simplification (by checking its type).</span>
<span class="sd">  Since automatic identification of the instance of the type class is not working</span>
<span class="sd">  currently, we identify the correct instance by giving the parameters inferred</span>
<span class="sd">  from the context.</span>

<span class="sd">  TODO: more strict identification of the point where the simplification has to be</span>
<span class="sd">        made, since nested sorted quantifiers can occur, which break the tactic.</span>
<span class="sd">        One potential solution is to use Ltac2.</span>
<span class="sd">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simpl_sorted_quantification</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span> G [<span class="nl">?f</span> <span class="nl">?arg</span> _ (<span class="nl">?binder</span> _ _)] =&gt;
    <span class="kr">match</span> <span class="kp">type of</span> <span class="kn">binder</span> <span class="kr">with</span>
    | Pattern -&gt; Pattern -&gt; Pattern =&gt;
      <span class="kr">tryif</span>
       <span class="nb">unshelve</span> (<span class="nb">erewrite</span> (@esorted_binder_morphism _ <span class="kn">binder</span>
            _ _ _ (f arg) _ _));
       <span class="kr">match goal with</span>
       | |- SwappableEx _ _ _ =&gt; <span class="nb">auto</span>
       | |- PatternMorphism _ =&gt; <span class="bp">now</span> <span class="nb">typeclasses eauto</span>
       | |- ESortedBinder _ _ =&gt; <span class="kr">tryif</span> <span class="bp">now</span> <span class="nb">typeclasses eauto</span> <span class="kr">then</span> <span class="kp">idtac</span> <span class="kr">else</span> <span class="kp">fail</span> <span class="mi">3</span>
       | _ =&gt; <span class="kp">idtac</span>
       <span class="kr">end</span>
      <span class="kr">then</span> <span class="kp">idtac</span>
      <span class="kr">else</span> <span class="kp">idtac</span> <span class="c">(* &quot;No sorted simplification instance for &quot; binder *)</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simpl_sorted_quantification_hyp</span> H :=
<span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | <span class="kp">context</span> G [<span class="nl">?f</span> <span class="nl">?arg</span> _ (<span class="nl">?binder</span> _ _)] =&gt; 
    <span class="kr">match</span> <span class="kp">type of</span> <span class="kn">binder</span> <span class="kr">with</span>
    | Pattern -&gt; Pattern -&gt; Pattern =&gt; 
      <span class="kr">tryif</span>
       (<span class="kr">let</span> <span class="nv">name</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span>
         <span class="nb">unshelve</span> (<span class="nb">epose proof</span> (name := @esorted_binder_morphism _ <span class="kn">binder</span>
            _ _ _ (f arg) _ _)); <span class="kp">try</span> (<span class="nb">rewrite</span> name <span class="kr">in</span> H; <span class="nb">clear</span> name);
            <span class="kp">try</span> <span class="nb">typeclasses eauto</span>; <span class="nb">auto</span>;
            <span class="kr">match goal with</span>
             | |- SwappableEx _ _ _ =&gt; <span class="nb">clear</span> H
             | |- PatternMorphism _ =&gt; <span class="nb">clear</span> H; <span class="bp">now</span> <span class="nb">typeclasses eauto</span>
             | |- ESortedBinder _ _ =&gt; <span class="nb">clear</span> H; <span class="kr">tryif</span> <span class="bp">now</span> <span class="nb">typeclasses eauto</span> <span class="kr">then</span> <span class="kp">idtac</span> <span class="kr">else</span> <span class="kp">fail</span> <span class="mi">3</span>
             | _ =&gt; <span class="kp">idtac</span>
            <span class="kr">end</span>
              )
      <span class="kr">then</span> <span class="kp">idtac</span>
      <span class="kr">else</span> <span class="kp">idtac</span> <span class="c">(* &quot;No sorted simplification instance for &quot; binder *)</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Test</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Substitution.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> ml_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Œ£</span> : Signature}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlSimpl&quot;</span> :=
  <span class="kp">repeat</span> (<span class="nb">rewrite</span> mlSimpl&#39; + simpl_sorted_quantification); <span class="kp">try</span> <span class="nb">rewrite</span> [increase_ex _ _]/=; <span class="kp">try</span> <span class="nb">rewrite</span> [increase_mu]/=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;mlSimpl&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kp">repeat</span> (<span class="nb">rewrite</span> mlSimpl&#39; <span class="kr">in</span> H + simpl_sorted_quantification_hyp H); <span class="kp">try</span> <span class="nb">rewrite</span> [increase_ex _ _]/= <span class="kr">in</span> H; <span class="kp">try</span> <span class="nb">rewrite</span> [increase_mu _ _]/= <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">patt_forall_of_sort</span> (<span class="nv">sort</span> <span class="nv">phi</span> : Pattern) : Pattern :=
    patt_exists (patt_imp (patt_imp (patt_bound_evar <span class="mi">0</span>) (nest_ex sort)) phi).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local]
  <span class="kn">Program Instance</span> <span class="nf">sorted_forall_binder</span> : ESortedBinder patt_forall_of_sort nest_ex := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc0"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A ‚Üí Pattern ‚Üí Pattern) (<span class="nv">f_morph</span> : 
                                          PatternMorphism
                                            f),
  SwappableEx f nest_ex f_morph
  ‚Üí <span class="kr">‚àÄ</span> (<span class="nv">s</span> <span class="nv">phi</span> : Pattern) (<span class="nv">a</span> : A),
      f a (patt_forall_of_sort s phi) =
      patt_forall_of_sort (f a s)
        (f (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (patt_forall_of_sort s phi) =
patt_forall_of_sort (f a s)
  (f (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc2"><span class="kp">repeat</span> <span class="nb">rewrite</span> pm_correctness.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_subst pm_spec_data a (patt_forall_of_sort s phi) =
patt_forall_of_sort (apply_subst pm_spec_data a s)
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists
  (patt_imp
     (patt_imp
        (on_bevar pm_spec_data
           (increase_ex pm_spec_data a) <span class="mi">0</span>)
        (apply_subst pm_spec_data
           (increase_ex pm_spec_data a) (nest_ex s)))
     (apply_subst pm_spec_data
        (increase_ex pm_spec_data a) phi)) =
patt_forall_of_sort (apply_subst pm_spec_data a s)
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc4"><span class="nb">rewrite</span> eswap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚Üí Pattern ‚Üí Pattern</span></span></span><br><span><var>f_morph</var><span class="hyp-type"><b>: </b><span>PatternMorphism f</span></span></span><br><span><var>f_swap</var><span class="hyp-type"><b>: </b><span>SwappableEx f nest_ex f_morph</span></span></span><br><span><var>s, phi</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_exists
  (patt_imp
     (patt_imp
        (on_bevar pm_spec_data
           (increase_ex pm_spec_data a) <span class="mi">0</span>)
        (nest_ex (apply_subst pm_spec_data a s)))
     (apply_subst pm_spec_data
        (increase_ex pm_spec_data a) phi)) =
patt_forall_of_sort (apply_subst pm_spec_data a s)
  (apply_subst pm_spec_data
     (increase_ex pm_spec_data a) phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> pm_ezero_increase.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc5"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">œà</span> <span class="nv">x</span>, <span class="c">(* well_formed_closed œà -&gt; *)</span>
(patt_forall_of_sort s œà)^[[<span class="nb">evar</span>: x ‚Ü¶ œà]] = patt_bott -&gt;
(patt_forall_of_sort s œà)^{<span class="nb">evar</span>: <span class="mi">0</span> ‚Ü¶ x} = patt_bott -&gt;
(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>: x ‚Ü¶ <span class="mi">0</span>}} = patt_bott -&gt;
(patt_forall_of_sort s œà)^[[<span class="nb">evar</span>: x ‚Ü¶ œà]] = patt_bott /\ 
(patt_forall_of_sort s œà)^{<span class="nb">evar</span>: <span class="mi">0</span> ‚Ü¶ x} = patt_bott /\
(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>: x ‚Ü¶ <span class="mi">0</span>}} = patt_bott
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">s</span> <span class="nv">œà</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott
  ‚Üí (patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott
    ‚Üí (patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
      patt_bott
      ‚Üí (patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
        patt_bott
        ‚àß (patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} =
          patt_bott
          ‚àß (patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
            patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">s</span> <span class="nv">œà</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott
  ‚Üí (patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott
    ‚Üí (patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
      patt_bott
      ‚Üí (patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
        patt_bott
        ‚àß (patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} =
          patt_bott
          ‚àß (patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
            patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott
‚àß (patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott
  ‚àß (patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} = patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkc8">mlSimpl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst œà) nest_ex
  (Free_evar_subst_morphism œà)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkc9"><hr></label><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott
‚àß patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
    œà^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>‚Ü¶x} = patt_bott
  ‚àß patt_forall_of_sort s^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
      œà^{{<span class="nb">evar</span>:x‚Ü¶increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkca"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott
‚àß patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
    œà^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>‚Ü¶x} = patt_bott
  ‚àß patt_forall_of_sort s^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
      œà^{{<span class="nb">evar</span>:x‚Ü¶increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkcb">mlSimpl <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst œà) nest_ex
  (Free_evar_subst_morphism œà)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott</span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkcc"><hr></label><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott
‚àß patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
    œà^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>‚Ü¶x} = patt_bott
  ‚àß patt_forall_of_sort s^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
      œà^{{<span class="nb">evar</span>:x‚Ü¶increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkcd"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott
‚àß patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
    œà^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>‚Ü¶x} = patt_bott
  ‚àß patt_forall_of_sort s^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
      œà^{{<span class="nb">evar</span>:x‚Ü¶increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkce">mlSimpl <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} œà^{<span class="nb">evar</span>:<span class="mi">1</span>‚Ü¶x} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">patt_forall_of_sort s^[[<span class="nb">evar</span>:x‚Ü¶œà]] œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott
‚àß patt_forall_of_sort s^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x}
    œà^{<span class="nb">evar</span>:increase_ex pm_spec_data <span class="mi">0</span>‚Ü¶x} = patt_bott
  ‚àß patt_forall_of_sort s^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}}
      œà^{{<span class="nb">evar</span>:x‚Ü¶increase_ex pm_spec_data <span class="mi">0</span>}} =
    patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">mlSimpl <span class="kr">in</span> H1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkcf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{<span class="nb">evar</span>:<span class="mi">0</span>‚Ü¶x} = patt_bott</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(patt_forall_of_sort s œà)^{{<span class="nb">evar</span>:x‚Ü¶<span class="mi">0</span>}} =
patt_bott</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst œà) nest_ex
  (Free_evar_subst_morphism œà)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd0"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">œà</span> <span class="nv">x</span>, <span class="c">(* well_formed_closed œà -&gt; *)</span>
(patt_forall_of_sort (patt_imp s s) œà)^[[<span class="nb">evar</span>: x ‚Ü¶ œà]] = patt_bott
.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">s</span> <span class="nv">œà</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort (patt_imp s s) œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
  patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">s</span> <span class="nv">œà</span> : Pattern) (<span class="nv">x</span> : <span class="nb">evar</span>),
  (patt_forall_of_sort (patt_imp s s) œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
  patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(patt_forall_of_sort (patt_imp s s) œà)^[[<span class="nb">evar</span>:x‚Ü¶œà]] =
patt_bott</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd3">simpl_sorted_quantification.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst œà) nest_ex
  (Free_evar_subst_morphism œà)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkd4"><hr></label><div class="goal-conclusion">patt_forall_of_sort (patt_imp s s)^[[<span class="nb">evar</span>:x‚Ü¶œà]]
  œà^[[<span class="nb">evar</span>:increase_ex pm_spec_data x‚Ü¶œà]] = patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="SyntacticConstruct-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="SyntacticConstruct-v-chkd5"><span class="mi">2</span>: mlSimpl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SwappableEx (free_evar_subst œà) nest_ex
  (Free_evar_subst_morphism œà)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="SyntacticConstruct-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>Signature</span></span></span><br><span><var>s, œà</var><span class="hyp-type"><b>: </b><span>Pattern</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="nb">evar</span></span></span></span><br></div><label class="goal-separator" for="SyntacticConstruct-v-chkd6"><hr></label><div class="goal-conclusion">patt_forall_of_sort
  (patt_imp s^[[<span class="nb">evar</span>:x‚Ü¶œà]] s^[[<span class="nb">evar</span>:x‚Ü¶œà]])
  œà^[[<span class="nb">evar</span>:x‚Ü¶œà]] = patt_bott</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Test</span>.</span></span></pre></article></body></html>