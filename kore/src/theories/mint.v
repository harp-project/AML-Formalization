From MatchingLogic Require Export stdpp_ext.
From Kore Require Export Semantics.
Import Signature.StringVariables.
Import Kore.Syntax.Notations.

From Coq Require Import ZArith.

Open Scope kore_scope.
Open Scope hlist_scope.
Open Scope string_scope.

(**
   This is copied from the other file.
 *)
Ltac autorewrite_set :=
  repeat (
    rewrite intersection_top_l_L +
    rewrite intersection_top_r_L +
    rewrite union_empty_l_L +
    rewrite union_empty_r_L +
    rewrite propset_difference_neg +
    rewrite propset_union_simpl +
    rewrite propset_intersection_simpl +
    rewrite singleton_subseteq_l +
    rewrite fmap_propset_singleton
  ).

Ltac basic_simplify_krule :=
  eval_helper2;
  simpl sort_inj;
  repeat (rewrite_app_ext; try rewrite fmap_propset_singleton);
  autorewrite_set.

Ltac simplify_krule :=
  basic_simplify_krule;
  apply propset_top_elem_of_2;
  intro;
  apply elem_of_PropSet;
  repeat rewrite elem_of_PropSet;
  repeat rewrite singleton_subseteq;
  repeat rewrite singleton_eq.

Ltac abstract_var := 
  match goal with
    | [|- context [evar_valuation ?σ ?s]] =>
      let x := fresh "var" in
      let Hx := fresh "Hvar" in
        remember (evar_valuation σ s) as x eqn:Hx (*;
        clear Hx;
        revert x *)
    end.

From stdpp Require Import bitvector.

(**
   This is the metatheory for MInt. This should not be needed for non-hooked
   types.
 *)
Module MInt.

  Import bitvector.

  Definition MInt (n : nat) : Set := bv (N.of_nat n).

  Definition neg {n : nat} : MInt n -> MInt n := bv_opp.

  Definition natvalue {n : nat} (x : MInt n) : nat := Z.to_nat (bv_unsigned x).

  Definition natural {n : nat} (x : nat) : MInt n := Z_to_bv (N.of_nat n) (Z.of_nat x).

  Instance bv_wf_zero (n : N) : BvWf n 0.
  Proof.
    apply bv_wf_in_range. split.
    apply Z.le_refl. apply bv_modulus_pos.
  Defined.

  (**
     Find more operations in this module.
   *)
  (* Search _ in definitions. *)
End MInt.

Module NonRecursive.

  Import CRelationClasses.

  (**
     Example parametric sorts, without recursive parameters.
   *)
  Inductive MintSorts : Set :=
    | SortNat
    | SortMInt (n : nat)
  .

  (**
     This is generated by taking all the sorts' parameters (if a sort has none, use one ()/unit) and separating all of them with +.
   *)
  Definition MintSorts_base : Set := () + nat.

  (**
     Same as in the other file, should be constant.
   *)
  Instance MintSorts_eqdecision : EqDecision MintSorts.
  Proof. solve_decision. Defined.

  (**
     This is fairly standard based on the structure of the sort type, we
     just need to map the above base type to the sorts and back. With a
     large number of sorts, there will be a lot of inl's. The different
     functions can be placed into separate definitions. See the next module
     for a more complicated, recursive sort definition.
   *)
  Instance MintSorts_countable : Countable MintSorts.
  Proof.
    unshelve refine (inj_countable' (A := MintSorts_base) _ _ _).
    refine (λ x, match x with
                  | SortNat    => inl ()
                  | SortMInt n => inr n
                  end
    ).
    refine (λ x, match x with
                  | inl () => SortNat
                  | inr n  => SortMInt n
                  end
    ).
    intros []; auto.
  Defined.

  (**
     No subsorts in this example.
   *)
  Inductive MintSubsort : crelation MintSorts := .

  Inductive SortNat_carrier : Set :=
    c_nat (n : nat)
  with SortMInt_carrier : nat -> Set :=
    c_mint (n : nat) (x : MInt.MInt n) : SortMInt_carrier n
  .

  Definition carrier (s : MintSorts) : Set :=
    match s with
    | SortNat    => SortNat_carrier
    | SortMInt n => SortMInt_carrier n
    end.

  Instance carrier_inhabited : forall s, Inhabited (carrier s).
  Proof.
    intros []; repeat unshelve econstructor.
    apply MInt.bv_wf_zero.
  Defined.

  Inductive MintSymbols : Set :=
    | SymZero
    | SymSucc
    | SymMIntNeg (n : nat)
    | SymMIntToNat (n : nat)
    | SymNatToMInt (n : nat)
  .

  Definition MintSymbols_base : Set := () + () + nat + nat + nat.

  (**
     This is the same as above, but bigger.
   *)
  Instance MintSymbols_eqdecision : EqDecision MintSymbols.
  Proof. solve_decision. Defined.

  Instance MintSymbols_countable : Countable MintSymbols.
  Proof.
    unshelve refine (inj_countable' (A := MintSymbols_base) _ _ _).
    refine (λ x, match x with
                  | SymZero        => inl(inl(inl(inl ())))
                  | SymSucc        => inl(inl(inl(inr ())))
                  | SymMIntNeg n   => inl(inl(inr n))
                  | SymMIntToNat n => inl(inr n)
                  | SymNatToMInt n => inr n
                  end
    ).
    refine (λ x, match x with
                  | inl(inl(inl(inl ()))) => SymZero
                  | inl(inl(inl(inr ()))) => SymSucc
                  | inl(inl(inr n))       => SymMIntNeg n
                  | inl(inr n)            => SymMIntToNat n
                  | inr n                 => SymNatToMInt n
                  end
    ).
    intros []; auto.
  Defined.

  Program Instance MintSignature : Signature := {|
    sorts := {| sort := MintSorts; subsort := MintSubsort |};
    variables := StringVariables;
    symbols := {|
      symbol := MintSymbols;
      arg_sorts := λ x, match x with
                        | SymZero        => []
                        | SymSucc        => [SortNat]
                        | SymMIntNeg n   => [SortMInt n]
                        | SymMIntToNat n => [SortMInt n]
                        | SymNatToMInt n => [SortNat]
                        end;
      ret_sort := λ x, match x with
                       | SymZero        => SortNat
                       | SymSucc        => SortNat
                       | SymMIntNeg n   => SortMInt n
                       | SymMIntToNat n => SortNat
                       | SymNatToMInt n => SortMInt n
                       end;
    |}
  |}.

  Definition MintModel : @Model MintSignature := mkModel_singleton
    carrier
    (λ x, match x with
           | SymZero        => c_nat 0
           | SymSucc        => λ '(c_nat n), c_nat (S n)
           | SymMIntNeg n   => λ '(c_mint n x), c_mint n (MInt.neg x)
           | SymMIntToNat n => λ '(c_mint n x), c_nat (MInt.natvalue x)
           | SymNatToMInt n => λ '(c_nat m), c_mint n (MInt.natural m)
           end
    )
    _
    (λ s s' H, match H with end).

  Definition test : @Theory MintSignature := PropSet (λ pat,
    (* --x = x *)
    (exists R n, pat = existT R (SymMIntNeg n ⋅ ⟨ SymMIntNeg n ⋅ ⟨ kore_fevar "x" ⟩ ⟩ =k{R} kore_fevar "x")) \/
    (* MInt2Nat{2} (Nat2MInt{2} (S (S O))) = S (S O) *)
    (exists R, pat = existT R (SymMIntToNat 2 ⋅ ⟨ SymNatToMInt 2 ⋅ ⟨ SymSucc ⋅ ⟨ SymSucc ⋅ ⟨ SymZero ⋅ ⟨ ⟩ ⟩ ⟩ ⟩ ⟩ =k{R} SymSucc ⋅ ⟨ SymSucc ⋅ ⟨ SymZero ⋅ ⟨ ⟩ ⟩ ⟩)) \/
    (* MInt2Nat{2} (Nat2MInt{2} (S (S (S O)))) = O *)
    (exists R, pat = existT R (SymMIntToNat 2 ⋅ ⟨ SymNatToMInt 2 ⋅ ⟨ SymSucc ⋅ ⟨ SymSucc ⋅ ⟨ SymSucc ⋅ ⟨ SymSucc ⋅ ⟨ SymZero ⋅ ⟨ ⟩ ⟩ ⟩ ⟩ ⟩ ⟩ ⟩ =k{R} SymZero ⋅ ⟨ ⟩))
  ).

  (**
     This is mostly MInt reasoning, which hopefully is unique to this
     theory, but the first one has some dependent things in it as well.
   *)
  Goal satT test MintModel.
  Proof.
    unfold satT, satM, test. intros.
    (* Generate a goal for each axiom: *)
    unfold_elem_of; destruct_or?; destruct_ex?; subst; cbn.
    * simplify_krule.
      do 2 case_match.
      f_equal.
      inversion H. inversion_sigma. pose proof Eqdep.EqdepTheory.UIP_refl _ n H2_ as ->. simpl in H2_0.
      rewrite <- H2_0.
      clear.
      unfold MInt.neg.
      apply definitions.bv_eq.
      rewrite 2! definitions.bv_opp_unsigned.
      rewrite definitions.bv_wrap_opp_idemp.
      rewrite Z.opp_involutive.
      apply definitions.bv_wrap_bv_unsigned.
    * simplify_krule.
      unfold MInt.natural, MInt.natvalue.
      rewrite definitions.Z_to_bv_small.
      cbv. split; congruence.
      cbv. reflexivity.
    * simplify_krule.
      unfold MInt.natural, MInt.natvalue.
      rewrite definitions.Z_to_bv_unsigned.
      cbv. reflexivity.
  Qed.

End NonRecursive.

Module RecursiveParameters.

  (**
     Example parametric sorts, including recursion (I don't know if we'll
     ever need recursion).
   *)
  Inductive MintSorts : Set :=
    | SortNat
    | SortMInt (n : nat)
    | SortVec (n : nat) (s : MintSorts)
  .

  (**
     This is generated by taking all the sorts' parameters and:
     - If a sort has none, use ()
     - If it is recursive, omit it
     - If there are multiple non-recursive ones, you can group them, I don't
     think it matters
     Finally separate all of them with +.
   *)
  Definition MintSorts_base : Set := () + nat + nat.

  (**
     Same as in the other file, should be constant.
   *)
  Instance MintSorts_eqdecision : EqDecision MintSorts.
  Proof. solve_decision. Defined.

  (**
     This is fairly standard based on the structure of the sort type,
     non-recursive sorts are mapped to leaves, recursive ones to nodes,
     with the non-recursive arguments mapped to leaves, and the recursive
     ones to the fixpoint function. In the other direction, in leaves, the
     parameters corresponding to non-recursive constructors are mapped to
     them, the rest are mapped to None, while in nodes, we need to match
     all recursive constructors to go with the above description, with the
     recursive parameters decoded by the fixpoint function, and the whole
     thing fmapped/bound (bind-ed?) together. The complexity can skyrocket
     with lots of recursive parameters.
   *)
  Instance MintSorts_countable : Countable MintSorts.
  Proof.
    unshelve refine (inj_countable (A := gen_tree MintSorts_base) _ _ _).
    refine (fix F x := match x with
                       | SortNat     => GenLeaf (inl (inl ()))
                       | SortMInt n  => GenLeaf (inl (inr n))
                       | SortVec n s => GenNode 0 [GenLeaf (inr n); F s]
                       end
    ).
    refine (fix F x := match x with
                       | GenLeaf x    => match x with
                                         | inl (inl ()) => Some SortNat
                                         | inl (inr n)  => Some (SortMInt n)
                                         | _ => None
                                         end
                       | GenNode x xs => match x, xs with
                                         | 0, [GenLeaf (inr n); s] => SortVec n <$> F s
                                         | _, _                    => None
                                         end
                       end
    ).
    induction x; auto. rewrite IHx; auto.
  Defined.

  (**
     The carrier can't be defined the usual way.
   *)

End RecursiveParameters.
