
From SMTCoq Require Import SMTCoq.

From MatchingLogic Require Export stdpp_ext.
From Kore Require Export Semantics.
Import Signature.StringVariables.
Import Kore.Syntax.Notations.
Require Import DVParsers.

From Coq Require Import ZArith.

Open Scope kore_scope.
Open Scope hlist_scope.
Open Scope string_scope.

Ltac autorewrite_set :=
  repeat (
    rewrite intersection_top_l_L +
    rewrite intersection_top_r_L +
    rewrite union_empty_l_L +
    rewrite union_empty_r_L +
    rewrite propset_difference_neg +
    rewrite propset_union_simpl +
    rewrite propset_intersection_simpl +
    rewrite singleton_subseteq_l
  ).

Ltac basic_simplify_krule :=
  simpl;
  repeat eval_simplifier;
  repeat rewrite_app_ext;
  autorewrite_set.
Ltac simplify_krule :=
  basic_simplify_krule;
  apply propset_top_elem_of_2;
  intro;
  apply elem_of_PropSet;
  repeat rewrite elem_of_PropSet;
  repeat rewrite singleton_subseteq;
  repeat rewrite singleton_eq.

Module DemoSyntaxSemantics.

  (* We have two sorts: natural numbers and bools *)
  Inductive DemoSorts :=
  | SortNat
  | SortBool.

  (* We prove decidable equality and finiteness of the type above. *)
  Instance DemoSorts_eq_dec : EqDecision DemoSorts.
  Proof. solve_decision. Defined.
  Program Instance DemoSorts_finite : finite.Finite DemoSorts := {
    enum := [SortNat; SortBool];
  }.
  Next Obligation. compute_done. Defined.
  Final Obligation. destruct x; set_solver. Defined.


  (* Suppose that we have the following 3 symbols: *)
  Inductive DemoSyms :=
  | SymZero
  | SymSucc
  | SymAdd
  | SymTrue
  | SymFalse.

  (* We prove decidable equality and finiteness of the type above. *)
  Instance DemoSyms_eq_dec : EqDecision DemoSyms.
  Proof. solve_decision. Defined.
  Program Instance DemoSyms_finite : finite.Finite DemoSyms := {
    enum := [SymZero;SymSucc;SymAdd;SymTrue;SymFalse];
  }.
  Next Obligation. compute_done. Defined.
  Final Obligation. destruct x; set_solver. Defined.

  Inductive Demo_subsort : CRelationClasses.crelation DemoSorts := .

  (* In the signature, we need to define the sorts, the variable types,
     and the typing/sorting rules for symbols: *)
  Program Instance DemoSignature : Signature := {|
    sorts := {|
      sort := DemoSorts;
      subsort := Demo_subsort;
    |};
    variables := StringVariables;
    symbols := {|
      symbol := DemoSyms;
      arg_sorts :=
        fun σ => match σ with
                 | SymZero => []
                 | SymSucc => [SortNat]
                 | SymAdd => [SortNat; SortNat]
                 | SymTrue => []
                 | SymFalse => []
                 end;
      ret_sort := fun σ => match σ with
                           | SymZero | SymSucc | SymAdd => SortNat
                           | SymTrue | SymFalse => SortBool
                           end;
    |};
  |}.

  Definition NatPattern := Pattern [] [] SortNat.
  Definition BoolPattern := Pattern [] [] SortBool.

 (*  Definition test0 : NatPattern := SymAdd ⋅ ⟨SymFalse ⋅ ⟨⟩; SymZero ⋅ ⟨⟩⟩. *)

  Definition TruePat : BoolPattern := SymTrue ⋅ ⟨⟩.
  Definition FalsePat : BoolPattern := SymFalse ⋅ ⟨⟩.

  Definition ZeroPat : NatPattern := SymZero ⋅ ⟨⟩.
  Definition OnePat : NatPattern := SymSucc ⋅ ⟨ ZeroPat ⟩.
  Definition TwoPat : NatPattern := SymSucc ⋅ ⟨ OnePat ⟩.

  Fail Definition wrong :=
    ZeroPat and TruePat.
  Definition test : Pattern [] [] _ := SymZero ⋅ ⟨⟩.
  Check test.

  Fail Definition wrong : NatPattern := SymSucc ⋅ ⟨ TruePat ⟩.
  Fail Definition wrong : NatPattern := SymZero ⋅ ⟨ OnePat ⟩.

  Definition carrier s :=
    match s with
    | SortNat => nat
    | SortBool => bool
    end.

  Program Definition DemoModel : @Model DemoSignature :=
    mkModel_singleton
      carrier
      (DemoSyms_rect _
        0
        S
        Nat.add
        true
        false)
      ltac:(intros []; auto with typeclass_instances)
      _ (fun _ => None_parser).
  Final Obligation.
    intros s1 s2 H x; inversion H; subst.
  Defined.

  Goal
    forall (ρ : Valuation),
      @eval _ DemoModel _ _ _ ρ ZeroPat = {[0]}.
  Proof.
    intros. unfold ZeroPat.
    basic_simplify_krule.
    reflexivity.
  Qed.

  Goal
    forall (ρ : Valuation),
      @eval _ DemoModel _ _ _ ρ (SymAdd ⋅ ⟨OnePat; TwoPat⟩) = {[3]}.
  Proof.
    intros. unfold TwoPat, OnePat, ZeroPat.
    basic_simplify_krule.
    reflexivity.
  Qed.

  Goal
    forall (ρ : Valuation),
      @eval _ DemoModel _ _ _ ρ
        (SymAdd ⋅ ⟨OnePat; TwoPat⟩ =k{SortNat} SymSucc ⋅ ⟨TwoPat⟩)
        = ⊤.
  Proof.
    intros. unfold TwoPat, OnePat, ZeroPat.
    basic_simplify_krule.
    set_solver.
  Qed.

End DemoSyntaxSemantics.



(**
  The symbols and axioms (theories) enumerated in this file were taken
  from definition.kore (generated by kompile) of the IMP case study.
*)
Module ImpSyntax.

  (* We have two sorts: bool, int *)
  Inductive Ksorts :=
  | Kbool
  | Kint.

  Instance Ksorts_eq_dec : EqDecision Ksorts.
  Proof. solve_decision. Defined.


  Program Instance Ksorts_finite : finite.Finite Ksorts := {
    enum := [Kbool; Kint];
  }.
  Next Obligation. compute_done. Defined.
  Final Obligation. destruct x; set_solver. Defined.

  (* Symbols about bools and ints: *)
  Inductive Ksyms :=
  (* Kbool *)
  | Ktrue
  | Kfalse
  | KnotBool
  | KandBool
  | KandThenBool
  | KxorBool
  | KorBool
  | KorElseBool
  | KimpliesBool
  | KeqBool
  | KneqBool
  (* Kint *)
  | KintVal (z : Z)
  | Kstderr_K_IO_Int
    (* Lbl'Hash'stderr'Unds'K-IO'Unds'Int{}() : SortInt{} *)
  | Kstdin_K_IO_Int
    (* Lbl'Hash'stdin'Unds'K-IO'Unds'Int{}() : SortInt{} *)
  | Kstdout_K_IO_Int
    (* Lbl'Hash'stdout'Unds'K-IO'Unds'Int{}() : SortInt{} *)
  | KtimeLParRPar_K_IO_Int
    (* Lbl'Hash'time'LParRParUnds'K-IO'Unds'Int{}() : SortInt{} *)
  | KtmodInt
    (* Lbl'UndsPerc'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KandInt
    (* Lbl'UndsAnd-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KmultInt
    (* Lbl'UndsStar'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KplusInt
    (* Lbl'UndsPlus'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KsubInt
    (* Lbl'Unds'-Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KtdivInt
    (* Lbl'UndsSlsh'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KltltInt
    (* Lbl'Unds-LT--LT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KleInt
    (* Lbl'Unds-LT-Eqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} *)
  | KltInt
    (* Lbl'Unds-LT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} *)
  | KneqInt
    (* Lbl'UndsEqlsSlshEqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} *)
  | KeqInt
    (* Lbl'UndsEqlsEqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} *)
  | KgeInt
    (* Lbl'Unds-GT-Eqls'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} *)
  | KgtgtInt
    (* Lbl'Unds-GT--GT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KgtInt
    (* Lbl'Unds-GT-'Int'Unds'{}(SortInt{}, SortInt{}) : SortBool{} *)
  | KpowmodInt
    (* Lbl'UndsXor-Perc'Int'UndsUnds'{}(SortInt{}, SortInt{}, SortInt{}) : SortInt{} *)
  | KpowInt
    (* Lbl'UndsXor-'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KdivInt
    (* Lbl'Unds'divInt'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KdividesInt
    (* Lbl'Unds'dividesInt'UndsUnds'INT-COMMON'Unds'Bool'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortBool{} *)
  | KmodInt
    (* Lbl'Unds'modInt'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KxorInt
    (* Lbl'Unds'xorInt'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KorInt
    (* Lbl'UndsPipe'Int'Unds'{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KabsInt
    (* LblabsInt'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} *)
  | KbitRangeInt
    (* LblbitRangeInt'LParUndsCommUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}, SortInt{}) : SortInt{} *)
  | KfreshInt
    (* LblfreshInt'LParUndsRParUnds'INT'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} *)
  | Klog2Int 
    (* Lbllog2Int'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} *)
  | KmaxInt
    (* LblmaxInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KminInt
    (* LblminInt'LParUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}) : SortInt{} *)
  | KrandInt
    (* LblrandInt'LParUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int{}(SortInt{}) : SortInt{} *)
  | KsignExtendBitRangeInt (* LblsignExtendBitRangeInt'LParUndsCommUndsCommUndsRParUnds'INT-COMMON'Unds'Int'Unds'Int'Unds'Int'Unds'Int{}(SortInt{}, SortInt{}, SortInt{}) : SortInt{} *)
  | KnotInt
    (* Lbl'Tild'Int'Unds'{}(SortInt{}) : SortInt{} *).

  Instance Ksyms_eq_dec : EqDecision Ksyms.
  Proof. solve_decision. Defined.

  (* This code is required to prove that there are Countably many symbols. *)
  Local Definition Ksyms_to_gen_tree (σ : Ksyms) : gen_tree (nat + Z) :=
  match σ with
   | Ktrue => GenLeaf (inl 0)
   | Kfalse => GenLeaf (inl 1)
   | KnotBool => GenLeaf (inl 2)
   | KandBool => GenLeaf (inl 3)
   | KandThenBool => GenLeaf (inl 4)
   | KxorBool => GenLeaf (inl 5)
   | KorBool => GenLeaf (inl 6)
   | KorElseBool => GenLeaf (inl 7)
   | KimpliesBool => GenLeaf (inl 8)
   | KeqBool => GenLeaf (inl 9)
   | KneqBool => GenLeaf (inl 10)
   | KintVal z => GenLeaf (inr z)
   | Kstderr_K_IO_Int => GenLeaf (inl 11)
   | Kstdin_K_IO_Int => GenLeaf (inl 12)
   | Kstdout_K_IO_Int => GenLeaf (inl 13)
   | KtimeLParRPar_K_IO_Int => GenLeaf (inl 14)
   | KtmodInt => GenLeaf (inl 15)
   | KandInt => GenLeaf (inl 16)
   | KmultInt => GenLeaf (inl 17)
   | KplusInt => GenLeaf (inl 18)
   | KsubInt => GenLeaf (inl 19)
   | KtdivInt => GenLeaf (inl 20)
   | KltltInt => GenLeaf (inl 21)
   | KleInt => GenLeaf (inl 22)
   | KltInt => GenLeaf (inl 23)
   | KneqInt => GenLeaf (inl 24)
   | KeqInt => GenLeaf (inl 25)
   | KgeInt => GenLeaf (inl 26)
   | KgtgtInt => GenLeaf (inl 27)
   | KgtInt => GenLeaf (inl 28)
   | KpowmodInt => GenLeaf (inl 29)
   | KpowInt => GenLeaf (inl 30)
   | KdivInt => GenLeaf (inl 31)
   | KdividesInt => GenLeaf (inl 32)
   | KmodInt => GenLeaf (inl 33)
   | KxorInt => GenLeaf (inl 34)
   | KorInt => GenLeaf (inl 35)
   | KabsInt => GenLeaf (inl 36)
   | KbitRangeInt => GenLeaf (inl 37)
   | KfreshInt => GenLeaf (inl 38)
   | Klog2Int => GenLeaf (inl 39)
   | KmaxInt => GenLeaf (inl 40)
   | KminInt => GenLeaf (inl 41)
   | KrandInt => GenLeaf (inl 42)
   | KsignExtendBitRangeInt => GenLeaf (inl 43)
   | KnotInt => GenLeaf (inl 44)
  end.

  Local Definition gen_tree_to_Ksyms (t : gen_tree (nat + Z)) : option Ksyms :=
  match t with
  | GenLeaf (inl x) => match x with
                       | 0 => Some Ktrue
                       | 1 => Some Kfalse
                       | 2 => Some KnotBool
                       | 3 => Some KandBool
                       | 4 => Some KandThenBool
                       | 5 => Some KxorBool
                       | 6 => Some KorBool
                       | 7 => Some KorElseBool
                       | 8 => Some KimpliesBool
                       | 9 => Some KeqBool
                       | 10 => Some KneqBool
                       | 11 => Some Kstderr_K_IO_Int
                       | 12 => Some Kstdin_K_IO_Int
                       | 13 => Some Kstdout_K_IO_Int
                       | 14 => Some KtimeLParRPar_K_IO_Int
                       | 15 => Some KtmodInt
                       | 16 => Some KandInt
                       | 17 => Some KmultInt
                       | 18 => Some KplusInt
                       | 19 => Some KsubInt
                       | 20 => Some KtdivInt
                       | 21 => Some KltltInt
                       | 22 => Some KleInt
                       | 23 => Some KltInt
                       | 24 => Some KneqInt
                       | 25 => Some KeqInt
                       | 26 => Some KgeInt
                       | 27 => Some KgtgtInt
                       | 28 => Some KgtInt
                       | 29 => Some KpowmodInt
                       | 30 => Some KpowInt
                       | 31 => Some KdivInt
                       | 32 => Some KdividesInt
                       | 33 => Some KmodInt
                       | 34 => Some KxorInt
                       | 35 => Some KorInt
                       | 36 => Some KabsInt
                       | 37 => Some KbitRangeInt
                       | 38 => Some KfreshInt
                       | 39 => Some Klog2Int
                       | 40 => Some KmaxInt
                       | 41 => Some KminInt
                       | 42 => Some KrandInt
                       | 43 => Some KsignExtendBitRangeInt
                       | 44 => Some KnotInt
                       | _ => None
                       end
  | GenLeaf (inr x) => Some (KintVal x)
  | _ => None
  end.


  Instance Ksyms_countable : Countable Ksyms.
  Proof.
    apply inj_countable with (f := Ksyms_to_gen_tree) (g := gen_tree_to_Ksyms).
    intros x. destruct x; try by simpl.
  Defined.

  Inductive K_subsort : CRelationClasses.crelation Ksorts := .

  (* Next, we define the signature of the theory containing bool and int. *)
  Program Instance ImpSignature : Signature := {|
    sorts := {|
      sort := Ksorts;
      subsort := K_subsort;
    |};
    variables := StringVariables;
    symbols := {|
      symbol := Ksyms;
      (* This function defines the sorts for the symbol arguments *)
      arg_sorts σ :=
        match σ with
        | Ktrue => []
        | Kfalse => []
        | KnotBool => [Kbool]
        | KandBool => [Kbool; Kbool]
        | KandThenBool => [Kbool; Kbool]
        | KxorBool => [Kbool; Kbool]
        | KorBool => [Kbool; Kbool]
        | KorElseBool => [Kbool; Kbool]
        | KimpliesBool => [Kbool; Kbool]
        | KeqBool => [Kbool; Kbool]
        | KneqBool => [Kbool; Kbool]
        | KintVal z => []
        | Kstderr_K_IO_Int => []
        | Kstdin_K_IO_Int => []
        | Kstdout_K_IO_Int => []
        | KtimeLParRPar_K_IO_Int => []
        | KtmodInt => [Kint; Kint]
        | KandInt => [Kint; Kint]
        | KmultInt => [Kint; Kint]
        | KplusInt => [Kint; Kint]
        | KsubInt => [Kint; Kint]
        | KtdivInt => [Kint; Kint]
        | KltltInt => [Kint; Kint]
        | KleInt => [Kint; Kint]
        | KltInt => [Kint; Kint]
        | KneqInt => [Kint; Kint]
        | KeqInt => [Kint; Kint]
        | KgeInt => [Kint; Kint]
        | KgtgtInt => [Kint; Kint]
        | KgtInt => [Kint; Kint]
        | KpowmodInt => [Kint; Kint; Kint]
        | KpowInt => [Kint; Kint]
        | KdivInt => [Kint; Kint]
        | KdividesInt => [Kint; Kint]
        | KmodInt => [Kint; Kint]
        | KxorInt => [Kint; Kint]
        | KorInt => [Kint; Kint]
        | KabsInt => [Kint]
        | KbitRangeInt => [Kint; Kint; Kint]
        | KfreshInt => [Kint]
        | Klog2Int => [Kint]
        | KmaxInt => [Kint; Kint]
        | KminInt => [Kint; Kint]
        | KrandInt => [Kint; Kint; Kint]
        | KsignExtendBitRangeInt => [Kint; Kint; Kint]
        | KnotInt => [Kint]
        end;
      (* This function defines the return sort of symbols *)
      ret_sort σ :=
        match σ with
         | Ktrue => Kbool
         | Kfalse => Kbool
         | KnotBool => Kbool
         | KandBool => Kbool
         | KandThenBool => Kbool
         | KxorBool => Kbool
         | KorBool => Kbool
         | KorElseBool => Kbool
         | KimpliesBool => Kbool
         | KeqBool => Kbool
         | KneqBool => Kbool
         | KintVal z => Kint
         | Kstderr_K_IO_Int => Kint
         | Kstdin_K_IO_Int => Kint
         | Kstdout_K_IO_Int => Kint
         | KtimeLParRPar_K_IO_Int => Kint
         | KtmodInt => Kint
         | KandInt => Kint
         | KmultInt => Kint
         | KplusInt => Kint
         | KsubInt => Kint
         | KtdivInt => Kint
         | KltltInt => Kint
         | KleInt => Kbool
         | KltInt => Kbool
         | KneqInt => Kbool
         | KeqInt => Kbool
         | KgeInt => Kbool
         | KgtgtInt => Kint
         | KgtInt => Kbool
         | KpowmodInt => Kint
         | KpowInt => Kint
         | KdivInt => Kint
         | KdividesInt => Kbool
         | KmodInt => Kint
         | KxorInt => Kint
         | KorInt => Kint
         | KabsInt => Kint
         | KbitRangeInt => Kint
         | KfreshInt => Kint
         | Klog2Int => Kint
         | KmaxInt => Kint
         | KminInt => Kint
         | KrandInt => Kint
         | KsignExtendBitRangeInt => Kint
         | KnotInt => Kint
        end;
    |};
  |}.
  (* This file contains the theory of bool and int.  
     The theories are splitted into two part: behavioural axioms and
     functional axioms.

     Behavioural axioms specify how a symbols should be evaluated (these
     are equality-based rules in Kore including simplification rules).

     Functional axioms are instances of the FUNCTION axiom for particular
     symbols.
   *)
  Definition Kbool_theory_behavioural : @Theory ImpSignature :=
    PropSet (fun pat =>
      (** negation: *)
      (* not false = true *)
      (exists R, pat =
        existT R ((Top{R} and kore_fevar "X" ⊆k{R} Kfalse ⋅ ⟨⟩)
          --->ₖ
         (KnotBool ⋅ ⟨kore_fevar "X"⟩ =k{R} (Ktrue ⋅ ⟨⟩ and Top{Kbool})))
      ) \/
      (* not true = false *)
      (exists R, pat =
        existT R ((Top{R} and kore_fevar "X" ⊆k{R} Ktrue ⋅ ⟨⟩)
          --->ₖ
        (KnotBool ⋅ ⟨kore_fevar "X"⟩ =k{R} (Kfalse ⋅ ⟨⟩ and Top{Kbool})))
      ) \/
      (** conjunction *)
      (* rule `_andBool_`(#token("false","Bool") #as _Gen1,_Gen0)=>_Gen1 *)
      (exists R, pat =
        existT R ((Top{R} and
                   kore_fevar "X0" ⊆k{R} (Kfalse ⋅ ⟨⟩ and kore_fevar "Gen1") and
                   @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "Gen0" and
                   Top{R})
          --->ₖ
        (KandBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "Gen1" and Top{Kbool})))
      ) \/
      ((* rule `_andBool_`(B,#token("true","Bool"))=>B *)
        exists R, pat =
          existT R (
            Top{R} --->ₖ
            KandBool ⋅ ⟨kore_fevar "B"; Ktrue ⋅ ⟨⟩ ⟩ =k{R} (kore_fevar "B" and Top{Kbool})
          )
      ) \/
      ( (* rule `_andBool_`(_Gen0,#token("false","Bool"))=>#token("false","Bool") *)
        exists R, pat =
          existT R (
            Top{R} --->ₖ
            KandBool ⋅ ⟨kore_fevar "Gen0"; Kfalse ⋅ ⟨⟩ ⟩ =k{R} (Kfalse ⋅ ⟨ ⟩ and Top{Kbool})
        )
      ) \/
      ( (* rule `_andBool_`(#token("true","Bool"),B)=>B *)
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Ktrue ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "B" and Top{R}
            --->ₖ
            (KandBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "B" and Top{Kbool}))
          )
      ) \/
      (** andthen *)
      (*rule `_andThenBool_`(#token("false","Bool") #as _Gen1,_Gen0)=>_Gen1*)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} (Kfalse ⋅ ⟨⟩ and kore_fevar "Gen1") and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "Gen0" and Top{R}
            --->ₖ
            (KandThenBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "Gen1" and Top{Kbool}))
          )
      ) \/
      (*rule `_andThenBool_`(K,#token("true","Bool"))=>K*)
      (
        exists R, pat =
          existT R (
            Top{R} --->ₖ
            KandThenBool ⋅ ⟨kore_fevar "K"; Ktrue ⋅ ⟨⟩ ⟩ =k{R} (kore_fevar "K" and Top{Kbool})
          )
      ) \/
      (*rule `_andThenBool_`(_Gen0,#token("false","Bool"))=>#token("false","Bool")*)
      (
        exists R, pat =
          existT R (
            Top{R} --->ₖ
            KandThenBool ⋅ ⟨kore_fevar "Gen0"; Kfalse ⋅ ⟨⟩ ⟩ =k{R} (Kfalse ⋅ ⟨ ⟩ and Top{Kbool})
        )
      ) \/
      (*rule `_andThenBool_`(#token("true","Bool"),K)=>K*)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Ktrue ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "K" and Top{R}
            --->ₖ
            (KandThenBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "K" and Top{Kbool}))
          )
      ) \/
      (** xorBool *)
      (* rule `_xorBool_`(B,B)=>#token("false","Bool") *)
      (
        exists R, pat =
          existT R (
            Top{R} and @kore_fevar _ _ _ Kbool "X0" ⊆k{R} kore_fevar "B" and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "B" and Top{R}
            --->ₖ
            (KxorBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (Kfalse ⋅ ⟨⟩ and Top{Kbool}))
          )
      ) \/
      (* rule `_xorBool_`(B,#token("false","Bool"))=>B *)
      (
        exists R, pat =
          existT R (
            Top{R}
            --->ₖ
            (KxorBool ⋅ ⟨kore_fevar "B"; Kfalse ⋅ ⟨⟩⟩ =k{R} (kore_fevar "B" and Top{Kbool}))
          )
      ) \/
      (* rule `_xorBool_`(#token("false","Bool"),B)=>B *)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Kfalse ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "B" and Top{R}
            --->ₖ
            (KxorBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "B" and Top{Kbool}))
          )
      ) \/
      (** orBool *)
      (* rule `_orBool_`(B,#token("false","Bool"))=>B *)
      (
        exists R, pat =
          existT R (
            Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "B"; Kfalse ⋅ ⟨⟩⟩ =k{R} (kore_fevar "B" and Top{Kbool}))
          )
      ) \/
      (* rule `_orBool_`(_Gen0,#token("true","Bool"))=>#token("true","Bool") *)
      (
        exists R, pat =
          existT R (
            Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "Gen0"; Ktrue ⋅ ⟨⟩⟩ =k{R} (Ktrue ⋅ ⟨⟩ and Top{Kbool}))
          )
      ) \/
      (* rule `_orBool_`(#token("false","Bool"),B)=>B *)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Kfalse ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "B" and Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "B" and Top{Kbool}))
          )
      ) \/
      (* rule `_orBool_`(#token("true","Bool"),_Gen0)=>#token("true","Bool") *)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Ktrue ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "Gen0" and Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (Ktrue ⋅ ⟨⟩ and Top{Kbool}))
          )
      ) \/
      (** orElseBool *)
      (* rule `_orElseBool_`(K,#token("false","Bool"))=>K *)
      (
        exists R, pat =
          existT R (
            Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "K"; Kfalse ⋅ ⟨⟩⟩ =k{R} (kore_fevar "K" and Top{Kbool}))
          )
      ) \/
      (* rule `_orElseBool_`(_Gen0,#token("true","Bool"))=>#token("true","Bool") *)
      (
        exists R, pat =
          existT R (
            Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "Gen0"; Ktrue ⋅ ⟨⟩⟩ =k{R} (Ktrue ⋅ ⟨⟩ and Top{Kbool}))
          )
      ) \/
      (* rule `_orElseBool_`(#token("false","Bool"),K)=>K *)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Kfalse ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "K" and Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "K" and Top{Kbool}))
          )
      ) \/
      (* rule `_orElseBool_`(#token("true","Bool"),_Gen0)=>#token("true","Bool") *)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Ktrue ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "Gen0" and Top{R}
            --->ₖ
            (KorBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (Ktrue ⋅ ⟨⟩ and Top{Kbool}))
          )
      ) \/
      (** impliesBool *)
      (* `_impliesBool_`(B,#token("false","Bool"))=>`notBool_`(B) *)
      (
        exists R, pat =
          existT R (
            Top{R}
            --->ₖ
            (KimpliesBool ⋅ ⟨kore_fevar "B"; Kfalse ⋅ ⟨⟩⟩ =k{R} (KnotBool ⋅ ⟨kore_fevar "B"⟩ and Top{Kbool}))
          )
      ) \/
      (* rule `_impliesBool_`(_Gen0,#token("true","Bool"))=>#token("true","Bool") *)
      (
        exists R, pat =
          existT R (
            Top{R}
            --->ₖ
            (KimpliesBool ⋅ ⟨kore_fevar "Gen0"; Ktrue ⋅ ⟨⟩⟩ =k{R} (Ktrue ⋅ ⟨⟩ and Top{Kbool}))
          )
      ) \/
      (* rule `_impliesBool_`(#token("false","Bool"),_Gen0)=>#token("true","Bool") *)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Kfalse ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "Gen0" and Top{R}
            --->ₖ
            (KimpliesBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (Ktrue ⋅ ⟨⟩ and Top{Kbool}))
          )
      ) \/
      (* rule `_impliesBool_`(#token("true","Bool"),B)=>B *)
      (
        exists R, pat =
          existT R (
            Top{R} and kore_fevar "X0" ⊆k{R} Ktrue ⋅ ⟨⟩ and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "B" and Top{R}
            --->ₖ
            (KimpliesBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "B" and Top{Kbool}))
          )
      ) \/
      ( (* rule `_=/=Bool_`(B1,B2)=>`notBool_`(`_==Bool_`(B1,B2)) *)
        exists R, pat =
          existT R (
            Top{R} and @kore_fevar _ _ _ Kbool "X0" ⊆k{R} kore_fevar "B1" and
            @kore_fevar _ _ _ Kbool "X1" ⊆k{R} kore_fevar "B2" and Top{R}
            --->ₖ
            (KneqBool ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (KnotBool ⋅ ⟨ KeqBool ⋅ ⟨kore_fevar "B1"; kore_fevar "B2"⟩⟩ and Top{Kbool}))
          )
      )
    ).

    (** functional axioms *)
    Definition Kbool_theory_functional : @Theory ImpSignature :=
      PropSet (fun pat =>
        exists R, pat =
          existT R (
            kore_exists Kbool (KandBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
        )) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KandThenBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
          ))
        ) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KimpliesBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
          ))
        ) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KorBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
          ))
        ) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KorElseBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
          ))
        ) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KxorBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
          ))
        ) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KneqBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
          ))
        ) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KeqBool ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar (In_nil)
          ))
        ) \/
        (
        exists R, pat =
          existT R (
            kore_exists Kbool (KnotBool ⋅ ⟨kore_fevar "K0"⟩ =k{R} kore_bevar (In_nil)
          ))
        )
    ).

   (** Theory of int. *)
   Definition Kint_theory_behavioural : @Theory ImpSignature :=
    PropSet (fun pat =>
      (exists R, pat =
        existT R (Top{R} and Top{R} --->ₖ Kstderr_K_IO_Int ⋅⟨⟩ =k{R} KintVal 2 ⋅ ⟨⟩)
      ) \/
      (exists R, pat =
        existT R (Top{R} and Top{R} --->ₖ Kstdin_K_IO_Int ⋅⟨⟩ =k{R} KintVal 0 ⋅ ⟨⟩)
      ) \/
      (exists R, pat =
        existT R (Top{R} and Top{R} --->ₖ Kstdout_K_IO_Int ⋅⟨⟩ =k{R} KintVal 1 ⋅ ⟨⟩)
      ) \/
      (exists R, pat =
        existT R (
          Top{R} and @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I1" and
          @kore_fevar _ _ _ Kint "X1" ⊆k{R} kore_fevar "I2" and Top{R}
          --->ₖ
          (KneqInt ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (KnotBool ⋅ ⟨KeqInt ⋅ ⟨kore_fevar "I1" ; kore_fevar "I2"⟩ ⟩ and Top{Kbool}))
        )
      ) \/
      (exists R, pat =
        existT R (
          KneqInt ⋅ ⟨kore_fevar "I2"; KintVal 0 ⋅ ⟨⟩ ⟩ =k{R} Ktrue ⋅ ⟨⟩ and
          @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I1" and
          @kore_fevar _ _ _ Kint "X1" ⊆k{R} kore_fevar "I2" and Top{R} --->ₖ
          KdivInt ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (KtdivInt ⋅ ⟨KsubInt ⋅ ⟨kore_fevar "I1" ; KmodInt ⋅ ⟨kore_fevar "I1"; kore_fevar "I2"⟩ ⟩; kore_fevar "I2"⟩ and Top{Kint})
        )
      ) \/
      (exists R, pat =
        existT R (
          Top{R} and
          @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I1" and
          @kore_fevar _ _ _ Kint "X1" ⊆k{R} kore_fevar "I2" and Top{R} --->ₖ
          KdividesInt ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (KeqInt ⋅ ⟨KtmodInt ⋅ ⟨kore_fevar "I2" ; kore_fevar "I1" ⟩; KintVal 0 ⋅ ⟨⟩⟩ and Top{Kbool})
        )
      ) \/
      (exists R, pat =
        existT R (
          KneqInt ⋅ ⟨kore_fevar "I2"; KintVal 0 ⋅ ⟨⟩⟩ =k{R} Ktrue ⋅ ⟨⟩ --->ₖ
          KmodInt ⋅ ⟨kore_fevar "I1"; kore_fevar "I2"⟩ =k{R}
            (KtmodInt ⋅ ⟨KplusInt ⋅
                         ⟨KtmodInt ⋅ ⟨kore_fevar "I1";
                                      KabsInt ⋅⟨kore_fevar "I2"⟩⟩;
                          KabsInt ⋅ ⟨kore_fevar "I2"⟩ ⟩;
                        KabsInt ⋅ ⟨kore_fevar "I2"⟩ ⟩ and Top{Kint})
        )
      ) \/
      (exists R, pat =
        existT R (
          @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I" and
          @kore_fevar _ _ _ Kint "X1" ⊆k{R} kore_fevar "IDX" and
          @kore_fevar _ _ _ Kint "X2" ⊆k{R} kore_fevar "LEN" and Top{R} --->ₖ
          KbitRangeInt ⋅⟨ kore_fevar "X0"; kore_fevar "X1"; kore_fevar "X2"⟩ =k{R}
            (KmodInt ⋅ ⟨KgtgtInt ⋅ ⟨kore_fevar "I"; kore_fevar "IDX"⟩;
                        KltltInt ⋅ ⟨KintVal 1 ⋅ ⟨⟩; kore_fevar "LEN"⟩⟩ and Top{Kint})
        )
      ) \/
      (exists R, pat =
        existT R (
          Top{R} and @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I" and Top{R} --->ₖ
          KfreshInt ⋅ ⟨ kore_fevar "X0" ⟩ =k{R} (kore_fevar "I" and Top{Kint})
        )
      ) \/
      (exists R, pat =
        existT R (
          KltInt ⋅ ⟨kore_fevar "I1"; kore_fevar "I2"⟩ =k{R} Ktrue ⋅ ⟨⟩ and
          @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I1" and
          @kore_fevar _ _ _ Kint "X1" ⊆k{R} kore_fevar "I2" and Top{R} --->ₖ
          KminInt⋅⟨ kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "I1" and Top{Kint})
        )
      ) \/
      (exists R, pat =
        existT R (
          KgeInt ⋅ ⟨kore_fevar "I1"; kore_fevar "I2"⟩ =k{R} Ktrue ⋅ ⟨⟩ and
          @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I1" and
          @kore_fevar _ _ _ Kint "X1" ⊆k{R} kore_fevar "I2" and Top{R} --->ₖ
          KminInt⋅⟨ kore_fevar "X0"; kore_fevar "X1"⟩ =k{R} (kore_fevar "I2" and Top{Kint})
        )
      ) \/
      (exists R, pat =
        existT R (
          Top{R} and
          @kore_fevar _ _ _ Kint "X0" ⊆k{R} kore_fevar "I" and
          @kore_fevar _ _ _ Kint "X1" ⊆k{R} kore_fevar "IDX" and
          @kore_fevar _ _ _ Kint "X2" ⊆k{R} kore_fevar "LEN" and Top{R} --->ₖ
          KsignExtendBitRangeInt ⋅ ⟨kore_fevar "X0"; kore_fevar "X1"; kore_fevar "X2"⟩ =k{R}
            (KsubInt ⋅ ⟨KmodInt ⋅ ⟨KplusInt ⋅ ⟨KbitRangeInt ⋅ ⟨kore_fevar "I";kore_fevar "IDX"; kore_fevar "LEN"⟩; KltltInt ⋅ ⟨KintVal 1 ⋅⟨⟩; KsubInt ⋅ ⟨kore_fevar "LEN" ; KintVal 1 ⋅⟨⟩⟩⟩⟩;
                                   KltltInt ⋅ ⟨KintVal 1 ⋅⟨⟩; KsubInt ⋅ ⟨kore_fevar "LEN" ; KintVal 1 ⋅⟨⟩⟩⟩⟩;
                        KltltInt ⋅ ⟨KintVal 1 ⋅⟨⟩; KsubInt ⋅ ⟨kore_fevar "LEN" ; KintVal 1 ⋅⟨⟩⟩⟩⟩
              and Top{Kint})
        )
      )
    ).

   Definition Kint_theory_functional : @Theory ImpSignature :=
    PropSet (fun pat =>
      (
        exists R, pat = existT R (
          kore_exists Kint (Kstderr_K_IO_Int ⋅ ⟨⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (Kstdin_K_IO_Int ⋅ ⟨⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (Kstdout_K_IO_Int ⋅ ⟨⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KandInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KmultInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KplusInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KsubInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kbool (KleInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kbool (KltInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kbool (KneqInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kbool (KeqInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kbool (KgeInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kbool (KgtInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KxorInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KorInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KabsInt ⋅ ⟨kore_fevar "K0"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KfreshInt ⋅ ⟨kore_fevar "K0"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KmaxInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KminInt ⋅ ⟨kore_fevar "K0"; kore_fevar "K1"⟩ =k{R} kore_bevar In_nil)
        )
      ) \/
      (
        exists R, pat = existT R (
          kore_exists Kint (KnotInt ⋅ ⟨kore_fevar "K0"⟩ =k{R} kore_bevar In_nil)
        )
      )
    ).
End ImpSyntax.

Module ImpSemantics.

  (* We define a model for (the union of) the previous theories. First, 
     we need some auxiliary definitions to model some (non-equality, bitrange)
     symbols. *)
  Import ImpSyntax.

  Definition neqbB (b1 b2 : bool) : bool :=
    negb (Bool.eqb b1 b2).
  Arguments neqbB /.
  Definition neqbZ (b1 b2 : Z) : bool :=
    negb (Z.eqb b1 b2).
  Arguments neqbZ /.

  Open Scope Z_scope.


  (* NOTE: Beware the difference between mod and rem
     (and quot and div) *)
  (*
    Following defs are taken from: https://github.com/runtimeverification/k/blob/eff6bea3f2118bb02c185888d1b369c5c2a59ec3/k-frontend/src/main/java/org/kframework/compile/ConstantFolding.java#L552
  *)
  (* TODO: Java throws an exception if idx or length is not unsigned *)
  Definition bitRange (i idx len : Z) : Z :=
    Z.shiftr
      (Z.land i (Z.shiftl (Z.shiftl 1 len - 1) idx))
      idx.
  Arguments bitRange /.

  (* TODO: Java throws an exception if idx or length is not unsigned *)
  Definition signExtendBitRange (i idx len : Z) : Z :=
  match len with
  | 0 => 0
  | _ =>
    if Z.testbit i (idx + len - 1)
    then
      let max := Z.shiftl 1 (len - 1) in
        let tmp := bitRange i idx len in
          bitRange (tmp + max) 0 len - max
    else bitRange i idx len
  end.
  Arguments signExtendBitRange /.

  Definition emod (a b : Z) : Z :=
    let rem := Z.rem a b in
    if rem <? 0
    then rem + Z.abs b
    else rem.
  Arguments emod /.

  Definition ediv (a b : Z) : Z :=
    Z.quot (a - emod a b) b.
  Arguments ediv /.

  (* REPORT modPow:
     This is how the Java code works, but every other
     operations is relying on rem, and not on mod!
     Are we sure, that all backends understand mod as rem
     (and div as quot)?
   *)
  Definition modPow (a b c : Z) : Z :=
    Z.modulo (Z.pow a b) c.
  Arguments modPow /.

  Compute modPow (-7) 3 20.

  Definition divides (a b : Z) : bool :=
    Z.rem a b =? 0.
  Arguments divides /.


  (* The model is constructed by defining the type-value set of sorts, and
     the functions that model the symbols. We also need to show that the model
     is inhabited. *)
  Program Definition ImpModel : @Model ImpSignature :=
    mkModel_singleton
      (Ksorts_rect _ bool Z)
      (Ksyms_rect _ true
                    false
                    negb
                    andb
                    andb
                    xorb
                    orb
                    orb
                    implb
                    eqb
                    neqbB
                    id
                    2
                    0
                    1
                    0 (* unsure about this *)
                    Z.rem
                    Z.land (* unsure about this *)
                    Z.mul
                    Z.add
                    Z.sub
                    Z.quot
                    Z.shiftl
                    Z.leb
                    Z.ltb
                    neqbZ
                    Z.eqb
                    Z.geb
                    Z.shiftr
                    Z.gtb
                    modPow (* powmod *)
                    Z.pow (* pow *)
                    ediv (* div *)
                    divides (* divides *)
                    emod (* mod *)
                    Z.lxor (* xor *)
                    Z.lor (* or *)
                    Z.abs (* abs *)
                    bitRange (* bitRange *)
                    (id : Z -> Z) (* fresh *)
                    Z.log2 (* log2 *)
                    Z.max
                    Z.min
                    _ (* rand - how should we model random generation? I could not find the corresponding implementation! *)
                    signExtendBitRange (* signExtendBitRangeInt *)
                    Z.lnot) (* not *)
      ltac:(intros []; auto with typeclass_instances)
      _ (fun _ => None_parser). (* Inhabited proof *)
  Next Obligation.
    simpl. intros x y z. exact (x + y + z).
  Defined.
  Final Obligation.
    intros. inversion X.
  Defined.

  (* We prove the satisfyability/consistency of functional axioms first,
     then we do this for behavioural axioms too. *)
  Goal satT Kint_theory_functional ImpModel.
  Proof.
    unfold satT, satM. intros.

    (* Generate a goal for each axiom: *)
    unfold Kbool_theory_behavioural in H.
    unfold_elem_of; destruct_or?; destruct_ex?; subst; simpl.
    all: solve_functional_axiom.
  Qed.

  Goal satT Kbool_theory_functional ImpModel.
  Proof.
    unfold satT, satM. intros.

    (* Generate a goal for each axiom: *)
    unfold Kbool_theory_behavioural in H.
    unfold_elem_of; destruct_or?; destruct_ex?; subst; simpl.
    all: solve_functional_axiom.
  Qed.

  Goal satT Kbool_theory_behavioural ImpModel.
  Proof.
    (* unfold sat defs *)
    unfold satT, satM. intros.

    (* Generate a goal for each axiom: *)
    unfold Kbool_theory_behavioural in H.
    unfold_elem_of; destruct_or?; destruct_ex?; subst.

    all:
      simplify_krule;
      repeat destruct_evar_val;
      try timeout 1 set_solver.
  Qed.

  Ltac abstract_var := 
    match goal with
      | [|- context [evar_valuation ?σ ?s]] =>
        let x := fresh "var" in
        let Hx := fresh "Hvar" in
          remember (evar_valuation σ s) as x eqn:Hx (*;
          clear Hx;
          revert x *)
      end.

  Lemma sasa : satT Kint_theory_behavioural ImpModel.
  Proof.
    unfold satT, satM. intros.

    (* Generate a goal for each axiom: *)
    unfold Kbool_theory_behavioural in H.
    unfold_elem_of; destruct_or?; destruct_ex?; subst.

    (* 7 axioms are automatically proved by Coq's lia tactic *)
    1-4,9-11: simplify_krule; try set_solver by lia.
    (* However, lia is not capable of handling bit operations and
       division, therefore the following proofs are challenginf: *)
    * simplify_krule.
      repeat abstract_var. clear.
      repeat rewrite negb_true_iff.
      repeat rewrite Z.eqb_neq.
      apply Classical_Prop.imply_to_or. intros.
      destruct_and?; subst. lia.
    * simplify_krule.
      repeat abstract_var.
      repeat rewrite negb_true_iff.
      repeat rewrite Z.eqb_neq.
      apply Classical_Prop.imply_to_or. intros.
      destruct_and?; subst.
      (* potentially INCONSISTENT for var0 = 0 or var2 = 0?
         Java hook throws an exception *)
      simpl in *.
      Fail smt. admit.
    * simplify_krule.
      repeat abstract_var.
      repeat rewrite negb_true_iff.
      repeat rewrite Z.eqb_neq.
      apply Classical_Prop.imply_to_or. intros.
      destruct_and?; subst.
      case_match; try lia.
      - apply Z.ltb_lt in H0.
        rewrite -> Z.rem_abs_r by assumption.
        rewrite -> Z.rem_abs_r by assumption.
        simpl in *. Fail smt.
        admit.
      - apply Z.ltb_nlt in H0.
        repeat rewrite -> Z.rem_abs_r by assumption.
        f_equal.
        simpl in *. Fail smt. admit.
    * simplify_krule.
      repeat abstract_var.
      repeat rewrite negb_true_iff.
      repeat rewrite Z.eqb_neq.
      apply Classical_Prop.imply_to_or. intros.
      destruct_and?; subst.
      simpl in *. Fail smt. admit.
    * simplify_krule.
      repeat abstract_var.
      repeat rewrite negb_true_iff.
      repeat rewrite Z.eqb_neq.
      apply Classical_Prop.imply_to_or. intros.
      destruct_and?; subst.
      simpl in *. Fail smt. admit.
  Admitted.

End ImpSemantics.

